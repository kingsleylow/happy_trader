#include "robot.hpp"
#include "implement.hpp"

namespace AlgLib {
	TradingSequenceRobot::TradingSequenceRobot(CPairTrade& base):
		base_m(base),
		calculatorLevel_m(*this)
	{
		uid_m.generate();
	}

	TradingSequenceRobot::~TradingSequenceRobot()
	{
	}

	void TradingSequenceRobot::initStateMachine()
	{
		MachineContext::MachineContextStructure ctx( base_m, *this, MAIN_FSM);
		// machine managing basse algorithm
		CppUtils::StateMachine<MachineContext> *m = new CppUtils::StateMachine<MachineContext>(&ctx);
		getTradingMachine().setMachine( m );
		

		// register states
		CppUtils::StateMachine<MachineContext> & machine = getTradingMachine().getMachine();

				


// --------------------------------------------
// BEGIN AUTOGENERATED BLOCK
// --------------------------------------------

//INIT MACHINES 
machine.add<TS_Completed>();
machine.add<TS_Some_Positions_Opened>();
machine.add<TS_Ready_Open>();
machine.add<TS_Initial>();
machine.add<TS_Error>();
machine.add<TS_Open_Short>();
machine.add<TS_Open_Long>();
machine.add<TS_Open_Nothing>();
//------------------------ 
//TS_Completed ------------------------ 
machine.state<TS_Completed>().connect<TE_Completed_Long>( machine.state<TS_Open_Long>() );
machine.state<TS_Completed>().connect<TE_Completed_Short>( machine.state<TS_Open_Short>() );

machine.state<TS_Completed>().add_entry_action<A_Completed>();
//--------------------------- 
//TS_Some_Positions_Opened ------------------------ 
machine.state<TS_Some_Positions_Opened>().connect<TE_Executed_All>( machine.state<TS_Completed>() );
machine.state<TS_Some_Positions_Opened>().connect<TE_Execute_Signal,AT_Check_All_Executed>( machine.state<TS_Some_Positions_Opened>() );
machine.state<TS_Some_Positions_Opened>().connect<TE_Broker_Error>( machine.state<TS_Error>() );
machine.state<TS_Some_Positions_Opened>().connect<TE_Stop_Trade>( machine.state<TS_Error>() );
machine.state<TS_Some_Positions_Opened>().connect<TE_Signal_Long,AT_Store_Pending_Signal>( machine.state<TS_Some_Positions_Opened>() );
machine.state<TS_Some_Positions_Opened>().connect<TE_Signal_Short,AT_Store_Pending_Signal>( machine.state<TS_Some_Positions_Opened>() );
machine.state<TS_Some_Positions_Opened>().connect<TE_Timeout>( machine.state<TS_Error>() );


//--------------------------- 
//TS_Ready_Open ------------------------ 
machine.state<TS_Ready_Open>().connect<TE_Execute_Signal>( machine.state<TS_Some_Positions_Opened>() );
machine.state<TS_Ready_Open>().connect<TE_Broker_Error>( machine.state<TS_Error>() );
machine.state<TS_Ready_Open>().connect<TE_Stop_Trade>( machine.state<TS_Error>() );
machine.state<TS_Ready_Open>().connect<TE_Signal_Short,AT_Store_Pending_Signal>( machine.state<TS_Ready_Open>() );
machine.state<TS_Ready_Open>().connect<TE_Signal_Long,AT_Store_Pending_Signal>( machine.state<TS_Ready_Open>() );
machine.state<TS_Ready_Open>().connect<TE_Timeout>( machine.state<TS_Error>() );


machine.state<TS_Ready_Open>().add_entry_action<A_Issue_Pair_Open>();
//--------------------------- 
//TS_Initial ------------------------ 
machine.state<TS_Initial>().connect<TE_Confirm_Open_Long>( machine.state<TS_Open_Long>() );
machine.state<TS_Initial>().connect<TE_Confirm_Open_Short>( machine.state<TS_Open_Short>() );
machine.state<TS_Initial>().connect<TE_Confirm_Open_Nothing>( machine.state<TS_Open_Nothing>() );

machine.state<TS_Initial>().add_exit_action<AE_Init_Context>();
//--------------------------- 
//TS_Error ------------------------ 

machine.state<TS_Error>().add_entry_action<A_Notify_User_Error>();
//--------------------------- 
//TS_Open_Short ------------------------ 
machine.state<TS_Open_Short>().connect<TE_Signal_Long>( machine.state<TS_Ready_Open>() );
machine.state<TS_Open_Short>().connect<TE_Stop_Trade>( machine.state<TS_Initial>() );

machine.state<TS_Open_Short>().add_entry_action<A_Check_Pending_Orders_TS_Open_Short>();
machine.state<TS_Open_Short>().add_exit_action<AE_TS_Open_Short_Exit>();
//--------------------------- 
//TS_Open_Long ------------------------ 
machine.state<TS_Open_Long>().connect<TE_Signal_Short>( machine.state<TS_Ready_Open>() );
machine.state<TS_Open_Long>().connect<TE_Stop_Trade>( machine.state<TS_Initial>() );

machine.state<TS_Open_Long>().add_entry_action<A_Check_Pending_Orders_TS_Open_Long>();
machine.state<TS_Open_Long>().add_exit_action<AE_TS_Open_Long_Exit>();
//--------------------------- 
//TS_Open_Nothing ------------------------ 
machine.state<TS_Open_Nothing>().connect<TE_Signal_Long>( machine.state<TS_Ready_Open>() );
machine.state<TS_Open_Nothing>().connect<TE_Signal_Short>( machine.state<TS_Ready_Open>() );
machine.state<TS_Open_Nothing>().connect<TE_Stop_Trade>( machine.state<TS_Initial>() );

machine.state<TS_Open_Nothing>().add_entry_action<A_Check_Pending_Orders_TS_Open_Nothing>();
machine.state<TS_Open_Nothing>().add_exit_action<AE_TS_Open_Nothing_Exit>();
//--------------------------- 

// --------------------------------------------
// END AUTOGENERATED BLOCK
// -------------------------------------------- 

// initial state - add manually
machine.add<CppUtils::InitialState<MachineContext> >();
machine.state<CppUtils::InitialState<MachineContext> >().connect(machine.state<TS_Initial>(), CppUtils::Unconditional());


			
// -------------------------------------------
			machine.init();
			
			

	}

	void TradingSequenceRobot::deinitStateMachine()
	{
		tradingMachine_m.clear();

		brokerDialogReal_m.deinit();
		brokerDialogDemo_m.deinit();
	}

	void TradingSequenceRobot::init(
		HlpStruct::AlgBrokerDescriptor const& descriptor,
		BrkLib::BrokerBase* brokerlib, 
		CppUtils::String const& runName,
		CppUtils::String const& comment,
		TradeParam const& tradeParam, 
		CppUtils::StringMap const& symbolsFinam,
		CppUtils::StringMap const& symbolsSmartcom,
		CppUtils::StringMap const& symbolsSmartcomReverse, 
		CppUtils::StringSet const& syntheticSmartcomList
	)
	{
		symbolsFinamList_m =	symbolsFinam;
		symbolsSmartcomList_m = symbolsSmartcom;
		symbolsSmartcomReverse_m = symbolsSmartcomReverse;
		syntheticSmartcomList_m = syntheticSmartcomList;

		// 
		

		tradeParam_m = tradeParam;
		initStateMachine();

		// connect to broker
		
		brokerDialogReal_m.initAndConnect(  brokerlib, CppUtils::String(PAIR_TRADE) + "_real", runName, comment, base_m.getRtdataProvider_Smartcom() );
	
		if (!brokerDialogReal_m.isConnected()) {
			LOGEVENT(HlpStruct::CommonLog::LL_ERROR,  PAIR_TRADE, "onLibraryInitialized(...) session cannot be established: " << brokerDialogReal_m.getConnectString());
		}

		// broker connect 2
		
		brokerDialogDemo_m.initAndConnect(  base_m.getAlgHolder().getBroker2(), CppUtils::String(PAIR_TRADE) + "_simul", runName, comment, base_m.getRtdataProvider_Smartcom() );
		if (!brokerDialogDemo_m.isConnected()) {
			LOGEVENT(HlpStruct::CommonLog::LL_ERROR,  PAIR_TRADE, "onLibraryInitialized(...) session with broker lib 2 cannot be established: " << brokerDialogDemo_m.getConnectString());
		}


		if (tradeParam_m.isInvalid())
			THROW(CppUtils::OperationFailed, "exc_TradeParamsInvalid", "ctx_onLibraryInitialized", tradeParam_m.toDescriptionString() );

		calculatorLevel_m.initialized();
		

		LOG_COMMON(base_m.getRunName(), base_m.getRtdataProvider_Smartcom(), BrkLib::AP_MEDIUM, "Trading parameters: " << tradeParam_m.toDescriptionString());

	}

	void TradingSequenceRobot::deinit()
	{
		calculatorLevel_m.deinitialized();
		deinitStateMachine();

	}
	
		
		// ------------

	

	

	void TradingSequenceRobot::onDataArrived(
				HlpStruct::RtData const& rtdata, 
				Inqueue::ContextAccessor& historyaccessor, 
				HlpStruct::TradingParameters const& descriptor,
				BrkLib::BrokerBase* brokerlib,
				CppUtils::String const& runName,
				CppUtils::String const& comment
			)
	{
		

		// only BAR symbols
			
		if (rtdata.getProvider2() == getBase().getBarDataProvider_Smartcom()) {
			CalcContext ctx;
			ctx.historyaccessorPtr = &historyaccessor;
			ctx.tradeParameters_m = (HlpStruct::TradingParameters*)&descriptor;

			calculatorLevel_m.onRtData(rtdata, &ctx);
		}
	}
			
	void TradingSequenceRobot::onRtProviderSynchEvent (
				Inqueue::ContextAccessor& contextaccessor, HlpStruct::RtData::SynchType const synchFlg,
				double const& synchTime,
				CppUtils::String const& providerName,
				CppUtils::String const& message
			)
	{
	}

	void TradingSequenceRobot::onLevel2DataArrived(
				HlpStruct::RtLevel2Data const& level2data,
				Inqueue::ContextAccessor& historyaccessor, 
				HlpStruct::TradingParameters const& descriptor,
				BrkLib::BrokerBase* brokerlib,
				CppUtils::String const& runName,
				CppUtils::String const& comment
			)
	{
		if (level2data.getProvider2() == base_m.getRtdataProvider_Smartcom()) {
			calculatorLevel_m.onLevel2Data(level2data, NULL);
		}
	}

	void TradingSequenceRobot::onLevel1DataArrived(
				HlpStruct::RtLevel1Data const& level1data,
				Inqueue::ContextAccessor& historyaccessor, 
				HlpStruct::TradingParameters const& descriptor,
				BrkLib::BrokerBase* brokerlib,
				CppUtils::String const& runName,
				CppUtils::String const& comment
			)
	{
	}

	void TradingSequenceRobot::onThreadStarted(Inqueue::ContextAccessor& contextaccessor, bool const firstLib, bool const lastLib )
	{
		CalcContext ctx;
		ctx.historyaccessorPtr = &contextaccessor;

		calculatorLevel_m.onThreadStarted(&ctx);
		
	}

	void TradingSequenceRobot::onThreadFinished(Inqueue::ContextAccessor& contextaccessor, HlpStruct::TradingParameters const& tradeParams, bool const firstLib, bool const lastLib )
	{
		

		CalcContext ctx;
		ctx.historyaccessorPtr = &contextaccessor;
		calculatorLevel_m.onThreadFinished(&ctx);
	}

	BrokerDialog& TradingSequenceRobot::resolveBrokerDialog()
	{
		return tradeParam_m.isDemoTrade_m ? brokerDialogDemo_m:brokerDialogReal_m;
	}
													   

	void TradingSequenceRobot::simulateUp()
	{
		TE_Signal_Long e;
		getTradingMachine().processEvent<TE_Signal_Long>(e);	
	}

	void TradingSequenceRobot::simulateDown()
	{
		TE_Signal_Short e;
		getTradingMachine().processEvent<TE_Signal_Short>(e);	
	}

	void TradingSequenceRobot::sendInitialEvent(BrkLib::TradeDirection const init_position)
	{
		LOG_COMMON(base_m.getRunName(),getBase().getBarDataProvider_Smartcom(), BrkLib::AP_MEDIUM, "Sending initial event confirming that our current position is: " << BrkLib::tradeDirection2String(init_position));

		if (init_position == BrkLib::TD_LONG) {
			TE_Confirm_Open_Long e;
			getTradingMachine().processEvent<TE_Confirm_Open_Long>(e);
		}
		else if (init_position == BrkLib::TD_SHORT) {
			TE_Confirm_Open_Short e;
			getTradingMachine().processEvent<TE_Confirm_Open_Short>(e);
		}
		else if (init_position == BrkLib::TD_NONE) {
			TE_Confirm_Open_Nothing e;
			getTradingMachine().processEvent<TE_Confirm_Open_Nothing>(e);

		}
		else
			THROW(CppUtils::OperationFailed, "exc_InvalidDirectionType", "ctx_sendInitialEvent", BrkLib::tradeDirection2String(init_position));
	}

	void TradingSequenceRobot::sendStopTradeEvent()
	{
		LOG_COMMON(base_m.getRunName(),getBase().getBarDataProvider_Smartcom(), BrkLib::AP_MEDIUM, "Sending stop trade event");


		TE_Stop_Trade e;
		getTradingMachine().processEvent<TE_Stop_Trade>(e);
	}

	

}; // end of ns											  