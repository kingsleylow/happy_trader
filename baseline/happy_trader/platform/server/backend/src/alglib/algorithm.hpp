#ifndef _ALGLIB_ALGORITHM_INCLUDED
#define _ALGLIB_ALGORITHM_INCLUDED


#include "alglibdefs.hpp"



namespace Inqueue {
	class AlgorithmHolder;
	struct AlgBrokerDescriptor;
	struct TradingParameters;
	class ContextAccessor;
	enum AlgorithmStatus;
	class OutProcessor;
}

namespace BrkLib {
	class BrokerSession;
	class BrokerConnect;
	class BrokerResponseBase;
	class BrokerBase;
	class Order;
	class Position;
	//typedef vector<Position> PositionList;
	enum OperationResult;
	typedef vector<BrokerResponseBase> BrokerResponseList;
};


namespace AlgLib {
	/**
		This is the base class for all the implemented algorithms 
	*/
	class ALGLIB_EXP AlgorithmBase: private CppUtils::Mutex {
		friend class Inqueue::AlgorithmHolder;
		
	public:

		typedef AlgorithmBase* (*CreatorAlgorithmFun) (Inqueue::AlgorithmHolder* );

		typedef void (*DestroyerAlgorithmFun) (AlgorithmBase*);

		// ctor & dtor
		AlgorithmBase( Inqueue::AlgorithmHolder& algHolder);

		virtual ~AlgorithmBase();

		// from here it is called derived onEventArrived
		virtual bool processAlgorithmRelatedEvent(
			HlpStruct::EventData const &request, 
			Inqueue::ContextAccessor& contextaccessor, 
			HlpStruct::EventData& response
		);

		
		// intreface to be implemented
		// passing optional broker ptr 
		virtual void onLibraryInitialized(
			HlpStruct::AlgBrokerDescriptor const& descriptor,
			BrkLib::BrokerBase* brokerlib,
			BrkLib::BrokerBase* brokerlib2,
			CppUtils::String const& runName,
			CppUtils::String const& comment
		) = 0;

		virtual void onLibraryFreed() = 0;

		// this is event from external layer 
		// it can be used for example to manualy work with orders, whatever
		// passing context accessor here
		virtual void onEventArrived(
			Inqueue::ContextAccessor& contextaccessor, 
			HlpStruct::CallingContext& callContext,
			bool& result,
			CppUtils::String &customOutputData
		) = 0;

		virtual void onThreadStarted(
			Inqueue::ContextAccessor& contextaccessor, bool const firstLib, bool const lastLib
		) = 0;

		virtual void onThreadFinished(
			Inqueue::ContextAccessor& contextaccessor, HlpStruct::TradingParameters const& tradeParams, bool const firstLib, bool const lastLib
		) = 0;


		
		// passing here optional brokerlib entry
		virtual void onDataArrived(
			HlpStruct::RtData const& rtdata, 
			Inqueue::ContextAccessor& historyaccessor, 
			HlpStruct::TradingParameters const& descriptor,
			BrkLib::BrokerBase* brokerlib,
			CppUtils::String const& runName,
			CppUtils::String const& comment
		) = 0;

		virtual void onRtProviderSynchEvent (
			Inqueue::ContextAccessor& contextaccessor,
			HlpStruct::RtData::SynchType const synchFlg,
			double const& synchTime,
			CppUtils::String const& providerName,
			CppUtils::String const& message
		) = 0;


		virtual void onLevel2DataArrived(
			HlpStruct::RtLevel2Data const& level2data,
			Inqueue::ContextAccessor& historyaccessor, 
			HlpStruct::TradingParameters const& descriptor,
			BrkLib::BrokerBase* brokerlib,
			CppUtils::String const& runName,
			CppUtils::String const& comment
		) = 0;

		virtual void onLevel1DataArrived(
			HlpStruct::RtLevel1Data const& level1data,
			Inqueue::ContextAccessor& historyaccessor, 
			HlpStruct::TradingParameters const& descriptor,
			BrkLib::BrokerBase* brokerlib,
			CppUtils::String const& runName,
			CppUtils::String const& comment
		) = 0;

		// this is event generated by broker (if any) that broker event arrived
		// event function called by broker layer 
		// passing current HlpStruct::TradingParameters - that may change asynchroniously
		// note that this function can be called either from current therad when using backtest simulator
		// as ...IssueOrder() will, call internalyy this event
		// but actual brokers may call this from separate thread
		
		virtual void onBrokerResponseArrived(
			BrkLib::BrokerConnect &brkConnect,
			BrkLib::BrokerResponseBase const& bresponse
		) = 0;


		// returns algorithm name
		virtual CppUtils::String const& getName() const = 0;

	
		
	public:

		
				
		// hold data over <onDataArrived> calls over many threads!!!
		HlpStruct::GlobalStorage& getGlobalStorage();
			
		
		inline Inqueue::AlgorithmHolder const& getAlgHolder() const
		{
			return algHolder_m;
		}

		inline Inqueue::AlgorithmHolder& getAlgHolder()
		{
			return algHolder_m;
		}
	
	private:

		// machine state
		CppUtils::Mutex stateMtx_m;

		int state_m;

		//
		HlpStruct::GlobalStorage globalStorage_m;

    //		
		Inqueue::AlgorithmHolder& algHolder_m;

		
		Inqueue::OutProcessor &outproc_m;

		
	};
};

#endif
