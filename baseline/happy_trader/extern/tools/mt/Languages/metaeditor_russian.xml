<?xml version="1.0" encoding='windows-1251'?>
<dictionary>
  tag=MetaQuotesLanguage
  caption=Язык MetaQuotes 4
  charset=windows-1251
  lang_params=Параметры:
  lang_sample=Пример:
  <styles>
  *           { font-family: Tahoma, Verdana, Arial, Helvetica, sans-serif; font-size:1em; }
  body        { margin-top: 3px; margin-bottom: 3px; padding-left: 3px; padding-right: 3px; margin: 3px; padding: 3px; background-color:#fbfbfc; color:#626363; font-size:0.8em; }
  div, p      { margin:0px; padding: 0px; }
  p           { margin-bottom: 12px; }
  ul          { list-style-type: square; }
  a           { color:#42639C; }
  
  td.l_smb    { font: 12pt Wingdings; }
  td.d_smb    { font: 12pt Wingdings;background: #E8E8FF; }
  td.l_code   { border-right: 1px #a8afaa solid; }
  td.d_code   { border-right: 1px #a8afaa solid;background: #e8e8ff; }
  td.d_code_e { background: #e8e8ff; }
  table.symbols{font-family: tahoma; font-size: 8pt; border: thin solid #a8afaa;}
  
  .docmenu    { width:200px; margin-right:15px; border-right:1px solid #DADADA; background-color:#f6f9fd; padding-left:10px; padding-right:10px; margin-bottom:5px; }
  .doctext    { margin-right:15px; padding-left:10px; padding-right:0px; margin-bottom:5px; padding-bottom:10px; padding-top:6px; }
  .docnav     { clear:both; width:100%; text-align:right; padding-top:4px; border-top:1px solid #DADADA; }
  .docfunc    { color: #8A2BE2; }
  .doctable   { border-top:1px solid #DADADA;  }
  .docvar     { font-family: monospace; font-size: 10pt; font-weight:bold; margin-bottom: 4pt; }
  .doctabhdr  { font-weight:bold; padding: 0pt 4pt 0pt 0pt; margin: 8pt 2pt 2pt 2pt;  }
  .docmql4    { background-color: #F6F9FC; border: 1px #d8dfea solid; padding: 2pt 2pt 2pt 2pt; margin: 2pt 0pt 2pt 15pt; font-family: monospace; }
  .docparams  { background-color: #F6F9FC; border: 1px #d8dfea solid; font-family: Tahoma; font-size: 9pt; margin-left: 15pt; }
  .docenums    { background-color: #F6F9FC; border-top: 1px #d8dfea solid; border-left: 1px #d8dfea solid; font-family: Tahoma; font-size: 9pt; margin-left: 15pt; width: 95%; }
  .docenums th { vertical-align: top; background-color: #d8dfea; border-bottom: 1px #d8dfea solid; border-right: 1px #d8dfea solid;font-family: Tahoma; font-size: 9pt; }
  .docenums td { vertical-align: top; background-color: #F6F9FC; border-bottom: 1px #d8dfea solid; border-right: 1px #d8dfea solid;font-family: Tahoma; font-size: 9pt; }
  </styles>

  <group>
    tag=index
    caption=Справочник MQL4
    
    <content>
      <p>MetaQuotes Language 4 (MQL4) - новый встроенный язык программирования торговых стратегий.
      Этот язык позволяет писать собственные программы-эксперты (Expert Advisors), автоматизирующие управление торговыми 
      процессами и идеально подходящие для реализации собственных торговых стратегий. Кроме того, на MQL4 можно создавать 
      собственные технические индикаторы (Custom Indicators), скрипты (Scripts) и библиотеки функций (Libraries). Изучение языка
      вы можете начать с помощью книги Сергея Ковалева &quot;Программирование на алгоритмическом языке MQL4&quot;, которая была 
      написана при поддержке <a target="_blank" href="http://www.metaquotes.ru/?source=metaeditor_help">MetaQuotes Software Corp.</a> Скачать Учебник
      в формате справки можно по адресу: <a href="http://www.mql4.com/files/mql4bookrussian.chm?source=metaeditor_help">http://www.mql4.com/files/mql4bookrussian.chm</a> (размер 2.0 Mb).</p>

      <p>В состав MQL4 включено большое количество функций, необходимых для анализа текущих и пришедших ранее котировок,
      встроены основные индикаторы и функции по управлению торговыми позициями и контролю над ними.</p>

      <p>Для написания кода программы используется текстовый редактор экспертов MetaEditor 4, выделяющий цветом
      различные конструкции языка MQL4, что позволяет пользователю лучше ориентироваться в тексте экспертной системы.
      В качестве справочной системы по языку MQL4 используется словарь - MetaQuotes Language Dictionary.
      Краткий справочник содержит разбитые на категории функции, операции, зарезервированные слова,
      другие конструкции языка и позволяет узнать описание каждого используемого элемента, входящего в язык.</p>
        
      <p>Программы, написанные на MetaQuotes Language 4, имеют различные свойства и предназначение:</p>
      <ul><li><p>
            <strong>Советник</strong> (Expert Advisor) - это механическая торговая система (МТС), имеющая привязку к определенному графику.
            Советник запускается на выполнение с каждым поступающим тиком по данному инструменту. Советник не будет запущен для вновь поступившего
            тика, если в этот момент советник обрабатывает предыдущий тик (то есть, советник еще не закончил свою работу).
            Советник может не только работать в режиме информирования о возможности совершить сделки, но и
            автоматически совершать сделки на торговом счете, направляя их прямо на торговый сервер.
            Как и в большинстве информационных систем, в терминале поддерживается тестирование стратегий на
            исторических данных с отображением на графиках точек входа в торговые позиции и выхода из них.
            Советники хранятся в директории <strong>каталог_терминала\experts</strong></p></li>
          <li><p>
            <strong>Пользовательский индикатор</strong> (Custom Indicator) - технический индикатор, самостоятельно написанный пользователем в дополнение к индикаторам, уже
            интегрированным в клиентский терминал. Пользовательские индикаторы, также как и встроенные, не могут автоматически
            торговать и предназначены только для реализации аналитических функций.
            Пользовательские индикаторы хранятся в директории <strong>каталог_терминала\experts\indicators</strong></p></li>
          <li><p>
            <strong>Скрипт</strong> (Script) - программа, предназначенная для одноразового выполнения каких-либо действий. 
            В отличие от экспертов, скрипты запускаются не потиково, а по запросу.
            Скрипты хранятся в директории <strong>каталог_терминала\experts\scripts</strong></p></li>
          <li><p>
            <strong>Библиотека</strong> (Library) - библиотека пользовательских функций, предназначенная для хранения и распространения часто 
            используемых блоков пользовательских программ. Библиотеки не могут самостоятельно запускаться на выполнение.<br/>
            Библиотеки рекомендуется хранить в директории <strong>каталог_терминала\experts\libraries</strong></p></li>
          <li><p>
            <strong>Включаемый файл</strong> (Included file) - исходный текст часто используемых блоков пользовательских программ. 
            Такие файлы могут включаться в исходные тексты экспертов, скриптов, пользовательских индикаторов и библиотек на этапе 
            компиляции. Использование включаемых файлов более предпочтительно, чем использование библиотек,
            из-за дополнительных накладных расходов при вызове библиотечных функций.
            Включаемые файлы рекомендуется хранить в директории <strong>каталог_терминала\experts\include</strong></p></li>
      </ul>
    </content>
    
  <group>
    tag=basis
    caption=Основы языка
    
    <content>
      <p>Язык MetaQuotes Language 4 (MQL4) - новый встроенный язык программирования торговых стратегий.
      Этот язык позволяет писать собственные программы-эксперты (Expert Advisors), автоматизирующие управление торговыми 
      процессами и идеально подходящие для реализации собственных торговых стратегий. Кроме того, на MQL4 можно создавать 
      собственные технические индикаторы (Custom Indicators), скрипты (Scripts) и библиотеки функций (Libraries).</p>
    </content>
    
  <group>
    tag=basis_syntax
    caption=Синтаксис

    <content>
      <p>Синтаксис языка программирования торговых стратегий MQL4 синтаксически очень похож язык программирования Си, за исключением некоторых возможностей:</p>
      <ul><li><p>
      отстутствует адресная арифметика;</p></li>
      <li><p>
      отсутствует оператор do ... while;</p></li>
      <li><p>
      отсутствует оператор goto ...;</p></li>
      <li><p>
      отсутствует операция [условие]?[выражение 1]:[выражение 2];</p></li>
      <li><p>
      отсутствуют сложные типы данных (структуры);</p></li>
      <li><p>
      невозможны сложные присваивания. Например, val1=val2=0; arr[i++]=val; cond=(cnt=OrdersTotal)>0; и т.п.;</p></li>
      <li><p>
      вычисление логического выражения производится до конца и не прерывается досрочно.</p></li>
      </ul>
    </content>
    
    <text>
      tag=basis_syntax_comments
      caption=Комментарии
      <content>
        <p>Многострочные комментарии начинаются парой символов /* и заканчиваются парой */.
        Данные комментарии не могут быть вложенными. Однострочные комментарии начинаются парой символов //,
        заканчиваются символом новой строки и могут быть вложены в многострочные комментарии.
        Комментарии разрешены везде, где возможны пробелы, и допускают любое число пробелов.</p>
        <p class="doctabhdr">Примеры:</p>
        <pre class="docmql4">// Однострочный комментарий

/*  Многостроч-
    ный         // Вложенный однострочный комментарий
    комментарий
*/</pre>
      </content>
    </text>
    
    <text>
      tag=basis_syntax_identifiers
      caption=Идентификаторы
      <content>
        <p>Идентификаторы используются в качестве имен для переменных и функций.
        Длина идентификатора не может превышать 31 знак.</p>
        <p>Допустимые символы: цифры 0-9, латинские прописные и строчные буквы
        а - z и А - Z, распознаваемые как разные символы, символ подчеркивания (_).
        Первый символ не может быть цифрой. Идентификатор не должен совпадать с зарезервированным словом.</p>
        <p class="doctabhdr">Примеры:</p>
        <pre class="docmql4">NAME1 namel Total_5 Paper</pre>
      </content>
    </text>

    <text>
      tag=basis_syntax_reserved
      caption=Зарезервированные слова
      <content>
        <p>Перечисленные ниже идентификаторы фиксируются как зарезервированные слова,
        каждому из которых соответствует определенное действие, и в другом смысле не могут использоваться:</p>

        <table cellspacing="0" cellpadding="4" border="0" class="docenums">
        <tr><th width="25%">Типы данных</th><th width="25%">Классы памяти</th><th width="25%">Операторы</th><th width="25%">Прочие</th></tr>
        <tr><td>bool</td><td>extern</td><td>break</td><td>false</td></tr>
        <tr><td>color</td><td>static</td><td>case</td><td>true</td></tr>
        <tr><td>datetime</td><td>&nbsp;</td><td>continue</td><td>&nbsp;</td></tr>
        <tr><td>double</td><td>&nbsp;</td><td>default</td><td>&nbsp;</td></tr>
        <tr><td>int</td><td>&nbsp;</td><td>else</td><td>&nbsp;</td></tr>
        <tr><td>string</td><td>&nbsp;</td><td>for</td><td>&nbsp;</td></tr>
        <tr><td>void</td><td>&nbsp;</td><td>if</td><td>&nbsp;</td></tr>
        <tr><td>&nbsp;</td><td>&nbsp;</td><td>return</td><td>&nbsp;</td></tr>
        <tr><td>&nbsp;</td><td>&nbsp;</td><td>switch</td><td>&nbsp;</td></tr>
        <tr><td>&nbsp;</td><td>&nbsp;</td><td>while</td><td>&nbsp;</td></tr>
        </table><br/>
      </content>
    </text>
  </group>


  <group>
    tag=basis_types
    caption=Типы данных
    
    <content>
     <p>Любая программа оперирует данными. Данные могут быть различных типов в зависимости от назначения.
     Например, для доступа к элементам массива используются данные целочисленного типа. Ценовые данные имеют тип двойной
     точности с плавающей точкой. Это связано с тем, что в языке MQL 4 не предусмотрено специального типа для ценовых данных.</p>
     <p>Данные разного типа обрабатываются с разной скоростью. Целочисленные данные обрабатываются быстрее всего.
     Для обработки данных двойной точности используется специальный сопроцессор. Однако из-за сложности внутреннего представления
     данных с плавающей точкой, они обрабатывается дольше, чем целочисленные. Дольше всего обрабатываются строковые данные. Это
     связано с динамическим распределением-перераспределением оперативной памяти компьютера.</p>
     <p>Основные типы данных:</p>
     <ul><li><a href="help://basis_types_integer">целые (int)</a></li>
         <li><a href="help://basis_types_bool">логические (bool)</a></li>
         <li><a href="help://basis_types_literal">литералы (char)</a></li>
         <li><a href="help://basis_types_string">строки (string)</a></li>
         <li><a href="help://basis_types_double">с плавающей точкой (double)</a></li>
         <li><a href="help://basis_types_color">цвет (color)</a></li>
         <li><a href="help://basis_types_datetime">дата и время (datetime)</a></li>
     </ul>

     <p>Типы <em>color</em> и <em>datetime</em> имеют смысл только для удобства представления и ввода параметров,
     задаваемых извне - из таблицы свойств советника или пользовательского индикатора (вкладка "Inputs").
     Данные типов color и datetime представляются в виде целых чисел. Целые типы вместе с типами с плавающей точкой 
     называются арифметическими (числовыми) типами.</p>
     <p>В <a href="help://basis_operations_expression">выражениях</a> используется только неявное <a href="help://basis_types_casting">приведение типов</a>.</p>
    </content>

    <text>
      tag=basis_types_casting
      caption=Приведение типов
      <content>
        <p>В <a href="help://basis_operations_expression">выражениях</a> языка MQL 4 используется только неявное приведение типов. Приоритет типов при преобразовании в порядке возрастания:</p>
        <pre class="docmql4">
int  (bool,color,datetime);
double;
string;</pre>
        <p>Перед выполнением операций (кроме операций присваивания) происходит преобразование в тип, имеющий наибольший 
        приоритет, а перед операциями присваивания - в целевой тип.</p>
        <p class="doctabhdr">Примеры:</p>
        <pre class="docmql4">
int    i = 1 / 2;     // приведения типов нет, результат: 0
int    i = 1 / 2.0;   // выражение приводится к типу double, затем приводится к целевому типу int, результат: 0
double d = 1.0 / 2.0; // приведения типов нет, результат: 0.5
double d = 1 / 2.0;   // выражение приводится к типу double, который совпадает с целевым типом, результат: 0.5
double d = 1 / 2;     // выражение типа int приводится к целевому типу double, результат: 0.0
string s = 1.0 / 8;   // выражение приводится к типу double, затем приводится к целевому типу string, результат: &quot;0.12500000&quot; (строка, содержащая 10 символов)
string s = NULL;      // константа типа int приводится к целевому типу string, результат: &quot;0&quot; (строка, содержащая один символ)
string s = &quot;Ticket #&quot;+12345; // выражение приводится к типу string, который совпадает с целевым типом, результат: &quot;Ticket #12345&quot;
</pre>
        <p>Приведение типов применяется не только к константам, но и <a href="help://basis_variables">переменным</a> разных типов.</p>
      </content>
    </text>

    <text>
      tag=basis_types_integer
      caption=Целые константы (int)
      keywords=;int;
      <content>
        <p>Десятичные: цифры 0-9; первой цифрой не должен быть 0.</p>
        <p class="doctabhdr">Примеры:</p>
        <pre class="docmql4">12, 111, -956 1007</pre><br/>
       
        <p>Шестнадцатеричные:  цифры 0-9, буквы а - f или А - F для значений 10-15; начинаются с Ох или ОХ.</p>
        <p class="doctabhdr">Примеры:</p>
        <pre class="docmql4">0x0A, 0x12, 0X12, 0x2f, 0xA3, 0Xa3, 0X7C7</pre>
        
        <p>Внутреннее представление - длинное целое число размером 4 байта. Целые константы могут принимать значения 
        от -2147483648 до 2147483647. Если константа превышает указанный диапазон, то результат не определен.</p>
      </content>
    </text>

    <text>
      tag=basis_types_literal
      caption=Символьные константы
      <content>
        <p>Любой одиночный символ, заключенный в одинарные кавычки, или шестнадцатеричный
        ASCII-код символа в виде '\x10' является символьной константой и имеет тип int.
        Некоторые символы, например, одинарные кавычки ('), двойные кавычки (&quot;), знак вопроса (?),
        обратная косая черта (\) и управляющие символы можно представлять комбинацией символов,
        начинающейся с обратной косой черты(\), в соответствии с приводимой ниже таблицей:</p>
<pre class="docmql4">
новая строка (перевод строки)          NL (LF)  \n
горизонтальная табуляция               HT       \t
возврат каретки                        CR       \r
обратная косая черта                   \        \\
одинарная кавычка                      '        \'
двойная кавычка                        "        \"
шестнадцатеричный ASCII-код            hh       \xhh
</pre>

        <p>Если за обратной косой чертой следует символ, отличный от перечисленных, результат не определяется:</p>
        <pre class="docmql4">
int a = 'A';
int b = '$';
int c = '&#xA9;';      // код 0xA9
int d = '\xAE';   // код символа &#xAE;</pre>
        
        <p>Внутреннее представление - длинное целое число размером 4 байта. Символьные константы могут принимать 
        значения от 0 до 255. Если константа превышает указанный диапазон, то результат не определен.</p>
      </content>
    </text>

    <text>
      tag=basis_types_bool
      caption=Логические константы (bool)
      keywords=;bool;true;false;
      <content>
        <p>Логические константы имеют значение true (истина) или false (ложь), числовое представление которых 
        1 или 0 соответственно. Могут использоваться написания True, TRUE, False и FALSE.</p>
        <p class="doctabhdr">Примеры:</p>
        <pre class="docmql4">
bool a = true;
bool b = false;
bool c = 1;</pre>
        <p>Внутреннее представление - длинное целое число размером 4 байта. Логические константы могут принимать 
        значения 0 и 1.</p>
      </content>
    </text>

    <text>
      tag=basis_types_double
      caption=Константы с плавающей точкой (double)
      keywords=;double;
      <content>
        <p>Константы с плавающей точкой состоят из целой части, точки (.) и дробной части.
        Целая и дробная части представляют собой последовательности десятичных цифр.</p>
        <p class="doctabhdr">Примеры:</p>
        <pre class="docmql4">double a = 12.111;
double b = -956.1007;
double c = 0.0001;
double d = 16;</pre>

        <p>Внутреннее представление - число двойной точности размером 8 байт. Пределы изменения от 
        -1.7 * e-308 до 1.7 * e308. Точность обеспечивается не более, чем 15 значащими цифрами.</p>
      </content>
    </text>

    <text>
      tag=basis_types_string
      caption=Строковые константы (string)
      keywords=;string;
      <content>
        <p>Строковая константа представляет собой последовательность символов кода ASCII,
        заключенную в двойные кавычки: &quot;Character constant&quot;.</p>

        <p>Строковая константа - это массив символов, заключенный в кавычки. Она имеет тип string.
        Если необходимо ввести в строку двойную кавычку (&quot;), то перед ней надо поставить символ обратной косой черты (\).
        В строку могут быть введены любые специальные <a href="help://basis_types_literal">символьные константы</a>, перед которыми стоит символ обратной косой черты (\).
        Длина строковой константы - от 0 до 255 символов. Если длина строковой константы превосходит максимальную, лишние 
        символы справа отбрасываются, и компилятор выдает соответствующее предупреждение.</p>
        <p class="doctabhdr">Примеры:</p>
<pre class="docmql4">
"This is a character string"
"Это строковая константа"
"Символ копирайта\t\xA9"
"эта строка содержит символ перевода строки \n"
"C:\\Program Files\\MetaTrader 4"
"А" "1234567890" "О" "$"
</pre>

        <p>Внутреннее представление - структура размером 8 байт. Первый элемент структуры - длинное целое, содержит 
        размер распределенного для строки буфера. Второй элемент структуры - 32-разрядный адрес буфера, содержащего строку.</p>
      </content>
    </text>

    <text>
      tag=basis_types_color
      caption=Цветовые константы (color)
      keywords=;color;
      <content>
        <p>Цветовые константы могут быть представлены тремя различными способами: литерально, целочисленно или при помощи 
        имени (только для именованных Web-цветов).</p>
        
        <p>Литеральное представление состоит из трех частей, представляющих числовые значения интенсивности трех основных компонент 
        цвета: красной (red), зеленой (green), синей (blue). Константа начинается с символа C и обрамляется одинарными кавычками. 
        Числовые значения интенсивности компоненты цвета лежат в диапазоне от 0 до 255.</p>
        
        <p>Целочисленное представление записывается в виде шестнадцатеричного или десятичного числа. Шестнадцатеричное число имеет 
        вид 0x00BBGGRR, где RR - значение интенсивности красной компоненты цвета, GG - зеленной, а BB - синей. Десятичные константы 
        не имеют прямого отражения в RGB. Они представляют собой десятичное значение шестнадцатеричного целочисленного представления.</p>
        
        <p>Именованные цвета отражают так называемый <a href="help://constants_colors">набор Web-цветов</a>.</p>
        <p class="doctabhdr">Примеры:</p>
        <pre class="docmql4">// литералы
C'128,128,128'    // серый
C'0x00,0x00,0xFF' // синий
//названия цветов
Red               // красный
Yellow            // желтый
Black             // черный
// целочисленные представления
0xFFFFFF          // белый
16777215          // белый
0x008000          // зеленый
32768             // зеленый</pre>
        
        <p>Внутреннее представление - длинное целое число размером 4 байта. Первый байт не учитывается. Остальные 3 байта 
        содержат RGB-составляющие.</p>
      </content>
    </text>

    <text>
      tag=basis_types_datetime
      caption=Константы даты и времени (datetime)
      keywords=;datetime;
      <content>
        <p>Константы даты и времени могут быть представлены в виде литеральной строки, которая состоит из 6 частей, 
        представляющих числовое значение года, месяца, числа (либо числа, месяца, года), часа, минуты и секунды. Константа обрамляется 
        одинарными кавычками и начинается с символа D.
        Может опускаться либо дата (год, месяц, число), либо время (часы, минуты, секунды), либо все вместе.
        Диапазон значений от 1 января 1970 года до 31 декабря 2037 года.</p>
        <p class="doctabhdr">Примеры:</p>
        <pre class="docmql4">
D'2004.01.01 00:00'     // Новый Год
D'1980.07.19 12:30:27'
D'19.07.1980 12:30:27'
D'19.07.1980 12'        //равнозначно D'1980.07.19 12:00:00'
D'01.01.2004'           //равнозначно D'01.01.2004 00:00:00'
D'12:30:27'             //равнозначно D'[дата компиляции] 12:30:27'
D''                     //равнозначно D'[дата компиляции] 00:00:00'</pre>

        <p>Внутреннее представление - длинное целое число размером 4 байта. Значение представляет собой количество 
        секунд, прошедшее с 00:00 1 января 1970 года.</p>
      </content>
    </text>
  </group>


  <group>
    tag=basis_operations
    caption=Операции и выражения
    <content>
     Некоторым символам и символьным последовательностям придается особое значение. Это - так называемые символы операций, например:
        <pre class="docmql4">
+ - * / %     символы арифметических операций
&amp;&amp; ||         символы логических операций
= += *=       символы операций присваивания</pre>
     <p>Символы операций используются в выражениях и имеют смысл тогда, когда им даны соответствующие операнды<br/><br/>
     Также особое значение придается знакам препинания. Знаки препинания включают круглые скобки, фигурные скобки, запятую, двоеточие и точку с запятой.<br/><br/>
     Символы операций, знаки препинания и пробелы служат для того, чтобы отделять элементы языка.</p>
    </content>
    
    <text>
      tag=basis_operations_expression
      caption=Выражения
      <content>
        <p>Выражение состоит из одного или нескольких операндов и символов операций. Может записываться в несколько строк.</p>
        <p class="doctabhdr">Примеры:</p>
        <pre class="docmql4">
a++; b = 10;
x = (y * z) / 
    (w + 2) + 127;</pre>
        <p>Выражение, заканчивающееся точкой с запятой (;), является оператором.</p>
      </content>
    </text>

    <text>
      tag=basis_operations_math
      caption=Арифметические операции
      keywords=;+;-;*;/;%;++;--;
      <content>
        <p>К арифметическим относятся аддитивные и мультипликативные операции:</p>
<pre class="docmql4">
Сумма величин                           i = j + 2;
Вычитание величин                       i = j - 3;
Изменение знака                         x = - x;
Умножение величин                       z = 3 * x;
Частное от деления                      i = j / 5;
Остаток от деления                      minutes = time % 60;
Добавление 1 к значению переменной      i++;
Вычитание 1 от значения переменной      k--;</pre>
        <p>Операции увеличения/уменьшения значения переменной не могут применяться в выражениях.</p>
        <p class="doctabhdr">Примеры:</p>
        <pre class="docmql4">int a=3;
a++;            // верное выражение
int b=(a++)*3;  // неверное выражение</pre>
      </content>
    </text>

    <text>
      tag=basis_operations_assign
      caption=Операция присваивания
      keywords=+=;-=;*=;/=;%=;&gt;&gt;=;&lt;&lt;=;&amp;=;|=;^=;
      <content>
        <p>Значением выражения, в которое входит операция присваивания, является значение левого операнда после присваивания:</p>
        <pre class="docmql4">Присваивание значения x переменной y                   у = x;</pre><br/>
        
        <p>Следующие операции объединяют арифметические или побитовые операции с операцией присваивания:</p>
        <pre class="docmql4">
Увеличение значения переменной у на x                  у += x;
Уменьшение значения переменной y на x                  y -= x;
Умножение значения переменной y на x                   y *= x;
Деление значения переменной y на x                     y /= x;
Остаток от деления значения переменной y на x          y %= x;
Сдвиг двоичного представления y вправо на x бит        y &gt;&gt;= x;
Сдвиг двоичного представления y влево на x бит         y &lt;&lt;= x;
Побитовая операция И двоичных представлений y и x      y &amp;= x;
Побитовая операция ИЛИ двоичных представлений y и x    y |= x;
Побитовая операция исключающее ИЛИ
          двоичных представлений y и x                 y ^= x;</pre><br/>

        <p>В выражении может быть только одна операция присваивания. Побитовые операции производятся только с целыми числами. 
        При выполнении операции логический сдвиг представления y вправо/влево на x бит используются младшие 5 двоичных разрядов значения x, 
        старшие разряды отбрасываются, то есть сдвиг производится на 0-31 бит. При выполнении операции %= (значение y по модулю x) знак результата 
        совпадает со знаком делимого.</p>
      </content>
    </text>

    <text>
      tag=basis_operations_relation
      caption=Операции отношения
      keywords=;==;!=;&lt;;&gt;;&lt;=;&gt;=;
      <content>
        <p>Логическое значение ЛОЖЬ представляется целым нулевым значением, а значение ИСТИНА представляется любым ненулевым.<br/>
        Значением выражений, содержащих операции отношения или логические операции, являются ЛОЖЬ(0) или ИСТИНА(1).</p>
        <pre class="docmql4">
Истина, если a равно b                       a == b;
Истина, если a не равно b                    a != b;
Истина, если a меньше b                      a &lt; b;
Истина, если a больше b                      a &gt; b;
Истина, если a меньше или равно b            a &lt;= b;
Истина, если a больше или равно b            a &gt;= b;</pre>

        <p>Два ненормализованных числа с плавающей точкой нельзя связывать операциями == или !=. 
        Следует из одного числа вычесть другое и <a href="help://convert_NormalizeDouble">нормализованный</a> результат сравнить с нулем.</p>
      </content>
    </text>

    <text>
      tag=basis_operations_bool
      caption=Логические операции
      keywords=;||;&amp;&amp;;
      <content>
        <p>Операнд операции логического отрицания НЕ(!) должен иметь арифметический тип.
        Результат равен ИСТИНА(1), если значение операнда есть ЛОЖЬ(0), и равен ЛОЖЬ(0), если операнд не равен ЛОЖЬ(0).</p>
        <pre class="docmql4">if(!a) Print(&quot;не 'a'&quot;);</pre><br/>

        <p>Логическая операция ИЛИ (||) значений x и y. Значением выражения является ИСТИНА(1), если истинно 
        (не нуль) значение x или y. В противном случае - ЛОЖЬ(0).</p>
        <pre class="docmql4">if(x&lt;0 || x&gt;=max_bars) Print(&quot;out of range&quot;);</pre><br/>

        <p>Логическая операция И (&amp;&amp;) значений x и y. Значением выражения является ИСТИНА(1), если значения 
        x и y истинны (не нуль). В противном случае - ЛОЖЬ(0). Логические выражения вычисляются полностью, т.е., к ним не применяется 
        схема так называемой "короткой оценки".</p>
        <pre class="docmql4">if(p!=x &amp;&amp; p&gt;y) Print(&quot;TRUE&quot;);</pre>
      </content>
    </text>

    <text>
      tag=basis_operations_bit
      caption=Побитовые операции
      keywords=;&lt;&lt;;&gt;&gt;;~;!;^;&amp;;|;
      <content>
        <p>Дополнение до единицы значения переменной. Значение выражения содержит 1 во всех разрядах, в 
        которых значение переменной содержит 0, и 0 во всех разрядах, в которых значения переменной содержит 1.</p>
        <pre class="docmql4">b = ~n;</pre><br/>

        <p>Двоичное представление x сдвигается вправо на y разрядов. Сдвиг вправо логический, то есть 
        освобождающиеся слева разряды будут заполняться нулями.</p>
        <pre class="docmql4">x = x &gt;&gt; y;</pre><br/>

        <p>Двоичное представление x сдвигается влево на y разрядов; освобождающиеся справа разряды 
        заполняются нулями.</p>
        <pre class="docmql4">x = x &lt;&lt; y;</pre><br/>

        <p>Побитовая операция И двоичных представлений x и y. Значение выражения содержит 1 (ИСТИНА) во 
        всех разрядах, в которых и x, и y содержат не ноль; и 0 (ЛОЖЬ) во всех остальных разрядах.</p>
        <pre class="docmql4">b = ((x &amp; y) != 0);</pre><br/>
        
        <p>Побитовая операция ИЛИ двоичных представлений x и y. Значение выражения содержит 1 во всех 
        разрядах, в которых x или y не содержит 0, и 0 - во всех остальных разрядах.</p>
        <pre class="docmql4">b = x | y;</pre><br/>

        <p>Побитовая операция исключающее ИЛИ (eXclusive OR) двоичных представлений x и y. Значение выражения 
        содержит 1 в тех разрядах, в которых x и y имеют разные двоичные значения, и 0 - во всех остальных разрядах.</p>
        <pre class="docmql4">b = x ^ y;</pre><br/>

        <p>Побитовые операции выполняются только с целыми числами.</p>
      </content>
    </text>

    <text>
      tag=basis_operations_other
      caption=Другие операции
      <content>
        <p><b>Индексирование</b><br/>
        При обращении к i-му элементу массива значением выражения является значение переменной с порядковым номером i.</p>
        <p class="doctabhdr">Пример:</p>
        <pre class="docmql4">array[i] = 3; // Присвоить значение 3 i-му элементу массива array.</pre><br/>

        <p>Индексом массива может быть только целое число. Допускаются не более чем четырехмерные массивы.
        Индексация каждого измерения производится от 0 до <b>размер измерения</b>-1. В частном случае одномерного массива из 50 элементов 
        обращение к первому элементу будет выглядеть как array[0], к последнему элементу - array[49].</p>

        <p>При доступе за пределы массива исполняющая подсистема сгенерирует <a href="help://constants_errors">ошибку</a> ERR_ARRAY_INDEX_OUT_OF_RANGE (4002), 
        которую можно получить при помощи функции <a href="help://check_GetLastError">GetLastError()</a>.</p>

        <p><b>Вызов функции с аргументами x1, x2,..., xn</b><br/>
        Каждый аргумент может представлять собой константу, переменную или выражение соответствующего типа. Передаваемые аргументы разделяются запятыми и должны
        находиться внутри круглых скобок, открывающая круглая скобка должна следовать за именем вызываемой функции.<br/><br/>
        Значением выражения является значение, возвращаемое функцией. Если тип возвращаемого значения функции есть void, то вызов 
        такой функции нельзя помещать справа в операции присвоения. Обратите внимание, что порядок выполнения выражений 
        x1,..., xn гарантируется.</p>
        <p class="doctabhdr">Пример:</p>
        <pre class="docmql4">
double SL=Bid-25*Point;
int    ticket=OrderSend(Symbol(),OP_BUY,1,Ask,3,SL,Ask+25*Point,"Мой комментарий",123,0,Red);</pre><br/>

        <p><b>Операция запятая</b><br/>
        Выражения, разделенные запятыми, вычисляются слева направо. Все побочные эффекты вычисления левого выражения могут
        возникать до вычисления правого выражения. Тип и значение результата совпадают с типом и значением правого выражения.
        В качестве примера можно рассматривать список передаваемых параметров (см.выше).</p>
        <p class="doctabhdr">Пример:</p>
        <pre class="docmql4">for(i=0,j=99; i&lt;100; i++,j--) Print(array[i][j]);</pre>
      </content>
    </text>

    <text>
      tag=basis_operations_rules
      caption=Приоритеты и порядок выполнения операций
      <content>
        <p>Для каждой группы операций в таблице приоритет одинаков. Чем выше приоритет группы операций, тем 
        выше она расположена в таблице. Порядок выполнения определяет группировку операций и операндов.</p>
<pre class="docmql4">
()     Вызов функции                            Слева направо
[]     Выделение элемента массива
</pre>
        <pre class="docmql4">
!      Логическое отрицание                     Справа налево
-      Изменение знака
++     Увеличение на единицу (increment)
--     Уменьшение на единицу (decrement)
~      Побитовое отрицание (complement)</pre>
<pre class="docmql4">
&amp;      Побитовая операция И                     Слева направо
|      Побитовая операция ИЛИ
^      Побитовая операция исключающее ИЛИ (eXclude OR)
&lt;&lt;     Сдвиг влево
&gt;&gt;     Сдвиг вправо
</pre>
<pre class="docmql4">
*      Умножение                                Слева направо
/      Деление
%      Деление по модулю
</pre>
<pre class="docmql4">
+      Сложение                                 Слева направо
-      Вычитание</pre>
        <pre class="docmql4">
&lt;      Меньше, чем                              Слева направо
&lt;=     Меньше или равно
&gt;      Больше, чем
&gt;=     Больше или равно
==     Равно
!=     Не равно
</pre>
<pre class="docmql4">||     Логическая операция ИЛИ                  Слева направо</pre>
<pre class="docmql4">&amp;&amp;     Логическая операция И                    Слева направо</pre>
<pre class="docmql4">
=      Присваивание                             Справа налево
+=     Сложение с присваиванием
-=     Вычитание с присваиванием
*=     Умножение с присваиванием
/=     Деление с присваиванием
%=     Деление по модулю с присваиванием
&gt;&gt;=    Сдвиг вправо с присваиванием
&lt;&lt;=    Сдвиг влево с присваиванием
&amp;=     Побитовое И с присваиванием
|=     Побитовое ИЛИ с присваиванием
^=     Исключающее ИЛИ с присваиванием
</pre>
<pre class="docmql4">,      Запятая                                  Слева направо</pre><br/>
        
        <p>Для изменения порядка выполнения операций применяются круглые скобки, которые имеют высший приоритет.<br/>
        <b>Внимание:</b> приоритет выполнения операций в языке MQL4 несколько отличается от приоритета, принятого в языке Си.</p>
      </content>
    </text>
  </group>


  <group>
    tag=basis_operators
    caption=Операторы
    <content>
      <p>Операторы языка описывают некоторые алгоритмические действия, которые необходимо выполнить для решения задачи. Тело
      программы - это последовательность таких операторов. Идущие друг за другом операторы разделяются точкой с запятой.<br/><br/>
      Один оператор может занимать одну или более строк. Два или большее количество операторов могут 
      быть расположены на одной строке. Операторы, управляющие порядком выполнения (if, if-else, switch, while и for), 
      могут быть вложены друг в друга.</p>
      <p class="doctabhdr">Пример:</p>
      <pre class="docmql4">
if(Month() == 12)
  if(Day() == 31) Print("Happy New Year!");</pre>
    </content>

    <text>
      tag=basis_operators_compound
      caption=Составной оператор
      <content>
        <p>Составной оператор (блок) состоит из одного или большего числа операторов любого типа, заключенных 
        в фигурные скобки { }. После закрывающейся фигурной скобки не должно быть точки с запятой (;).</p>
        <p class="doctabhdr">Пример:</p>
        <pre class="docmql4">
if(x==0)
  {
   Print("invalid position x=",x);
   return; 
  }</pre>
      </content>
    </text>

    <text>
      tag=basis_operators_expression
      caption=Оператор-выражение
      <content>
        <p>Любое выражение, заканчивающееся точкой с запятой (;), является оператором. Далее следуют примеры операторов-выражений.</p>
        <p><b>Оператор присваивания</b>:</p>
        <pre class="docmql4"><i>Идентификатор = выражение;</i>
        
  x=3;
  y=x=3; // ошибка</pre>
        <p>В выражении оператор присваивания может использоваться только один раз.</p><br/>
        
        <p><b>Оператор вызова функции</b>:</p>
        <pre class="docmql4"><i>Имя_функции (аргумент1,..., аргументN);</i>
        
  FileClose(file);</pre><br/>

        <p><b>Пустой оператор</b><br/>
        Состоит только из точки с запятой (;) и используется для обозначения пустого тела управляющего оператора.</p>
      </content>
    </text>

    <text>
      tag=basis_operators_break
      caption=Оператор завершения break
      keywords=;break;
      <content>
        <p>Оператор <em>break</em> прекращает выполнение ближайшего вложенного внешнего оператора <a href="help://basis_operators_switch"><em>switch</em></a>,
        <a href="help://basis_operators_while"><em>while</em></a> или <a href="help://basis_operators_for"><em>for</em></a>. 
        Управление передается оператору, следующему за заканчиваемым. Одно из назначений этого оператора - закончить выполнение 
        цикла при присваивании некоторой переменной определенного значения.</p>

        <p class="doctabhdr">Пример:</p>
        <pre class="docmql4">// поиск первого нулевого элемента
for(i=0;i&lt;array_size;i++) 
  if(array[i]==0)
    break;</pre>
      </content>
    </text>

    <text>
      tag=basis_operators_continue
      caption=Оператор продолжения continue
      keywords=;continue;
      <content>
        <p>Оператор <em>continue</em> передает управление в начало ближайшего внешнего оператора цикла 
        <a href="help://basis_operators_while"><em>while</em></a> или <a href="help://basis_operators_for"><em>for</em></a>, вызывая начало 
        следующей итерации. Этот оператор по действию противоположен оператору <a href="help://basis_operators_break"><em>break</em></a>.</p>
        <p class="doctabhdr">Пример:</p>
        <pre class="docmql4">
// сумма всех ненулевых элементов
int func(int array[])
  {
   int array_size=ArraySize(array);
   int sum=0;
   for(int i=0;i&lt;array_size; i++)
     {
      if(a[i]==0) continue;
      sum+=a[i]; 
     }
   return(sum);
  }</pre>
      </content>
    </text>

    <text>
      tag=basis_operators_return
      caption=Оператор возврата return
      keywords=;return;
      <content>
        <p>Оператор <em>return</em> прекращает выполнение текущей функции и возвращает управление вызвавшей программе.
        Использование <em>return(выражение);</em> прекращает выполнение текущей функции с передачей результата. Выражение оператора 
        заключается в круглые скобки и не должно содержать оператор присваивания.</p>
        <p class="doctabhdr">Пример:</p>
        <pre class="docmql4">int CalcSum(int x, int y)
  {
   return(x+y);
  }</pre><br/>
        
        <p>В функциях с типом возвращаемого значения void необходимо использовать оператор <em>return</em> без выражения:</p>
        <pre class="docmql4">void SomeFunction()
  {
   Print("Hello!");
   return;    // этот оператор можно удалить
  }</pre>
        <p>Завершающая фигурная скобка функции предполагает неявное исполнение оператора <em>return</em> без выражения.</p>
      </content>
    </text>

    <text>
      tag=basis_operators_if
      caption=Условный оператор if-else
      keywords=;else;
      <content>
        <p>Если выражение истинно, то выполняется оператор1 и управление передается на оператор, следующий за оператором2 
        (т. е. оператор2 не выполняется). Если выражение ложно, то выполняется оператор2.</p>
        <pre class="docmql4"><i>if (выражение)
     оператор1
else
     оператор2</i></pre><br/>

        <p>Часть <em>else</em> оператора <em>if</em> может опускаться. Поэтому во вложенных операторах <em>if</em> 
        с пропущенной частью <em>else</em> может возникнуть неоднозначность. В этом случае <em>else</em> связывается с 
        ближайшим предыдущим оператором <em>if</em> в том же блоке, не имеющим части <em>else</em>.</p>

        <p class="doctabhdr">Примеры:</p>
        <pre class="docmql4">//   Часть else относится ко второму оператору if:
if(x&gt;1)
  if(y==2) z=5;
  else     z=6;
<br/>
//   Часть else относится к первому оператору if
if(x&gt;l)
  {
   if(y==2) z=5;
  }
else        z=6;
<br/>
//   Вложенные операторы
if(x=='a')
  {
   y=1;
  }
else if(x=='b')
  {
   y=2;
   z=3;
  }
else if(x=='c')
  {
   y = 4;
  }
else Print(&quot;ERROR&quot;);</pre>
      </content>
    </text>

    <text>
      tag=basis_operators_switch
      caption=Оператор-переключатель switch
      keywords=;switch;case;default;
      <content>
        <p>Сравнивает значение выражения с константами во всех вариантах <em>case</em> и передает управление 
        оператору, который соответствует значению выражения. Каждый вариант <em>case</em> может быть помечен целой константой,
        символьной константой или константным выражением. Константное выражение не может включать переменные или вызовы функций.
        Выражение оператора <em>switch</em> должно быть целого типа.</p>
        <pre class="docmql4"><i>switch(выражение)
  {
   case константа: операторы
   case константа: операторы
     ...
   default: операторы
  }</i></pre><br/>
  
        <p>Операторы, связанные с меткой <em>default</em>, выполняются, если ни одна из констант в операторах <em>case</em> не равна 
        значению выражения. Вариант <em>default</em> обязательно должен быть последним. Если ни одна константа не соответствует значению 
        выражения и вариант <em>default</em> отсутствует, то не выполняется никаких действий. Ключевое слово <em>case</em> вместе с константой 
        служат просто метками, и если будут выполняться операторы для некоторого варианта <em>case</em>, то далее будут выполняться операторы всех 
        последующих вариантов до тех пор, пока не встретится оператор <a href="help://basis_operators_break"><em>break</em></a>, что позволяет 
        связывать одну последовательность операторов с несколькими вариантами.</p>
        
        <p>Константное выражение вычисляется в период компиляции. Никакие две константы в одном операторе-переключателе не могут 
        иметь одинаковые значения.</p>
        <p class="doctabhdr">Пример:</p>
        <pre class="docmql4">switch(x) 
  { 
   case 'A':
      Print(&quot;CASE A&quot;);
      break;
   case 'B':
   case 'C':
      Print(&quot;CASE B or C&quot;);
      break;
   default:
      Print(&quot;NOT A, B or C&quot;);
      break;
  }</pre>
      </content>
    </text>

    <text>
      tag=basis_operators_while
      caption=Оператор цикла while
      keywords=;while;
      <content>
        <p>Если выражение истинно, то оператор выполняется до тех пор, пока выражение не станет ложным. Если 
        выражение ложно, то управление передается следующему оператору.</p>
        <pre class="docmql4"><i>while(выражение) 
  оператор;</i></pre><br/>
        <p>Значение выражения определяется до выполнения оператора. Следовательно, если выражение ложно с самого 
        начала, то оператор вообще не выполняется.</p>
        <p class="doctabhdr">Пример:</p>
        <pre class="docmql4">while(k&lt;n) 
  {
   y=y*x; 
   k++;
  }</pre>
      </content>
    </text>

    <text>
      tag=basis_operators_for
      caption=Оператор цикла for
      keywords=;for;
      <content>
        <p><em>Выражение1</em> описывает инициализацию цикла. <em>Выражение2</em> - проверка условия завершения цикла.
        Если оно истинно, то выполняется оператор тела цикла <em>for</em>. Все повторяется, пока <em>выражение2</em> не станет ложным.
        Если оно ложно, цикл заканчивается и управление передается следующему оператору. <em>ВыражениеЗ</em> вычисляется после каждой итерации.</p>
        <pre class="docmql4"><i>for(выражение1; выражение2; выражение3)
   оператор;</i></pre><br/>
   
        <p>Оператор <em>for</em> эквивалентен следующей последовательности операторов:</p>
        <pre class="docmql4"><i>выражение1;
while(выражение2)
  {
   оператор;
   выражение 3;
  };</i></pre><br/>
  
        <p>Любое из трех или все три выражения в операторе <em>for</em> могут отсутствовать, однако разделяющие 
        их точки с запятыми (;) опускать нельзя. Если опущено <em>выражение2</em>, то считается, что оно постоянно истинно. 
        Оператор <em>for(;;)</em> представляет собой бесконечный цикл, эквивалентный оператору <em>while(1)</em>.
        Каждое из <em>выражение1</em> и <em>выражение3</em> может состоять из нескольких выражений, объединенных оператором запятая ','.</p>
        <p class="doctabhdr">Примеры:</p>
        <pre class="docmql4">for(x=1;x&lt;=7;x++) Print(MathPower(x,2));<br/>
for(;;)
  {
   Print(MathPower(x,2));
   x++;
   if(x>10) break;
  }<br/>
for(i=0,j=n-l;i&lt;n;i++,j--) a[i]=a[j];</pre>
      </content>
    </text>
  </group>


  <group>
    tag=basis_functions
    caption=Функции
    <content>
      <p>Функция - это поименованная часть программы, которая может вызываться из других частей программы столько раз,
      сколько необходимо. Она состоит из описания типа возвращаемого значения, имени, формальных параметров и составного оператора 
      (блока) из выполняемых действий. Количество параметров, передаваемых в функцию, ограничено и не может превышать 64.</p>
      <p class="doctabhdr">Пример:</p>
      <pre class="docmql4">
double                       // тип возвращаемого значения
linfunc (double а, double b) // имя функции и список параметров
  {
                             // составной оператор
   return (a + b);           // возвращаемое значение
  }</pre>
        
      <p>Оператор return может возвращать значение выражения, стоящего в этом операторе. Значение выражения при необходимости 
      преобразуется к типу результата функции. Функция, которая не возвращает значения, должна быть описана как имеющая тип void.</p>
      <p class="doctabhdr">Пример:</p>
      <pre class="docmql4">
void errmesg(string s)
  {
   Print(&quot;error: &quot;+s);
  }</pre>

      <p>Параметры, передаваемые в функцию могут иметь умолчательные значения, которые задаются константами соответствующего типа.</p>
      <p class="doctabhdr">Пример:</p>
      <pre class="docmql4">
int somefunc(double a, double d=0.0001, int n=5, bool b=true, string s="passed string")
  {
   Print(&quot;Обязательный параметр a=&quot;,a);
   Print(&quot;Переданы следующие параметры: d=&quot;,d,&quot; n=&quot;,n,&quot; b=&quot;,b,&quot; s=&quot;,s);
   return (0);
  }</pre>
      <p>Если какому-либо параметру было назначено умолчательное значение, то все последующие параметры также должны 
      иметь умолчательное значение.</p>
      <p class="doctabhdr">Пример неправильного объявления:</p>
      <pre class="docmql4">
int somefunc(double a, double d=0.0001, int n, bool b, string s="passed string")
  {
  }</pre>
    </content>

    <text>
      tag=basis_functions_call
      caption=Вызов функции
      <content>
        <p>Если некоторое имя, которое не было описано ранее, появляется в выражении и за ним следует левая круглая скобка, то
        оно по контексту считается именем некоторой функции.</p>
        <pre class="docmql4"><i>имя_функции (x1, x2,..., xn)</i></pre><br/>
         
        <p>Аргументы (<a href="help://basis_variables_formal">формальные параметры</a>) передаются по значению, т. е. каждое выражение <em>xl</em>, . . . , <em>xn</em>
        вычисляется и значение передается функции. Порядок вычисления выражений и порядок загрузки значений гарантируются. Во время 
        выполнения производится проверка числа и типа аргументов, переданных функции. Такой способ обращения к функции называется 
        вызовом по значению. Вызов функции - это выражение, значением которого является значение, возвращаемое функцией. Описанный 
        тип функции должен соответствовать типу возвращаемого значения. Функция может быть объявлена или описана в любом месте программы
        на глобальном уровне, то есть, вне других функций. Функция не может быть объявлена или описана внутри другой функции.</p>
        <p class="doctabhdr">Примеры:</p>
        <pre class="docmql4">
int start()
  {
   double some_array[4]={0.3, 1.4, 2.5, 3.6};
   double a=linfunc(some_array, 10.5, 8);
   //...
  }

double linfunc(double x[], double a, double b)
  {
   return (a*x[0] + b);
  }</pre><br/>

        <p>При вызове функции, имеющей умолчательные параметры, список передаваемых параметров можно ограничить не ранее 
        первого умолчательного параметра.</p>
        <p class="doctabhdr">Примеры:</p>
        <pre class="docmql4">void somefunc(double init,double sec=0.0001,int level=10);  // прототип функции<br/>
somefunc();                   // неправильный вызов. первый обязательный параметр должен быть.
somefunc(3.14);               // правильный вызов
somefunc(3.14, 0.0002);       // правильный вызов
somefunc(3.14, 0.0002, 10);   // правильный вызов</pre><br/>

        <p>При вызове функции, нельзя пропускать параметры, даже имеющие умолчательные значения:</p>
        <pre class="docmql4">somefunc(3.14, , 10);         // неправильный вызов. второй параметр пропущен.</pre>
      </content>
    </text>

    <text>
      tag=basis_functions_special
      caption=Специальные функции
      keywords=;init;deinit;start;
      <content>
        <p>В MQL4 существуют 3 функции с предопределенными именами:<br/><br/>

        <b>init()</b> - функция, вызывающаяся в процессе инициализации модуля. В случае ее отсутствия при инициализации не вызывается никакой функции.<br/><br/>

        <b>start()</b> - основная функция. У экспертов вызывается после прихода очередного тика. У пользовательских индикаторов вызывается при пересчете
        после прикрепления индикатора к графику, при открытии клиентского терминала (если индикатор прикреплен к графику), а также после прихода очередного тика.
        У скриптов выполняется сразу после прикрепления к графику и выполнения инициализации. В случае отсутствия в модуле функции start() этот модуль (эксперт,
        скрипт или пользовательский индикатор) не может быть запущен.<br/><br/>

        <b>deinit()</b> - функция, вызывающаяся в процессе деинициализации модуля. В случае ее отсутствия при деинициализации не вызывается никакой функции.</p>

        <p>Предопределенные функции могут иметь параметры. Однако при вызове этих функций клиентским терминалом никакие 
        параметры переданы извне не будут, а будут использованы умолчательные значения. Функции <em>start()</em>, <em>init()</em> и 
        <em>deinit()</em> могут быть вызваны из любого места модуля по общим правилам, наравне с другими функциями.</p>
        
        <p>Нежелательно из функции <em>init()</em> вызывать <em>start()</em> или совершать торговые операции, так как в момент 
        инициализации модуля могут быть не готовы данные графиков, рыночные цены и т.д. Функции <em>init()</em> и <em>deinit()</em> должны 
        максимально быстро завершать свою работу и ни в коем случае не зацикливаться в попытке начать полноценную работу раньше вызова функции 
        <em>start()</em>.</p>
      </content>
    </text>
  </group>


  <group>
    tag=basis_variables
    caption=Переменные
    <content>
      <p>Переменные должны быть объявлены перед их использованием. Для идентификации переменных используются уникальные 
      имена. Описания переменных используются для их определения и объявления типов. Описание не является оператором.</p>

      <p><b>Основными типами являются:</b></p>
      <ul><li><a href="help://basis_types_integer">int</a> - целые числа;</li>
          <li><a href="help://basis_types_bool">bool</a> - логические значения <em>true</em> и <em>false</em>;</li>
          <li><a href="help://basis_types_string">string</a> - символьные строки;</li>
          <li><a href="help://basis_types_double">double</a> - числа двойной точности с плавающей точкой.</li>
      </ul>

      <p class="doctabhdr">Примеры:</p>
      <pre class="docmql4">
string MessageBox;
int    Orders;
double SymbolPrice;
bool   bLog;</pre><br/>

      <p><b>Дополнительные типы:</b></p>
      <ul><li><a href="help://basis_types_color">color</a> - целое число, представляющее RGB-цвет;</li>
          <li><a href="help://basis_types_datetime">datetime</a> - дата и время, беззнаковое целое число, содержащее 
          количество секунд, прошедших с 0 часов 1 января 1970 года.</li>
      </ul>
        
      <p>Дополнительные типы данных имеют смысл только при объявлении <a href="help://basis_variables_extern">входных параметров</a> для более удобного 
      представления их в окне свойств.</p>
      <p class="doctabhdr">Примеры:</p>
      <pre class="docmql4">
datetime tBegin_Data   = D'2004.01.01 00:00';
color    cModify_Color = C'0x44,0xB9,0xE6';</pre><br/>

      <p><b>Массивы</b></p>
      <p>Массив - это индексированная совокупность однотипных данных:</p>
      <pre class="docmql4">
int    a[50];       // Одномерный массив из 50 целых чисел.
double m[7][50];    // Двухмерный массив из семи массивов,
                    // каждый из которых состоит из 50 чисел.</pre><br/>

      <p><a href="help://basis_operations_other">Индексом массива</a> может быть только целое число. Допускаются не более 
      чем четырехмерные массивы. Нумерация элементов массива начинается с 0. Последний элемент одномерного массива имеет номер на 
      1 меньший, чем размер массива, то есть обращение к последнему элементу массива из 50 целых чисел будет выглядеть как a[49]. 
      То же самое относится и к многомерным массивам - индексация одного измерения производится от 0 до <b>размер измерения</b>-1.
      Последний элемент двумерного массива из примера будет выглядеть как m[6][49].</p>

      <p>При доступе за пределы массива исполняющая подсистема сгенерирует <a href="help://constants_errors">ошибку</a> 
      ERR_ARRAY_INDEX_OUT_OF_RANGE (4002), которую можно получить при помощи функции <a href="help://check_GetLastError">GetLastError()</a>.</p>
    </content>

    <text>
      tag=basis_variables_local
      caption=Локальные переменные
      <content>
        <p>Переменная, объявленная внутри какой-либо функции, является локальной. Область видимости локальной переменной 
        ограничена пределами функции, внутри которой она объявлена. Локальная переменная может быть проинициализирована при помощи 
        любого выражения. Инициализация локальной переменной производится каждый раз при вызове соответствующей функции. Локальные 
        переменные располагаются во временной области памяти соответствующей функции.</p>
        <p class="doctabhdr">Пример:</p>
        <pre class="docmql4">
int somefunc()
  {
   int ret_code=0;
   ....
   return(ret_code);
  }</pre><br/>
      </content>
    </text>
        
    <text>
      tag=basis_variables_formal
      caption=Формальные параметры
      <content>
        <p><a href="help://basis_functions_call">Передаваемые в функцию</a> параметры являются локальными. Областью видимости является блок функции. Формальные параметры 
        должны отличаться по именам от внешних переменных и локальных переменных, определенных внутри функции. В блоке функции формальным 
        параметрам могут быть присвоены некоторые значения.</p>
        <p class="doctabhdr">Пример:</p>
        <pre class="docmql4">
void func(int x[], double y, bool z)
  {
   if(y&gt;0.0 &amp;&amp; !z)
      Print(x[0]);
   ...
  }</pre><br/>
        <p>Формальные параметры могут быть проинициализированы константами. В этом случае 
        инициализирующее значение считается значением по умолчанию. Параметры, следующие за проинициализированным параметром, должны 
        быть тоже проинициализированы.</p>
        <p class="doctabhdr">Пример:</p>
        <pre class="docmql4">void func(int x, double y = 0.0, bool z = true)
  {
   ...
  }</pre>

       <p>При вызове такой функции инициализированные параметры можно опускать, вместо них будут подставлены значения по умолчанию.</p>
       <p class="doctabhdr">Пример:</p><pre class="docmql4">func(123, 0.5);</pre><br/>
       
       <p>Библиотечные функции, <a href="help://basis_variables_extfunctions">импортируемые</a> в других модулях, не могут иметь параметров по умолчанию.</p>
       
       <p>Параметры передаются по значению, то есть изменения соответствующей локальной переменной внутри вызываемой 
       функции никак не отразится в вызывающей функции. В качестве параметров можно передавать массивы. Но у массива, переданного 
       в качестве параметра, нельзя изменять значения его элементов.</p>
       
       <p>Существует возможность передавать параметры по ссылке. В этом случае модификация таких параметров отразится 
       на соответствующих переменных в вызываемой функции, переданных по ссылке. Нельзя передавать по ссылке элементы массивов.
       Параметры по ссылке можно передавать только в пределах одного модуля, для библиотечных функций такая возможность не предусмотрена.
       Для того чтобы указать, что параметр передается по ссылке, после типа данных необходимо поставить модификатор &amp;.</p>
       <p class="doctabhdr">Пример:</p>
       <pre class="docmql4">
void func(int&amp; x, double&amp; y, double&amp; z[])
  {
   double calculated_tp;
   ...
   for(int i=0; i&lt;OrdersTotal(); i++)
     {
      if(i==ArraySize(z))       break;
      if(OrderSelect(i)==false) break;
      z[i]=OrderOpenPrice();
     }
   x=i;
   y=calculated_tp;
  }</pre><br/>
      <p>Массивы также можно передавать по ссылке, все изменения отразятся в исходном массиве. В отличие от простых параметров
      массивы можно передавать по ссылке и в библиотечные функции.<br/><br/>

      Параметры, передаваемые по ссылке, нельзя инициализировать значениями по умолчанию.<br/><br/>
      
      В функцию нельзя передать больше 64 параметров.</p>
      </content>
    </text>

    <text>
      tag=basis_variables_static
      caption=Статические переменные
      keywords=;static;
      <content>
        <p>Класс памяти static определяет статическую переменную. Модификатор static указывается перед типом данных.</p>
        <p class="doctabhdr">Пример:</p>
        <pre class="docmql4">
int somefunc()
  {
   static int flag=10;
   ....
   return(flag);
  }</pre><br/>
        <p>Статические переменные хранятся в постоянной области памяти программы, их значения не теряются при выходе из функции. 
        Любые переменные в блоке, кроме формальных параметров функции, могут быть определены как статические. Статическая переменная может 
        быть проинициализирована соответствующей ее типу константой, в отличие от простой локальной переменной, которая может быть 
        проинициализирована любым выражением. Если нет явной инициализации, то статическая переменная инициализируется нулем. 
        Статические переменные инициализируются однократно перед вызовом специализированной функции init(), то есть при выходе из функции, 
        внутри которой объявлена статическая переменная, значение этой переменной не теряется.</p>
      </content>
    </text>

    <text>
      tag=basis_variables_global
      caption=Глобальные переменные
      keywords=;static;
      <content>
        <p>Глобальные переменные определяются на том же уровне, что и функции, т. е. не локальны ни в каком блоке.</p>
        <p class="doctabhdr">Пример:</p>
        <pre class="docmql4">int GlobalFlag=10;   // глобальная переменная<br/>

int start()
  {
   ...
  }</pre><br/>
  
        <p>Область видимости глобальных переменных - вся программа, глобальные переменные доступны из всех функций, определенных 
        в программе. Инициализируются нулем, если явно не задано другое начальное значение. Глобальная переменная может быть проинициализирована 
        только соответствующей ее типу константой. Инициализация глобальных переменных производится однократно сразу после загрузки программы в
        память клиентского терминала.</p>
       
        <p>Замечание: не следует путать переменные, объявленные на глобальном уровне, с глобальными переменными клиентского терминала, 
        доступ к которым осуществляется при помощи функций <a href="help://globals"><em>GlobalVariable...()</em></a>.</p>
      </content>
    </text>

    <text>
      tag=basis_variables_extern
      caption=Внешние переменные
      keywords=;extern;
      <content>
        <p>Класс памяти <em>extern</em> определяет внешнюю переменную. Модификатор <em>extern</em> указывается перед типом данных.</p>
        <p class="doctabhdr">Пример:</p>
        <pre class="docmql4">extern double InputParameter1 = 1.0;
extern color  InputParameter2 = red;<br/>
int init()
  {
   ...
  }</pre><br/>
        <p>Внешние переменные определяют входные параметры программы, они доступны из окна свойств программы. Массивы не могут 
        выступать в качестве внешних переменных.</p>
      </content>
    </text>

    <text>
      tag=basis_variables_initialization
      caption=Инициализация переменных
      <content>
        <p>Любая переменная при определении может быть инициализирована. Любая переменная инициализируется нулем (0), если 
        явно не задано другое начальное значение. Глобальные и статические переменные могут быть проинициализированы только константой 
        соответствующего типа. Локальные переменные могут быть проинициализированы любым выражением, а не только константой.</p>
        <p>Инициализация глобальных и статических переменных производится однократно. Инициализация локальных переменных 
        производится каждый раз при вызове соответствующих функций.</p>
        <p class="doctabhdr">Примеры:</p>
        <pre class="docmql4">
int    n       = 1;
double p       = MarketInfo(Symbol(),MODE_POINT);
string s       = "hello";
double f[]     = { 0.0, 0.236, 0.382, 0.5, 0.618, 1.0 };
int    a[4][4] = { 1, 1, 1, 1,  2, 2, 2, 2,  3, 3, 3, 3,  4, 4, 4, 4 };</pre><br/>

        <p>Список значений элементов массива должен быть заключен в фигурные скобки. Пропущенные инициализирующие значения
        считаются равными 0. Если размер инициализируемого массива не указан, то он определяется компилятором, исходя из размера инициализирующей
        последовательности. Многомерные массивы инициализируются одномерной последовательностью, последовательностью без дополнительных
        фигурных скобок. Массивы (в том числе и объявленные на локальном уровне) могут инициализироваться только константами.</p>
      </content>
    </text>

    <text>
      tag=basis_variables_extfunctions
      caption=Описание внешних функций
      keywords=;import;
      <content>
        <p>Тип внешних функций, определенных в другом модуле, должен быть явно описан. Отсутствие такого 
        описания может привести к ошибкам при компиляции, компоновке или выполнении программы. При описании внешнего объекта используйте 
        ключевое слово <em>#import</em> с указанием модуля.</p>
        <p class="doctabhdr">Примеры:</p>
        <pre class="docmql4">
#import "user32.dll"
  int     MessageBoxA(int hWnd ,string szText,string szCaption,int nType);
  int     SendMessageA(int hWnd,int Msg,int wParam,int lParam);
#import "lib.ex4"
  double  round(double value);
#import</pre><br/>

        <p>С помощью импорта можно очень легко описывать функции, вызываемые из внешних DLL или скомпилированных 
        EX4 библиотек.<br/><br/>
        Существует способ передавать в импортируемые dll-функции указатели на переменные. Данные типа <em>string</em> передаются как указатель
        на соответствующую область памяти (напомним, что внутреннее представление строковых данных состоит из двух частей: длины области памяти
        и указателя на область памяти). Если необходимо передать данные типа <em>int</em> или <em>double</em>, то в качестве параметра
        следует передать по ссылке одноэлементный массив соответствующего типа.</p>
        <p class="doctabhdr">Пример:</p>
        <pre class="docmql4">
#import "some_lib.dll"
  void    PassIntegerByref(int&amp; OneInt[]);
#import
int start()
  {
   int array[1];
//...
   PassIntegerByref(array);
   Print(array[0]);
//...
  }
</pre>
      </content>
    </text>
  </group>


  <group>
    tag=basis_preprosessor
    caption=Препроцессор
    <content>
    Препроцессор - это специальная подсистема компилятора MQL4, которая занимается предварительной подготовкой исходного текста программы непосредственно
    перед ее компиляцией.<br/><br/>
    Препроцессор позволяет улучшить читаемость исходного кода. Структурирование кода может быть достигнуто путем включения отдельных
    файлов с исходными кодами MQL4-программ. Улучшению читаемости кода способствует и возможность присвоения мнемонических имен отдельным константам.<br/><br/>
    Препроцессор позволяет также определять специфические параметры MQL4-программ.<br/><br/>
    Если в качестве первого символа в строке программы используется символ #, то эта строка является директивой препроцессора.
    Директива препроцессора заканчивается символом перевода на новую строку.
    </content>
    <text>
      tag=basis_preprosessor_constant
      caption=Объявление константы
      keywords=;#define;define;
      <content>
        <p>Используя конструкцию <em>#define</em>, можно в начале программы определить символическое имя или символическую константу, 
        которая будет конкретной строкой символов. Впоследствии компилятор заменит все не заключенные в кавычки появления этого имени на 
        соответствующую строку. Фактически это имя может быть заменено абсолютно произвольным текстом, не обязательно цифрами:</p>
        <pre class="docmql4"><i>#define идентификатор значение</i></pre><br/>
        
        <p>Идентификатор константы подчиняется тем же правилам, что и для имен переменных. Значение может быть любого типа:</p>
        <pre class="docmql4">
#define ABC          100
#define PI           0.314
#define COMPANY_NAME "MetaQuotes Software Corp."<br/>
...<br/>

void ShowCopyright()
  {
   Print("Copyright © 2001-2007, ",COMPANY_NAME);
   Print("http://www.metaquotes.net");
  }</pre>
      </content>
    </text>

    <text>
      tag=basis_preprosessor_compilation
      caption=Специальные параметры
      <keywords>
      ;#property;property;link;copyright;stacksize;indicator_chart_window;indicator_separate_window;indicator_buffers;
      ;indicator_minimum;indicator_maximum;indicator_color1;indicator_color2;indicator_color3;indicator_color4;
      ;indicator_color5;indicator_color6;indicator_color7;indicator_color8;indicator_level1;indicator_level2;
      ;indicator_level3;indicator_level4;indicator_level5;indicator_level6;indicator_level7;indicator_level8;
      ;indicator_levelcolor;indicator_levelwidth;indicator_levelstyle;show_confirm;show_inputs;
      </keywords>
      <content>
        <p>У каждой MQL4 программы можно указать дополнительные специфические параметры <em>#property</em>, которые помогают 
        клиентскому терминалу правильно обслуживать программы без необходимости их явного запуска. В первую очередь это 
        касается внешних настроек индикаторов.</p>
        <pre class="docmql4"><i>#property идентификатор значение</i></pre><br/>
        
        <table cellspacing="0" cellpadding="4" border="0" class="docenums">
        <tr><th width="15%">Константа</th><th width="10%">Тип</th><th width="75%">Описание</th></tr>
        <tr><td>link</td><td>string</td><td>ссылка на сайт компании-производителя</td></tr>
        <tr><td>copyright</td><td>string</td><td>название компании-производителя</td></tr>
        <tr><td>stacksize</td><td>int</td><td>размер стека для рекурсивных вызовов</td></tr>
        <tr><td>library</td><td>&nbsp;</td><td>библиотека; не назначается никакой стартовой функции, не удаляются функции, которые не вызываются из других функций</td></tr>
        <tr><td>indicator_chart_window</td><td>void</td><td>выводить индикатор в окно графика</td></tr>
        <tr><td>indicator_separate_window</td><td>void</td><td>выводить индикатор в отдельное окно</td></tr>
        <tr><td>indicator_buffers</td><td>int</td><td>количество буферов для расчета индикатора, максимум до 8</td></tr>
        <tr><td>indicator_minimum</td><td>double</td><td>нижнее ограничение шкалы отдельного окна индикатора</td></tr>
        <tr><td>indicator_maximum</td><td>double</td><td>верхнее ограничение шкалы отдельного окна индикатора</td></tr>
        <tr><td>indicator_colorN</td><td>color</td><td>цвет для вывода линии N, где N от 1 до 8</td></tr>
        <tr><td>indicator_widthN</td><td>int</td><td>толщина линии N, где N от 1 до 8</td></tr>
        <tr><td>indicator_styleN</td><td>int</td><td>стиль линии N, где N от 1 до 8</td></tr>
        <tr><td>indicator_levelN</td><td>double</td><td>горизонтальный уровень N в отдельном окне индикатора, где N от 1 до 8</td></tr>
        <tr><td>indicator_levelcolor</td><td>color</td><td>цвет горизонтальных уровней индикатора</td></tr>
        <tr><td>indicator_levelwidth</td><td>int</td><td>толщина горизонтальных уровней индикатора</td></tr>
        <tr><td>indicator_levelstyle</td><td>int</td><td>стиль горизонтальных уровней индикатора</td></tr>
        <tr><td>show_confirm</td><td>void</td><td>выводить окно подтверждения перед запуском скрипта</td></tr>
        <tr><td>show_inputs</td><td>void</td><td>выводить окно со свойствами перед запуском скрипта и запретить вывод окна подтверждения</td></tr>
        </table><br/>
        
        <p class="doctabhdr">Примеры:</p>
        <pre class="docmql4">
#property link        "http://www.metaquotes.net"
#property copyright   "MetaQuotes Software Corp."
#property library
#property stacksize   1024</pre>
        <p>Компилятор запишет в настройках выполняемого модуля объявленные значения.</p>
      </content>
    </text>

    <text>
      tag=basis_preprosessor_include
      caption=Включение файлов
      keywords=;include;
      <content>
        <p>Командная строка <em>#include</em> может встречаться в любом месте программы, но обычно все включения размешаются в 
        начале файла исходного текста. Формат вызова:</p>
        <pre class="docmql4"><i>#include &lt;имя_файла&gt;
#include &quot;имя_файла&quot;;</i></pre><br/>

        <p class="doctabhdr">Примеры:</p>
        <pre class="docmql4">
#include &lt;WinUser32.mqh&gt;
#include "mylib.mqh"</pre><br/>

        <p>Препроцессор заменяет строку <em>#include &lt;имя_файла&gt;</em> содержимым файла <em>WinUser32.mqh</em>.
        Угловые скобки обозначают, что файл <em>WinUser32.mqh</em> будет взят из стандартного каталога (обычно это 
        <em>каталог_терминала\experts\include</em>). Текущий каталог не просматривается.</p>
        
        <p>Если имя файла заключено в кавычки, то поиск производится в текущем каталоге (в котором содержится основной файл 
        исходного текста). Cтандартный каталог не просматривается.</p>
      </content>
    </text>

    <text>
      tag=basis_preprosessor_import
      caption=Импорт функций
      keywords=;import;DLL;EX4;
      <content>
        <p>Импорт функций осуществляется из откомпилированных модулей MQL4 (файлы *.ex4) и из модулей операционной 
        системы (файлы *.dll). Имя модуля указывается в директиве <em>#import</em>. Для того, чтобы компилятор мог правильно оформить вызов 
        импортируемой функции и организовать правильную передачу параметров, необходимо полное описание функций. Описания функций следуют 
        непосредственно за директивой <em>#import &quot;имя модуля&quot;</em>. Новая команда <em>#import</em> (можно без параметров) завершает 
        блок описания импортируемых функций.</p>
        <pre class="docmql4"><i>#import "имя_файла"
    func1 define;
    func2 define;
    ...
    funcN define;
#import</i></pre><br/>

        <p>Импортируемые функции должны иметь уникальные имена. Нельзя одновременно импортировать из разных модулей 
        функции с одинаковыми именами. Импортируемые функции не должны иметь имен, совпадающих с именами встроенных функций.</p>
        <p>Так как импортируемые функции находятся вне компилируемого модуля, компилятор не может проверить правильность передаваемых
        параметров. Поэтому, во избежание ошибок выполнения, необходимо точно описывать состав и порядок параметров, передаваемых в
        импортируемые функции. Параметры, передаваемые в импортируемые функции (как из EX4, так и из DLL-модулей), не могут иметь значения по умолчанию.</p>
        <p class="doctabhdr">Примеры:</p>
        <pre class="docmql4">#import "user32.dll"
   int    MessageBoxA(int hWnd, string lpText, string lpCaption, int uType);<br/>
#import "stdlib.ex4"
   string ErrorDescription(int error_code);
   int    RGB(int red_value, int green_value, int blue_value);
   bool   CompareDoubles(double number1, double number2);
   string DoubleToStrMorePrecision(double number, int precision);
   string IntegerToHexString(int integer_number);<br/>
#import "ExpertSample.dll"
   int    GetIntValue(int);
   double GetDoubleValue(double);
   string GetStringValue(string);
   double GetArrayItemValue(double arr[], int, int);
   bool   SetArrayItemValue(double&amp; arr[], int,int, double);
   double GetRatesItemValue(double rates[][6], int, int, int);
   int    SortStringArray(string&amp; arr[], int);
   int    ProcessStringArray(string&amp; arr[], int);
#import</pre><br/>

        <p>Для импорта функций во время выполнения mql4-программы используется так называемое позднее связывание. 
        Это значит, что пока не вызвана импортируемая функция, соответствующий модуль (ex4 или dll) не загружается.</p>

        <p>Не рекомендуется использовать полностью квалифицированное имя загружаемого модуля вида 
        <em>Drive:\Directory\FileName.Ext</em>. Библиотеки MQL4 загружаются из папки <em>terminal_dir\experts\libraries</em>.
        Если библиотека не была найдена, то производится попытка загрузить библиотеку из папки <em>terminal_dir\experts</em>.</p>
      </content>
    </text>
  </group>
  </group>

  <group>
    tag=constants
    caption=Стандартные константы
    <content>
     <p>Для облегчения написания программ, а также для удобства восприятия исходных текстов программ, в языке MQL4 предусмотрены предопределенные
     стандартные константы.<br/><br/>
     Стандартные константы являются аналогом <a href="help://basis_preprosessor_constant">макроподстановок</a> и имеют тип int.<br/><br/>
     Константы сгруппированы по своему назначению.</p>
    </content>
    <text>
      tag=constants_series
      caption=Таймсерии
      keywords=;MODE_OPEN;MODE_LOW;MODE_HIGH;MODE_CLOSE;MODE_TIME;MODE_VOLUME;
      <content>
        <p>Идентификаторы таймсерий используются в функциях <a href="help://array_ArrayCopySeries">ArrayCopySeries()</a>,
        <a href="help://series_iHighest">iHighest()</a> и <a href="help://series_iLowest">iLowest()</a>. Mогут быть одной из следующих величин:</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums">
        <tr><th width="15%">Константа</th><th width="10%">Значение</th><th width="75%">Описание</th></tr>
        <tr><td>MODE_OPEN</td><td>0</td><td>Цена открытия</td></tr>
        <tr><td>MODE_LOW</td><td>1</td><td>Минимальная цена</td></tr>
        <tr><td>MODE_HIGH</td><td>2</td><td>Максимальная цена</td></tr>
        <tr><td>MODE_CLOSE</td><td>3</td><td>Цена закрытия</td></tr>
        <tr><td>MODE_VOLUME</td><td>4</td><td>Объем (количество тиков, сформировавших бар)</td></tr>
        <tr><td>MODE_TIME</td><td>5</td><td>Время открытия бара</td></tr>
        </table>
      </content>
    </text>

    <text>
      tag=constants_timeframes
      caption=Периоды графиков
      keywords=;PERIOD_M1;PERIOD_M5;PERIOD_M15;PERIOD_H1;PERIOD_H4;PERIOD_D1;PERIOD_W1;PERIOD_MN1;
      <content>
        <p>Период графика может быть любым из следующих величин:</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums">
        <tr><th width="15%">Константа</th><th width="10%">Значение</th><th width="75%">Описание</th></tr>
        <tr><td>PERIOD_M1</td><td>1</td><td>1 минута</td></tr>
        <tr><td>PERIOD_M5</td><td>5</td><td>5 минут</td></tr>
        <tr><td>PERIOD_M15</td><td>15</td><td>15 минут</td></tr>
        <tr><td>PERIOD_M30</td><td>30</td><td>30 минут</td></tr>
        <tr><td>PERIOD_H1</td><td>60</td><td>1 час</td></tr>
        <tr><td>PERIOD_H4</td><td>240</td><td>4 часа</td></tr>
        <tr><td>PERIOD_D1</td><td>1440</td><td>1 день</td></tr>
        <tr><td>PERIOD_W1</td><td>10080</td><td>1 неделя</td></tr>
        <tr><td>PERIOD_MN1</td><td>43200</td><td>1 месяц</td></tr>
        <tr><td>0 (ноль)</td><td>0</td><td>Период текущего графика</td></tr>
        </table>
      </content>
    </text>

    <text>
      tag=constants_trading
      caption=Торговые операции
      keywords=;OP_BUY;OP_SELL;OP_BUYLIMIT;OP_SELLLIMIT;OP_BUYSTOP;OP_SELLSTOP;
      <content>
        <p>Тип операций для функции <a href="help://trading_OrderSend">OrderSend()</a>. Mожет быть любым из следующих величин:</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums">
        <tr><th width="15%">Константа</th><th width="10%">Значение</th><th width="75%">Описание</th></tr>
        <tr><td>OP_BUY</td><td>0</td><td>Покупка</td></tr>
        <tr><td>OP_SELL</td><td>1</td><td>Продажа</td></tr>
        <tr><td>OP_BUYLIMIT</td><td>2</td><td>Отложенный ордер BUY LIMIT</td></tr>
        <tr><td>OP_SELLLIMIT</td><td>3</td><td>Отложенный ордер SELL LIMIT</td></tr>
        <tr><td>OP_BUYSTOP</td><td>4</td><td>Отложенный ордер BUY STOP</td></tr>
        <tr><td>OP_SELLSTOP</td><td>5</td><td>Отложенный ордер SELL STOP</td></tr>
        </table>
      </content>
    </text>

    <text>
      tag=constants_prices
      caption=Ценовые константы
      keywords=;PRICE_CLOSE;PRICE_OPEN;PRICE_HIGH;PRICE_LOW;PRICE_MEDIAN;PRICE_TYPICAL;PRICE_WEIGHTED;
      <content>
        <p>Используемая цена для расчёта индикаторов может принимать любое из следующих значений:</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums">
        <tr><th width="15%">Константа</th><th width="10%">Значение</th><th width="75%">Описание</th></tr>
              <tr><td>PRICE_CLOSE</td><td>0</td><td>Цена закрытия</td></tr>
              <tr><td>PRICE_OPEN</td><td>1</td><td>Цена открытия</td></tr>
              <tr><td>PRICE_HIGH</td><td>2</td><td>Максимальная цена</td></tr>
              <tr><td>PRICE_LOW</td><td>3</td><td>Минимальная цена</td></tr>
              <tr><td>PRICE_MEDIAN</td><td>4</td><td>Средняя цена, (high+low)/2</td></tr>
              <tr><td>PRICE_TYPICAL</td><td>5</td><td>Типичная цена, (high+low+close)/3</td></tr>
              <tr><td>PRICE_WEIGHTED</td><td>6</td><td>Взвешенная цена закрытия, (high+low+close+close)/4</td></tr>
              </table>
      </content>
    </text>

    <text>
      tag=constants_marketinfo
      caption=MarketInfo
      <keywords>
      ;MODE_BID;MODE_ASK;MODE_POINT;MODE_DIGITS;MODE_SPREAD;MODE_TIME;MODE_LOW;MODE_HIGH;MODE_TIME;MODE_STOPLEVEL;
      ;MODE_LOTSIZE;MODE_TICKVALUE;MODE_TICKSIZE;MODE_SWAPLONG;MODE_SWAPSHORT;MODE_STARTING;MODE_EXPIRATION;
      ;MODE_TRADEALLOWED;MODE_MINLOT;MODE_LOTSTEP;MODE_MAXLOT;MODE_SWAPTYPE;MODE_PROFITCALCMODE;MODE_MARGINCALCMODE;
      ;MODE_MARGININIT;MODE_MARGINMAINTENANCE;MODE_MARGINHEDGED;MODE_MARGINREQUIRED;MODE_FREEZELEVEL;
      </keywords>
      <content>
        <p>Идентификаторы запроса, используемые в функции <a href="help://common_MarketInfo">MarketInfo()</a>.
        Mогут быть одной из следующего величин:</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums">
        <tr><th width="15%">Константа</th><th width="10%">Значение</th><th width="75%">Описание</th></tr>
        <tr><td>MODE_LOW</td><td>1</td><td>Минимальная дневная цена</td></tr>
        <tr><td>MODE_HIGH</td><td>2</td><td>Максимальная дневная цена</td></tr>
        <tr><td>MODE_TIME</td><td>5</td><td>Время поступления последней котировки</td></tr>
        <tr><td>MODE_BID</td><td>9</td><td>Последняя поступившая цена предложения. Для текущего инструмента хранится в предопределенной переменной <a href="help://predefined_variables_Bid">Bid</a></td></tr>
        <tr><td>MODE_ASK</td><td>10</td><td>Последняя поступившая цена продажи. Для текущего инструмента хранится в предопределенной переменной <a href="help://predefined_variables_Ask">Ask</a></td></tr>
        <tr><td>MODE_POINT</td><td>11</td><td>Размер пункта в валюте котировки. Для текущего инструмента хранится в предопределенной переменной <a href="help://predefined_variables_Point">Point</a></td></tr>
        <tr><td>MODE_DIGITS</td><td>12</td><td>Количество цифр после десятичного точки в цене инструмента. Для текущего инструмента хранится в предопределенной переменной <a href="help://predefined_variables_Digits">Digits</a></td></tr>
        <tr><td>MODE_SPREAD</td><td>13</td><td>Спрэд в пунктах</td></tr>
        <tr><td>MODE_STOPLEVEL</td><td>14</td><td>Минимально допустимый уровень стоп-лосса/тейк-профита в пунктах</td></tr>
        <tr><td>MODE_LOTSIZE</td><td>15</td><td>Размер контракта в базовой валюте инструмента</td></tr>
        <tr><td>MODE_TICKVALUE</td><td>16</td><td>Размер минимального изменения цены инструмента в валюте депозита</td></tr>
        <tr><td>MODE_TICKSIZE</td><td>17</td><td>Минимальный шаг изменения цены инструмента в валюте котировки</td></tr>
        <tr><td>MODE_SWAPLONG</td><td>18</td><td>Размер свопа для длинных позиций</td></tr>
        <tr><td>MODE_SWAPSHORT</td><td>19</td><td>Размер свопа для коротких позиций</td></tr>
        <tr><td>MODE_STARTING</td><td>20</td><td>Календарная дата начала торгов (обычно используется для фьючерсов)</td></tr>
        <tr><td>MODE_EXPIRATION</td><td>21</td><td>Календарная дата конца торгов (обычно используется для фьючерсов)</td></tr>
        <tr><td>MODE_TRADEALLOWED</td><td>22</td><td>Разрешение торгов по указанному инструменту</td></tr>
        <tr><td>MODE_MINLOT</td><td>23</td><td>Минимальный размер лота</td></tr>
        <tr><td>MODE_LOTSTEP</td><td>24</td><td>Шаг изменения размера лота</td></tr>
        <tr><td>MODE_MAXLOT</td><td>25</td><td>Максимальный размер лота</td></tr>
        <tr><td>MODE_SWAPTYPE</td><td>26</td><td>Метод вычисления свопов. 0 - в пунктах; 1 - в базовой валюте инструмента; 2 - в процентах; 3 - в валюте залоговых средств.</td></tr>
        <tr><td>MODE_PROFITCALCMODE</td><td>27</td><td>Способ расчета прибыли. 0 - Forex; 1 - CFD; 2 - Futures</td></tr>
        <tr><td>MODE_MARGINCALCMODE</td><td>28</td><td>Способ расчета залоговых средств. 0 - Forex; 1 - CFD; 2 - Futures; 3 - CFD на индексы</td></tr>
        <tr><td>MODE_MARGININIT</td><td>29</td><td>Начальные залоговые требования для 1 лота</td></tr>
        <tr><td>MODE_MARGINMAINTENANCE</td><td>30</td><td>Размер залоговых средств для поддержки открытых позиций в расчете на 1 лот</td></tr>
        <tr><td>MODE_MARGINHEDGED</td><td>31</td><td>Маржа, взимаемая с перекрытых позиций в расчете на 1 лот</td></tr>
        <tr><td>MODE_MARGINREQUIRED</td><td>32</td><td>Размер свободных средств, необходимых для открытия 1 лота на покупку</td></tr>
        <tr><td>MODE_FREEZELEVEL</td><td>33</td><td>Уровень заморозки ордеров в пунктах. Если цена исполнения находится в пределах, определяемых уровнем заморозки, то ордер не может быть модифицирован, отменен или закрыт.</td></tr>
        </table><br/>
      </content>
    </text>

    <text>
      tag=constants_drawstyles
      caption=Стили рисования
      keywords=;DRAW_NONE;DRAW_LINE;DRAW_SECTION;DRAW_HISTOGRAM;DRAW_ARROW;DRAW_ZIGZAG;STYLE_SOLID;STYLE_DASH;STYLE_DOT;STYLE_DASHDOT;STYLE_DASHDOTDOT;
      <content>
        <p>Перечисленние стилей рисования для функций <a href="help://customind_SetIndexStyle">SetIndexStyle()</a> и 
        <a href="help://customind_SetLevelStyle">SetLevelStyle()</a>. Может быть любым из следующего величин:</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums">
        <tr><th width="15%">Константа</th><th width="10%">Значение</th><th width="75%">Описание</th></tr>
        <tr><td>DRAW_LINE</td><td>0</td><td>Простая линия</td></tr>
        <tr><td>DRAW_SECTION</td><td>1</td><td>Отрезки между непустыми значениями линии</td></tr>
        <tr><td>DRAW_HISTOGRAM</td><td>2</td><td>Гистограмма</td></tr>
        <tr><td>DRAW_ARROW</td><td>3</td><td>Стрелки (символы)</td></tr>
        <tr><td>DRAW_ZIGZAG</td><td>4</td><td>Отрезки между непустыми значениями чётной и нечётной линий (зигзаг)</td></tr>
        <tr><td>DRAW_NONE</td><td>12</td><td>Отсутствие какого-либо рисования</td></tr>
        </table><br/>

        <p>Стиль линии. Используется только при толщине линии 0 или 1. Может быть любое из следующих значений:</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums">
        <tr><th width="15%">Константа</th><th width="10%">Значение</th><th width="75%">Описание</th></tr>
        <tr><td>STYLE_SOLID</td><td>0</td><td>Сплошная линия</td></tr>
        <tr><td>STYLE_DASH</td><td>1</td><td>Штриховая линия</td></tr>
        <tr><td>STYLE_DOT</td><td>2</td><td>Пунктирная линия</td></tr>
        <tr><td>STYLE_DASHDOT</td><td>3</td><td>Штрих-пунктирная линия</td></tr>
        <tr><td>STYLE_DASHDOTDOT</td><td>4</td><td>Штрих-пунктирная линия с двойными точками</td></tr>
        </table><br/>
        <p>Стиль линии может также использоваться для получения или установки свойства 
        <a href="help://constants_objects_properties">OBJPROP_STYLE</a> объекта.</p>
      </content>
    </text>

    <text>
      tag=constants_arrows
      caption=Коды стрелок
      keywords=;SYMBOL_LEFTPRICE;SYMBOL_RIGHTPRICE;SYMBOL_THUMBSUP;SYMBOL_THUMBSDOWN;SYMBOL_ARROWUP;SYMBOL_ARROWDOWN;SYMBOL_STOPSIGN;SYMBOL_CHECKSIGN;
      <content>
        <p>Константы кодов стрелок. Mогут иметь следующие значения:</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums">
        <tr><th width="15%">Константа</th><th width="10%">Значение</th><th width="75%">Описание</th></tr>
        <tr><td>SYMBOL_THUMBSUP</td><td>67</td><td>Символ - большой палец вверх (<span style="font: 12pt Wingdings;">&#67;</span>)</td></tr>
        <tr><td>SYMBOL_THUMBSDOWN</td><td>68</td><td>Символ - большой палец вниз (<span style="font: 12pt Wingdings;">&#68;</span>)</td></tr>
        <tr><td>SYMBOL_ARROWUP</td><td>241</td><td>Символ - стрелка вверх (<span style="font: 12pt Wingdings;">&#241;</span>)</td></tr>
        <tr><td>SYMBOL_ARROWDOWN</td><td>242</td><td>Символ - стрелка вниз (<span style="font: 12pt Wingdings;">&#242;</span>)</td></tr>
        <tr><td>SYMBOL_STOPSIGN</td><td>251</td><td>Символ - СТОП (<span style="font: 12pt Wingdings;">&#251;</span>)</td></tr>
        <tr><td>SYMBOL_CHECKSIGN</td><td>252</td><td>Символ - галочка (<span style="font: 12pt Wingdings;">&#252;</span>)</td></tr>
        </table><br/>
        
        <p>Специальные коды стрелок, которые точно указывают на цену и время. Mогут быть следующими величинами:</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums">
        <tr><th width="15%">Константа</th><th width="10%">Значение</th><th width="75%">Описание</th></tr>
        <tr><td>&nbsp;</td><td>1</td><td>Восходящая стрелка с подсказкой направо (<span style="font-family: Lucida Sans Unicode; font-size: 12pt;">&#8625;</span>)</td></tr>
        <tr><td>&nbsp;</td><td>2</td><td>Нисходящая стрелка с подсказкой направо (<span style="font-family: Lucida Sans Unicode; font-size: 12pt;">&#8627;</span>)</td></tr>
        <tr><td>&nbsp;</td><td>3</td><td>Левый указывающий треугольник (<span style="font: 12pt Arial;">&#9668;</span>)</td></tr>
        <tr><td>&nbsp;</td><td>4</td><td>Символ Черточки (&#8211;)</td></tr>
        <tr><td>SYMBOL_LEFTPRICE</td><td>5</td><td>Левая ценовая метка</td></tr>
        <tr><td>SYMBOL_RIGHTPRICE</td><td>6</td><td>Правая ценовая метка</td></tr>
        </table><br/>
        <p>Специальные коды стрелок не могут использоваться в пользовательских индикаторах при 
        <a href="help://customind_SetIndexArrow">установке значения стрелки</a> для линий, имеющих стиль 
        <a href="help://constants_drawstyles">DRAW_ARROW</a>.</p>
      </content>
    </text>

   <text>
      tag=constants_wingdings
      caption=Wingdings
      <content>
        <p>Символы шрифта Wingdings, используемые с объектом <a href="help://constants_objects">OBJ_ARROW</a>:</p>
        <table border="0" cellspacing="0" cellpadding="2" class="symbols" width="96%">
        <tr><td class="l_smb">&#32;</td><td class="l_code">32</td><td class="l_smb">&#33;</td><td class="l_code">33</td>
        <td class="l_smb">&#34;</td><td class="l_code">34</td><td class="l_smb">&#35;</td><td class="l_code">35</td>
        <td class="l_smb">&#36;</td><td class="l_code">36</td><td class="l_smb">&#37;</td><td class="l_code">37</td>
        <td class="l_smb">&#38;</td><td class="l_code">38</td><td class="l_smb">&#39;</td><td class="l_code">39</td>
        <td class="l_smb">&#40;</td><td class="l_code">40</td><td class="l_smb">&#41;</td><td class="l_code">41</td>
        <td class="l_smb">&#42;</td><td class="l_code">42</td><td class="l_smb">&#43;</td><td class="l_code">43</td>
        <td class="l_smb">&#44;</td><td class="l_code">44</td><td class="l_smb">&#45;</td><td class="l_code">45</td>
        <td class="l_smb">&#46;</td><td class="l_code">46</td><td class="l_smb">&#47;</td><td>47</td></tr>
        <tr><td class="d_smb">&#48;</td><td class="d_code">48</td><td class="d_smb">&#49;</td><td class="d_code">49</td>
        <td class="d_smb">&#50;</td><td class="d_code">50</td><td class="d_smb">&#51;</td><td class="d_code">51</td>
        <td class="d_smb">&#52;</td><td class="d_code">52</td><td class="d_smb">&#53;</td><td class="d_code">53</td>
        <td class="d_smb">&#54;</td><td class="d_code">54</td><td class="d_smb">&#55;</td><td class="d_code">55</td>
        <td class="d_smb">&#56;</td><td class="d_code">56</td><td class="d_smb">&#57;</td><td class="d_code">57</td>
        <td class="d_smb">&#58;</td><td class="d_code">58</td><td class="d_smb">&#59;</td><td class="d_code">59</td>
        <td class="d_smb">&#60;</td><td class="d_code">60</td><td class="d_smb">&#61;</td><td class="d_code">61</td>
        <td class="d_smb">&#62;</td><td class="d_code">62</td><td class="d_smb">&#63;</td><td class="d_code_e">63</td></tr>
        <tr><td class="l_smb">&#64;</td><td class="l_code">64</td><td class="l_smb">&#65;</td><td class="l_code">65</td>
        <td class="l_smb">&#66;</td><td class="l_code">66</td><td class="l_smb">&#67;</td><td class="l_code">67</td>
        <td class="l_smb">&#68;</td><td class="l_code">68</td><td class="l_smb">&#69;</td><td class="l_code">69</td>
        <td class="l_smb">&#70;</td><td class="l_code">70</td><td class="l_smb">&#71;</td><td class="l_code">71</td>
        <td class="l_smb">&#72;</td><td class="l_code">72</td><td class="l_smb">&#73;</td><td class="l_code">73</td>
        <td class="l_smb">&#74;</td><td class="l_code">74</td><td class="l_smb">&#75;</td><td class="l_code">75</td>
        <td class="l_smb">&#76;</td><td class="l_code">76</td><td class="l_smb">&#77;</td><td class="l_code">77</td>
        <td class="l_smb">&#78;</td><td class="l_code">78</td><td class="l_smb">&#79;</td><td>79</td></tr>
        <tr><td class="d_smb">&#80;</td><td class="d_code">80</td><td class="d_smb">&#81;</td><td class="d_code">81</td>
        <td class="d_smb">&#82;</td><td class="d_code">82</td><td class="d_smb">&#83;</td><td class="d_code">83</td>
        <td class="d_smb">&#84;</td><td class="d_code">84</td><td class="d_smb">&#85;</td><td class="d_code">85</td>
        <td class="d_smb">&#86;</td><td class="d_code">86</td><td class="d_smb">&#87;</td><td class="d_code">87</td>
        <td class="d_smb">&#88;</td><td class="d_code">88</td><td class="d_smb">&#89;</td><td class="d_code">89</td>
        <td class="d_smb">&#90;</td><td class="d_code">90</td><td class="d_smb">&#91;</td><td class="d_code">91</td>
        <td class="d_smb">&#92;</td><td class="d_code">92</td><td class="d_smb">&#93;</td><td class="d_code">93</td>
        <td class="d_smb">&#94;</td><td class="d_code">94</td><td class="d_smb">&#95;</td><td class="d_code_e">95</td></tr>
        <tr><td class="l_smb">&#96;</td><td class="l_code">96</td><td class="l_smb">&#97;</td><td class="l_code">97</td>
        <td class="l_smb">&#98;</td><td class="l_code">98</td><td class="l_smb">&#99;</td><td class="l_code">99</td>
        <td class="l_smb">&#100;</td><td class="l_code">100</td><td class="l_smb">&#101;</td><td class="l_code">101</td>
        <td class="l_smb">&#102;</td><td class="l_code">102</td><td class="l_smb">&#103;</td><td class="l_code">103</td>
        <td class="l_smb">&#104;</td><td class="l_code">104</td><td class="l_smb">&#105;</td><td class="l_code">105</td>
        <td class="l_smb">&#106;</td><td class="l_code">106</td><td class="l_smb">&#107;</td><td class="l_code">107</td>
        <td class="l_smb">&#108;</td><td class="l_code">108</td><td class="l_smb">&#109;</td><td class="l_code">109</td>
        <td class="l_smb">&#110;</td><td class="l_code">110</td><td class="l_smb">&#111;</td><td>111</td></tr>
        <tr><td class="d_smb">&#112;</td><td class="d_code">112</td><td class="d_smb">&#113;</td><td class="d_code">113</td>
        <td class="d_smb">&#114;</td><td class="d_code">114</td><td class="d_smb">&#115;</td><td class="d_code">115</td>
        <td class="d_smb">&#116;</td><td class="d_code">116</td><td class="d_smb">&#117;</td><td class="d_code">117</td>
        <td class="d_smb">&#118;</td><td class="d_code">118</td><td class="d_smb">&#119;</td><td class="d_code">119</td>
        <td class="d_smb">&#120;</td><td class="d_code">120</td><td class="d_smb">&#121;</td><td class="d_code">121</td>
        <td class="d_smb">&#122;</td><td class="d_code">122</td><td class="d_smb">&#123;</td><td class="d_code">123</td>
        <td class="d_smb">&#124;</td><td class="d_code">124</td><td class="d_smb">&#125;</td><td class="d_code">125</td>
        <td class="d_smb">&#126;</td><td class="d_code">126</td><td class="d_smb">&#127;</td><td class="d_code_e">127</td></tr>
        <tr><td class="l_smb">&#128;</td><td class="l_code">128</td><td class="l_smb">&#129;</td><td class="l_code">129</td>
        <td class="l_smb">&#130;</td><td class="l_code">130</td><td class="l_smb">&#131;</td><td class="l_code">131</td>
        <td class="l_smb">&#132;</td><td class="l_code">132</td><td class="l_smb">&#133;</td><td class="l_code">133</td>
        <td class="l_smb">&#134;</td><td class="l_code">134</td><td class="l_smb">&#135;</td><td class="l_code">135</td>
        <td class="l_smb">&#136;</td><td class="l_code">136</td><td class="l_smb">&#137;</td><td class="l_code">137</td>
        <td class="l_smb">&#138;</td><td class="l_code">138</td><td class="l_smb">&#139;</td><td class="l_code">139</td>
        <td class="l_smb">&#140;</td><td class="l_code">140</td><td class="l_smb">&#141;</td><td class="l_code">141</td>
        <td class="l_smb">&#142;</td><td class="l_code">142</td><td class="l_smb">&#143;</td><td>143</td></tr>
        <tr><td class="d_smb">&#144;</td><td class="d_code">144</td><td class="d_smb">&#145;</td><td class="d_code">145</td>
        <td class="d_smb">&#146;</td><td class="d_code">146</td><td class="d_smb">&#147;</td><td class="d_code">147</td>
        <td class="d_smb">&#148;</td><td class="d_code">148</td><td class="d_smb">&#149;</td><td class="d_code">149</td>
        <td class="d_smb">&#150;</td><td class="d_code">150</td><td class="d_smb">&#151;</td><td class="d_code">151</td>
        <td class="d_smb">&#152;</td><td class="d_code">152</td><td class="d_smb">&#153;</td><td class="d_code">153</td>
        <td class="d_smb">&#154;</td><td class="d_code">154</td><td class="d_smb">&#155;</td><td class="d_code">155</td>
        <td class="d_smb">&#156;</td><td class="d_code">156</td><td class="d_smb">&#157;</td><td class="d_code">157</td>
        <td class="d_smb">&#158;</td><td class="d_code">158</td><td class="d_smb">&#159;</td><td class="d_code_e">159</td></tr>
        <tr><td class="l_smb">&#160;</td><td class="l_code">160</td><td class="l_smb">&#161;</td><td class="l_code">161</td>
        <td class="l_smb">&#162;</td><td class="l_code">162</td><td class="l_smb">&#163;</td><td class="l_code">163</td>
        <td class="l_smb">&#164;</td><td class="l_code">164</td><td class="l_smb">&#165;</td><td class="l_code">165</td>
        <td class="l_smb">&#166;</td><td class="l_code">166</td><td class="l_smb">&#167;</td><td class="l_code">167</td>
        <td class="l_smb">&#168;</td><td class="l_code">168</td><td class="l_smb">&#169;</td><td class="l_code">169</td>
        <td class="l_smb">&#170;</td><td class="l_code">170</td><td class="l_smb">&#171;</td><td class="l_code">171</td>
        <td class="l_smb">&#172;</td><td class="l_code">172</td><td class="l_smb">&#173;</td><td class="l_code">173</td>
        <td class="l_smb">&#174;</td><td class="l_code">174</td><td class="l_smb">&#175;</td><td>175</td></tr>
        <tr><td class="d_smb">&#176;</td><td class="d_code">176</td><td class="d_smb">&#177;</td><td class="d_code">177</td>
        <td class="d_smb">&#178;</td><td class="d_code">178</td><td class="d_smb">&#179;</td><td class="d_code">179</td>
        <td class="d_smb">&#180;</td><td class="d_code">180</td><td class="d_smb">&#181;</td><td class="d_code">181</td>
        <td class="d_smb">&#182;</td><td class="d_code">182</td><td class="d_smb">&#183;</td><td class="d_code">183</td>
        <td class="d_smb">&#184;</td><td class="d_code">184</td><td class="d_smb">&#185;</td><td class="d_code">185</td>
        <td class="d_smb">&#186;</td><td class="d_code">186</td><td class="d_smb">&#187;</td><td class="d_code">187</td>
        <td class="d_smb">&#188;</td><td class="d_code">188</td><td class="d_smb">&#189;</td><td class="d_code">189</td>
        <td class="d_smb">&#190;</td><td class="d_code">190</td><td class="d_smb">&#191;</td><td class="d_code_e">191</td></tr>
        <tr><td class="l_smb">&#192;</td><td class="l_code">192</td><td class="l_smb">&#193;</td><td class="l_code">193</td>
        <td class="l_smb">&#194;</td><td class="l_code">194</td><td class="l_smb">&#195;</td><td class="l_code">195</td>
        <td class="l_smb">&#196;</td><td class="l_code">196</td><td class="l_smb">&#197;</td><td class="l_code">197</td>
        <td class="l_smb">&#198;</td><td class="l_code">198</td><td class="l_smb">&#199;</td><td class="l_code">199</td>
        <td class="l_smb">&#200;</td><td class="l_code">200</td><td class="l_smb">&#201;</td><td class="l_code">201</td>
        <td class="l_smb">&#202;</td><td class="l_code">202</td><td class="l_smb">&#203;</td><td class="l_code">203</td>
        <td class="l_smb">&#204;</td><td class="l_code">204</td><td class="l_smb">&#205;</td><td class="l_code">205</td>
        <td class="l_smb">&#206;</td><td class="l_code">206</td><td class="l_smb">&#207;</td><td>207</td></tr>
        <tr><td class="d_smb">&#208;</td><td class="d_code">208</td><td class="d_smb">&#209;</td><td class="d_code">209</td>
        <td class="d_smb">&#210;</td><td class="d_code">210</td><td class="d_smb">&#211;</td><td class="d_code">211</td>
        <td class="d_smb">&#212;</td><td class="d_code">212</td><td class="d_smb">&#213;</td><td class="d_code">213</td>
        <td class="d_smb">&#214;</td><td class="d_code">214</td><td class="d_smb">&#215;</td><td class="d_code">215</td>
        <td class="d_smb">&#216;</td><td class="d_code">216</td><td class="d_smb">&#217;</td><td class="d_code">217</td>
        <td class="d_smb">&#218;</td><td class="d_code">218</td><td class="d_smb">&#219;</td><td class="d_code">219</td>
        <td class="d_smb">&#220;</td><td class="d_code">220</td><td class="d_smb">&#221;</td><td class="d_code">221</td>
        <td class="d_smb">&#222;</td><td class="d_code">222</td><td class="d_smb">&#223;</td><td class="d_code_e">223</td></tr>
        <tr><td class="l_smb">&#224;</td><td class="l_code">224</td><td class="l_smb">&#225;</td><td class="l_code">225</td>
        <td class="l_smb">&#226;</td><td class="l_code">226</td><td class="l_smb">&#227;</td><td class="l_code">227</td>
        <td class="l_smb">&#228;</td><td class="l_code">228</td><td class="l_smb">&#229;</td><td class="l_code">229</td>
        <td class="l_smb">&#230;</td><td class="l_code">230</td><td class="l_smb">&#231;</td><td class="l_code">231</td>
        <td class="l_smb">&#232;</td><td class="l_code">232</td><td class="l_smb">&#233;</td><td class="l_code">233</td>
        <td class="l_smb">&#234;</td><td class="l_code">234</td><td class="l_smb">&#235;</td><td class="l_code">235</td>
        <td class="l_smb">&#236;</td><td class="l_code">236</td><td class="l_smb">&#237;</td><td class="l_code">237</td>
        <td class="l_smb">&#238;</td><td class="l_code">238</td><td class="l_smb">&#239;</td><td>239</td></tr>
        <tr><td class="d_smb">&#240;</td><td class="d_code">240</td><td class="d_smb">&#241;</td><td class="d_code">241</td>
        <td class="d_smb">&#242;</td><td class="d_code">242</td><td class="d_smb">&#243;</td><td class="d_code">243</td>
        <td class="d_smb">&#244;</td><td class="d_code">244</td><td class="d_smb">&#245;</td><td class="d_code">245</td>
        <td class="d_smb">&#246;</td><td class="d_code">246</td><td class="d_smb">&#247;</td><td class="d_code">247</td>
        <td class="d_smb">&#248;</td><td class="d_code">248</td><td class="d_smb">&#249;</td><td class="d_code">249</td>
        <td class="d_smb">&#250;</td><td class="d_code">250</td><td class="d_smb">&#251;</td><td class="d_code">251</td>
        <td class="d_smb">&#252;</td><td class="d_code">252</td><td class="d_smb">&#253;</td><td class="d_code">253</td>
        <td class="d_smb">&#254;</td><td class="d_code">254</td><td class="d_smb">&#255;</td><td class="d_code_e">255</td></tr>
        </table><br/>
      </content>
   </text>

   <text>
      tag=constants_colors
      caption=Набор Web-цветов
      <keywords>
      ;Black;DarkGreen;DarkSlateGray;Olive;Green;Teal;Navy;Purple;Maroon;Indigo;MidnightBlue;DarkBlue;
      ;DarkOliveGreen;SaddleBrown;ForestGreen;OliveDrab;SeaGreen;DarkGoldenrod;DarkSlateBlue;Sienna;MediumBlue;
      ;Brown;DarkTurquoise;DimGray;LightSeaGreen;DarkViolet;FireBrick;MediumVioletRed;MediumSeaGreen;
      ;Chocolate;Crimson;SteelBlue;Goldenrod;MediumSpringGreen;LawnGreen;CadetBlue;DarkOrchid;YellowGreen;
      ;LimeGreen;OrangeRed;DarkOrange;Orange;Gold;Yellow;Chartreuse;Lime;SpringGreen;Aqua;DeepSkyBlue;Blue;
      ;Magenta;Red;Gray;SlateGray;Peru;BlueViolet;LightSlateGray;DeepPink;MediumTurquoise;DodgerBlue;
      ;Turquoise;RoyalBlue;SlateBlue;DarkKhaki;IndianRed;MediumOrchid;GreenYellow;MediumAquamarine;
      ;DarkSeaGreen;Tomato;RosyBrown;Orchid;MediumPurple;PaleVioletRed;Coral;CornflowerBlue;DarkGray;
      ;SandyBrown;MediumSlateBlue;Tan;DarkSalmon;BurlyWood;HotPink;Salmon;Violet;LightCoral;SkyBlue;
      ;LightSalmon;Plum;Khaki;LightGreen;Aquamarine;Silver;LightSkyBlue;LightSteelBlue;LightBlue;
      ;PaleGreen;Thistle;PowderBlue;PaleGoldenrod;PaleTurquoise;LightGray;Wheat;NavajoWhite;Moccasin;LightPink;
      ;Gainsboro;PeachPuff;Pink;Bisque;LightGoldenrod;BlanchedAlmond;LemonChiffon;Beige;AntiqueWhite;PapayaWhip;
      ;Cornsilk;LightYellow;LightCyan;Linen;Lavender;MistyRose;OldLace;WhiteSmoke;Seashell;Ivory;
      ;Honeydew;AliceBlue;LavenderBlush;MintCream;Snow;White;
      </keywords>
      <content>
        Тип color, поддерживающий цветовые константы:<br/><br/>
        <div align="center">
        <table style="FONT-SIZE: 8pt; FONT-FAMILY: Tahoma" cellspacing="1" cellpadding="2" bgcolor="#c0c0c0" border="0" width="96%">
        <tr align="center">
          <td style="background: black; color: white;" width="12.5%">Black</td>
          <td style="background: darkgreen; color: white" width="12.5%">DarkGreen</td>
          <td style="background: darkslategray; color: white" width="12.5%">DarkSlateGray</td>
          <td style="background: olive; color: white" width="12.5%">Olive</td>
          <td style="background: green; color: white" width="12.5%">Green</td>
          <td style="background: teal; color: white" width="12.5%">Teal</td>
          <td style="background: navy; color: white" width="12.5%">Navy</td>
          <td style="background: purple; color: white" width="12.5%">Purple</td></tr>
        <tr align="center">
          <td style="background: maroon; color: white">Maroon</td>
          <td style="background: indigo; color: white">Indigo</td>
          <td style="background: midnightblue; color: white">MidnightBlue</td>
          <td style="background: darkblue; color: white">DarkBlue</td>
          <td style="background: darkolivegreen; color: white">DarkOliveGreen</td>
          <td style="background: saddlebrown; color: white">SaddleBrown</td>
          <td style="background: forestgreen; color: white">ForestGreen</td>
          <td style="background: olivedrab; color: white">OliveDrab</td></tr>
        <tr align="center">
          <td style="background: seagreen; color: white">SeaGreen</td>
          <td style="background: darkgoldenrod; color: white">DarkGoldenrod</td>
          <td style="background: darkslateblue; color: white">DarkSlateBlue</td>
          <td style="background: sienna; color: white">Sienna</td>
          <td style="background: mediumblue; color: white">MediumBlue</td>
          <td style="background: brown; color: white">Brown</td>
          <td style="background: darkturquoise">DarkTurquoise</td>
          <td style="background: dimgray; color: white">DimGray</td></tr>
        <tr align="center">
          <td style="background: lightseagreen">LightSeaGreen</td>
          <td style="background: darkviolet; color: white">DarkViolet</td>
          <td style="background: firebrick; color: white">FireBrick</td>
          <td style="background: mediumvioletred; color: white">MediumVioletRed</td>
          <td style="background: mediumseagreen; color: white">MediumSeaGreen</td>
          <td style="background: chocolate; color: white">Chocolate</td>
          <td style="background: crimson; color: white">Crimson</td>
          <td style="background: steelblue; color: white">SteelBlue</td></tr>
        <tr align="center">
          <td style="background: goldenrod">Goldenrod</td>
          <td style="background: mediumspringgreen; color: black">MediumSpringGreen</td>
          <td style="background: lawngreen; color: black">LawnGreen</td>
          <td style="background: cadetblue; color: white">CadetBlue</td>
          <td style="background: darkorchid; color: white">DarkOrchid</td>
          <td style="background: yellowgreen; color: white">YellowGreen</td>
          <td style="background: limegreen; color: white">LimeGreen</td>
          <td style="background: orangered; color: white">OrangeRed</td></tr>
        <tr align="center">
          <td style="background: darkorange; color: white">DarkOrange</td>
          <td style="background: orange">Orange</td>
          <td style="background: gold">Gold</td>
          <td style="background: yellow">Yellow</td>
          <td style="background: chartreuse; color: black">Chartreuse</td>
          <td style="background: lime; color: black">Lime</td>
          <td style="background: springgreen; color: black">SpringGreen</td>
          <td style="background: aqua">Aqua</td></tr>
        <tr align="center">
          <td style="background: deepskyblue">DeepSkyBlue</td>
          <td style="background: blue; color: white">Blue</td>
          <td style="background: magenta">Magenta</td>
          <td style="background: red; color: white">Red</td>
          <td style="background: gray; color: white">Gray</td>
          <td style="background: slategray; color: white">SlateGray</td>
          <td style="background: peru; color: white">Peru</td>
          <td style="background: blueviolet; color: white">BlueViolet</td></tr>
        <tr align="center">
          <td style="background: lightslategray; color: white">LightSlateGray</td>
          <td style="background: deeppink; color: white">DeepPink</td>
          <td style="background: mediumturquoise">MediumTurquoise</td>
          <td style="background: dodgerblue; color: white">DodgerBlue</td>
          <td style="background: turquoise">Turquoise</td>
          <td style="background: royalblue; color: white">RoyalBlue</td>
          <td style="background: slateblue; color: white">SlateBlue</td>
          <td style="background: darkkhaki">DarkKhaki</td></tr>
        <tr align="center">
          <td style="background: indianred; color: white">IndianRed</td>
          <td style="background: mediumorchid">MediumOrchid</td>
          <td style="background: greenyellow">GreenYellow</td>
          <td style="background: mediumaquamarine">MediumAquamarine</td>
          <td style="background: darkseagreen; color: white">DarkSeaGreen</td>
          <td style="background: tomato; color: white">Tomato</td>
          <td style="background: rosybrown; color: white">RosyBrown</td>
          <td style="background: orchid">Orchid</td></tr>
        <tr align="center">
          <td style="background: mediumpurple; color: white">MediumPurple</td>
          <td style="background: palevioletred; color: white">PaleVioletRed</td>
          <td style="background: coral; color: white">Coral</td>
          <td style="background: cornflowerblue; color: white">CornflowerBlue</td>
          <td style="background: darkgray">DarkGray</td>
          <td style="background: sandybrown">SandyBrown</td>
          <td style="background: mediumslateblue; color: white">MediumSlateBlue</td>
          <td style="background: tan">Tan</td></tr>
        <tr align="center">
          <td style="background: darksalmon; color: white">DarkSalmon</td>
          <td style="background: burlywood">BurlyWood</td>
          <td style="background: hotpink">HotPink</td>
          <td style="background: salmon; color: white">Salmon</td>
          <td style="background: violet">Violet</td>
          <td style="background: lightcoral; color: white">LightCoral</td>
          <td style="background: skyblue">SkyBlue</td>
          <td style="background: lightsalmon">LightSalmon</td></tr>
        <tr align="center">
          <td style="background: plum">Plum</td>
          <td style="background: khaki">Khaki</td>
          <td style="background: lightgreen; color: black">LightGreen</td>
          <td style="background: aquamarine">Aquamarine</td>
          <td style="background: silver">Silver</td>
          <td style="background: lightskyblue">LightSkyBlue</td>
          <td style="background: lightsteelblue">LightSteelBlue</td>
          <td style="background: lightblue">LightBlue</td></tr>
        <tr align="center">
          <td style="background: palegreen; color: black">PaleGreen</td>
          <td style="background: thistle">Thistle</td>
          <td style="background: powderblue">PowderBlue</td>
          <td style="background: palegoldenrod">PaleGoldenrod</td>
          <td style="background: paleturquoise">PaleTurquoise</td>
          <td style="background: f0f8ff">LightGray</td>
          <td style="background: wheat">Wheat</td>
          <td style="background: navajowhite">NavajoWhite</td></tr>
        <tr align="center">
          <td style="background: moccasin">Moccasin</td>
          <td style="background: lightpink">LightPink</td>
          <td style="background: gainsboro">Gainsboro</td>
          <td style="background: peachpuff">PeachPuff</td>
          <td style="background: pink">Pink</td>
          <td style="background: bisque">Bisque</td>
          <td style="background: eedc82">LightGoldenrod</td>
          <td style="background: blanchedalmond">BlanchedAlmond</td></tr>
        <tr align="center">
          <td style="background: lemonchiffon">LemonChiffon</td>
          <td style="background: beige">Beige</td>
          <td style="background: antiquewhite">AntiqueWhite</td>
          <td style="background: papayawhip">PapayaWhip</td>
          <td style="background: cornsilk">Cornsilk</td>
          <td style="background: lightyellow">LightYellow</td>
          <td style="background: lightcyan">LightCyan</td>
          <td style="background: linen">Linen</td></tr>
        <tr align="center">
          <td style="background: lavender">Lavender</td>
          <td style="background: mistyrose">MistyRose</td>
          <td style="background: oldlace">OldLace</td>
          <td style="background: whitesmoke">WhiteSmoke</td>
          <td style="background: seashell">Seashell</td>
          <td style="background: ivory">Ivory</td>
          <td style="background: honeydew">Honeydew</td>
          <td style="background: aliceblue">AliceBlue</td></tr>
        <tr align="center">
          <td style="background: lavenderblush">LavenderBlush</td>
          <td style="background: mintcream">MintCream</td>
          <td style="background: snow">Snow</td>
          <td style="background: white">White</td>
          <td style="background: white"></td>
          <td style="background: white"></td>
          <td style="background: white"></td>
          <td style="background: white"></td></tr>
        </table>
        </div><br/>
      </content>
    </text>

    <text>
      tag=constants_lines
      caption=Линии индикаторов
      keywords=;MODE_MAIN;MODE_PLUSDI;MODE_MINUSDI;MODE_SIGNAL;MODE_UPPER;MODE_LOWER;
      <content>
        <p>Идентификаторы линий индикаторов, используемых при вызове функций <a href="help://indicators_iMACD">iMACD()</a>, 
        <a href="help://indicators_iRVI">iRVI()</a> и <a href="help://indicators_iStochastic">iStochastic()</a>. Mогут иметь одно из следующего значений:</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums">
        <tr><th width="15%">Константа</th><th width="10%">Значение</th><th width="75%">Описание</th></tr>
        <tr><td>MODE_MAIN</td><td>0</td><td>Основная линия</td></tr>
        <tr><td>MODE_SIGNAL</td><td>1</td><td>Сигнальная линия</td></tr>
        </table><br/>
        
        <p>Идентификаторы линий Average Directional Movement Index, используемых при вызове функции 
        <a href="help://indicators_iADX">iADX()</a>:</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums">
        <tr><th width="15%">Константа</th><th width="10%">Значение</th><th width="75%">Описание</th></tr>
        <tr><td>MODE_MAIN</td><td>0</td><td>Основная линия</td></tr>
        <tr><td>MODE_PLUSDI</td><td>1</td><td>Линия +DI</td></tr>
        <tr><td>MODE_MINUSDI</td><td>2</td><td>Линия -DI</td></tr>
        </table><br/>
        
        <p>Идентификаторы линий индикаторов, используемых при вызове функций <a href="help://indicators_iBands">iBands()</a>,
        <a href="help://indicators_iEnvelopes">iEnvelopes()</a>, <a href="help://indicators_iEnvelopesOnArray">iEnvelopesOnArray()</a>, 
        <a href="help://indicators_iFractals">iFractals()</a> и <a href="help://indicators_iGator">iGator()</a>:</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums">
        <tr><th width="15%">Константа</th><th width="10%">Значение</th><th width="75%">Описание</th></tr>
        <tr><td>MODE_UPPER</td><td>1</td><td>Верхняя линия</td></tr>
        <tr><td>MODE_LOWER</td><td>2</td><td>Нижняя линия</td></tr>
        </table><br/>
      </content>
    </text>

    <text>
      tag=constants_ichimoku
      caption=Ichimoku Kinko Hyo
      keywords=;MODE_TENKANSEN;MODE_KIJUNSEN;MODE_SENKOUSPANA;MODE_SENKOUSPANB;MODE_CHINKOUSPAN;
      <content>
        <p>Идентификаторы линий индикатора Ichimoku Kinko Hyo, используемых при вызове функции 
        <a href="help://indicators_iIchimoku">iIchimoku()</a>. Могут иметь одно из следующих значений:</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums">
        <tr><th width="15%">Константа</th><th width="10%">Значение</th><th width="75%">Описание</th></tr>
        <tr><td>MODE_TENKANSEN</td><td>1</td><td>Tenkan-sen</td></tr>
        <tr><td>MODE_KIJUNSEN</td><td>2</td><td>Kijun-sen</td></tr>
        <tr><td>MODE_SENKOUSPANA</td><td>3</td><td>Senkou Span A</td></tr>
        <tr><td>MODE_SENKOUSPANB</td><td>4</td><td>Senkou Span B</td></tr>
        <tr><td>MODE_CHINKOUSPAN</td><td>5</td><td>Chinkou Span</td></tr>
        </table>
      </content>
    </text>

    <text>
      tag=constants_movings
      caption=Методы скользящих
      keywords=;MODE_SMA;MODE_EMA;MODE_SMMA;MODE_LWMA;
      <content>
        <p>Метод вычисления скользящего среднего (Moving Average). Используется в индикаторах 
        <a href="help://indicators_iAlligator">iAlligator()</a>, <a href="help://indicators_iEnvelopes">iEnvelopes()</a>,
        <a href="help://indicators_iEnvelopesOnArray">iEnvelopesOnArray</a>, <a href="help://indicators_iForce">iForce()</a>, 
        <a href="help://indicators_iGator">iGator()</a>, <a href="help://indicators_iMA">iMA()</a>, 
        <a href="help://indicators_iMAOnArray">iMAOnArray()</a>, <a href="help://indicators_iStdDev">iStdDev()</a>, 
        <a href="help://indicators_iStdDevOnArray">iStdDevOnArray()</a> и <a href="help://indicators_iStochastic">iStochastic()</a>.
        Mожет быть одним из следующих:</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums">
        <tr><th width="15%">Константа</th><th width="10%">Значение</th><th width="75%">Описание</th></tr>
        <tr><td>MODE_SMA</td><td>0</td><td>Простое скользящее среднее</td></tr>
        <tr><td>MODE_EMA</td><td>1</td><td>Экспоненциальное скользящее среднее</td></tr>
        <tr><td>MODE_SMMA</td><td>2</td><td>Сглаженное скользящее среднее</td></tr>
        <tr><td>MODE_LWMA</td><td>3</td><td>Линейно-взвешенное скользящее среднее</td></tr>
        </table>
      </content>
    </text>

    <text>
      tag=constants_messagebox
      caption=MessageBox
      <keywords>
      ;IDOK;IDCANCEL;IDABORT;IDRETRY;IDIGNORE;IDYES;IDNO;IDTRYAGAIN;IDCONTINUE;
      ;MB_OK;MB_OKCANCEL;MB_ABORTRETRYIGNORE;MB_YESNOCANCEL;MB_YESNO;MB_CANCELTRYCONTINUE;
      ;MB_ICONSTOP;MB_ICONERROR;MB_ICONHAND;MB_ICONQUESTION;MB_ICONEXCLAMATION;MB_ICONWARNING;
      ;MB_ICONINFORMATION;MB_ICONASTERISK;MB_DEFBUTTON1;MB_DEFBUTTON2;MB_DEFBUTTON3;MB_DEFBUTTON4;
      </keywords>
      <content>
        <p>Коды возврата функции <a href="help://common_MessageBox">MessageBox()</a>. Если окно сообщения имеет кнопку <em>Отмена (Cancel)</em>,
        то функция возвращает значение IDCANCEL при нажатой клавише ESC или кнопке <em>Отмена (Cancel)</em>.
        Если окно сообщения не имеет кнопки <em>Отмена (Cancel)</em>, нажатие ESC не дает никакого эффекта.</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums">
        <tr><th width="15%">Константа</th><th width="10%">Значение</th><th width="75%">Описание</th></tr>
        <tr><td>IDOK</td><td>1</td><td>Выбрана кнопка <em>OK</em></td></tr>
        <tr><td>IDCANCEL</td><td>2</td><td>Выбрана кнопка <em>Отмена (Cancel)</em></td></tr>
        <tr><td>IDABORT</td><td>3</td><td>Выбрана кнопка <em>Прервать (Abort)</em></td></tr>
        <tr><td>IDRETRY</td><td>4</td><td>Выбрана кнопка <em>Повтор (Retry)</em></td></tr>
        <tr><td>IDIGNORE</td><td>5</td><td>Выбрана кнопка <em>Пропустить (Ignore)</em></td></tr>
        <tr><td>IDYES</td><td>6</td><td>Выбрана кнопка <em>Да (Yes)</em></td></tr>
        <tr><td>IDNO</td><td>7</td><td>Выбрана кнопка <em>Нет (No)</em></td></tr>
        <tr><td>IDTRYAGAIN</td><td>10</td><td>Выбрана кнопка <em>Повторить (Try Again)</em></td></tr>
        <tr><td>IDCONTINUE</td><td>11</td><td>Выбрана кнопка <em>Продолжить (Continue)</em></td></tr>
        </table>
        <p>Эти коды возврата определены в файле <em>WinUser32.mqh</em>, поэтому необходимо включать 
        этот заголовочный файл в программы через <em>#include &lt;WinUser32.mqh&gt;</em>.</p>
        <p><br/>Основные флаги функции <a href="help://common_MessageBox">MessageBox()</a> определяют содержание и поведение диалогового окна.
        Это значение может быть комбинацией флагов из следующих групп флагов:</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums">
        <tr><th width="15%">Константа</th><th width="10%">Значение</th><th width="75%">Описание</th></tr>
        <tr><td>MB_OK</td><td>0x00000000</td><td>Окно сообщения содержит одну кнопку: OK. По умолчанию</td></tr>
        <tr><td>MB_OKCANCEL</td><td>0x00000001</td><td>Окно сообщения содержит две кнопки: OK и Cancel</td></tr>
        <tr><td>MB_ABORTRETRYIGNORE</td><td>0x00000002</td><td>Окно сообщения содержит три кнопки: Abort, Retry и Ignore</td></tr>
        <tr><td>MB_YESNOCANCEL</td><td>0x00000003</td><td>Окно сообщения содержит три кнопки: Yes, No и Cancel</td></tr>
        <tr><td>MB_YESNO</td><td>0x00000004</td><td>Окно сообщения содержит две кнопки: Yes и No</td></tr>
        <tr><td>MB_RETRYCANCEL</td><td>0x00000005</td><td>Окно сообщения содержит две кнопки: Retry и Cancel</td></tr>
        <tr><td>MB_CANCELTRYCONTINUE</td><td>0x00000006</td><td>Окно сообщения содержит три кнопки: Cancel, Try Again, Continue</td></tr>
        </table><br/>
        
        <p>Для отображения иконки в окне сообщения необходимо определить дополнительные флаги:</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums">
        <tr><th width="15%">Константа</th><th width="10%">Значение</th><th width="75%">Описание</th></tr>
        <tr><td>MB_ICONSTOP, MB_ICONERROR, MB_ICONHAND</td><td>0x00000010</td><td>Изображение знака STOP</td></tr>
        <tr><td>MB_ICONQUESTION</td><td>0x00000020</td><td>Изображение вопросительного знака</td></tr>
        <tr><td>MB_ICONEXCLAMATION, MB_ICONWARNING</td><td>0x00000030</td><td>Изображение восклицательного знака</td></tr>
        <tr><td>MB_ICONINFORMATION, MB_ICONASTERISK</td><td>0x00000040</td><td>Изображение, состоящее из строчного знака <b>i</b> в круге</td></tr>
        </table><br/>
        
        <p>Кнопки по умолчанию задаются следующими флагами:</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums">
        <tr><th width="15%">Константа</th><th width="10%">Значение</th><th width="75%">Описание</th></tr>
        <tr><td>MB_DEFBUTTON1</td><td>0x00000000</td><td>Первая кнопка MB_DEFBUTTON1 - кнопка выбрана по умолчанию, если MB_DEFBUTTON2, MB_DEFBUTTON3, или MB_DEFBUTTON4 не определены</td></tr>
        <tr><td>MB_DEFBUTTON2</td><td>0x00000100</td><td>Вторая кнопка - кнопка по умолчанию</td></tr>
        <tr><td>MB_DEFBUTTON3</td><td>0x00000200</td><td>Третья кнопка - кнопка по умолчанию</td></tr>
        <tr><td>MB_DEFBUTTON4</td><td>0x00000300</td><td>Четвертая кнопка - кнопка по умолчанию</td></tr>
        </table><br/>
        
        <p>Флаги поведения функции MessageBox() определены в файле <em>WinUser32.mqh</em>, поэтому необходимо включать 
        этот заголовочный файл в программы через <em>#include &lt;WinUser32.mqh&gt;</em>. Здесь перечислены не все возможные флаги. Более 
        подробную информацию можно получить в описании Win32 API.</p>
      </content>
    </text>

    <text>
      tag=constants_objects
      caption=Типы объектов
      <keywords>
      ;OBJ_HLINE;OBJ_VLINE;OBJ_TREND;OBJ_TRENDBYANGLE;OBJ_REGRESSION;
      ;OBJ_CHANNEL;OBJ_STDDEVCHANNEL;OBJ_GANNLINE;OBJ_GANNFAN;OBJ_GANNGRID;OBJ_FIBO;
      ;OBJ_FIBOTIMES;OBJ_FIBOFAN;OBJ_FIBOARC;OBJ_EXPANSION;OBJ_FIBOCHANNEL;OBJ_RECTANGLE;
      ;OBJ_TRIANGLE;OBJ_ELLIPSE;OBJ_PITCHFORK;OBJ_CYCLES;OBJ_TEXT;OBJ_ARROW;OBJ_LABEL;
      </keywords>
      <content>
        <p>Идентификаторы типов графических объектов используются в функциях 
        <a href="help://objects_ObjectCreate">ObjectCreate()</a>,
        <a href="help://objects_ObjectsDeleteAll">ObjectsDeleteAll()</a> и <a href="help://objects_ObjectType">ObjectType()</a>.
        Mогут быть любыми из следующих величин (объекты могут иметь 1-3 координаты в зависимости от типа):</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums">
        <tr><th width="15%">Константа</th><th width="10%">Значение</th><th width="75%">Описание</th></tr>
        <tr><td>OBJ_VLINE</td><td>0</td><td>Вертикальная линия. Использует время в качестве первой координаты, цена игнорируется</td></tr>
        <tr><td>OBJ_HLINE</td><td>1</td><td>Горизонтальная линия. Использует цену в качестве первой координаты, время игнорируется</td></tr>
        <tr><td>OBJ_TREND</td><td>2</td><td>Трендовая линия. Использует 2 координаты</td></tr>
        <tr><td>OBJ_TRENDBYANGLE</td><td>3</td><td>Трендовая линия по углу. Использует 2 координаты, либо первую координату и угол. Для установки угла линии (свойство OBJPROP_ANGLE) используется функция <a href="help://objects_ObjectSet">ObjectSet()</a></td></tr>
        <tr><td>OBJ_REGRESSION</td><td>4</td><td>Канал линейной регрессии. Использует временные составляющие 2 координат, ценовые составляющие игнорируются</td></tr>
        <tr><td>OBJ_CHANNEL</td><td>5</td><td>Равноудаленный канал. Использует 3 координаты</td></tr>
        <tr><td>OBJ_STDDEVCHANNEL</td><td>6</td><td>Канал стандартных отклонений. Использует временные составляющие 2 координат, ценовые составляющие игнорируются</td></tr>
        <tr><td>OBJ_GANNLINE</td><td>7</td><td>Линия Ганна. Использует 2 координаты, но ценовая составляющая второй координаты игнорируется. Для установки соотношения между временной и ценовой шкалами (свойство OBJPROP_SCALE) используется функция <a href="help://objects_ObjectSet">ObjectSet()</a></td></tr>
        <tr><td>OBJ_GANNFAN</td><td>8</td><td>Веер Ганна. Использует 2 координаты, но ценовая составляющая второй координаты игнорируется. Для установки соотношения между временной и ценовой шкалами (свойство OBJPROP_SCALE) используется функция <a href="help://objects_ObjectSet">ObjectSet()</a></td></tr>
        <tr><td>OBJ_GANNGRID</td><td>9</td><td>Сетка Ганна. Использует 2 координаты, но ценовая составляющая второй координаты игнорируется. Для установки соотношения между временной и ценовой шкалами (свойство OBJPROP_SCALE) используется функция <a href="help://objects_ObjectSet">ObjectSet()</a></td></tr>
        <tr><td>OBJ_FIBO</td><td>10</td><td>Уровни Фибоначчи. Использует 2 координаты. Для установки количества уровней (свойство OBJPROP_FIBOLEVELS) и значения уровней (свойство OBJPROP_FIRSTLEVEL+n) используется функция <a href="help://objects_ObjectSet">ObjectSet()</a></td></tr>
        <tr><td>OBJ_FIBOTIMES</td><td>11</td><td>Временные зоны Фибоначчи. Использует 2 координаты. Для установки количества уровней (свойство OBJPROP_FIBOLEVELS) и значения уровней (свойство OBJPROP_FIRSTLEVEL+n) используется функция <a href="help://objects_ObjectSet">ObjectSet()</a></td></tr>
        <tr><td>OBJ_FIBOFAN</td><td>12</td><td>Веер Фибоначчи. Использует 2 координаты. Для установки количества уровней (свойство OBJPROP_FIBOLEVELS) и значения уровней (свойство OBJPROP_FIRSTLEVEL+n) используется функция <a href="help://objects_ObjectSet">ObjectSet()</a></td></tr>
        <tr><td>OBJ_FIBOARC</td><td>13</td><td>Дуги Фибоначчи. Использует 2 координаты. Для установки количества уровней (свойство OBJPROP_FIBOLEVELS) и значения уровней (свойство OBJPROP_FIRSTLEVEL+n) используется функция <a href="help://objects_ObjectSet">ObjectSet()</a></td></tr>
        <tr><td>OBJ_EXPANSION</td><td>14</td><td>Расширение Фибоначчи. Использует 3 координаты. Для установки количества уровней (свойство OBJPROP_FIBOLEVELS) и значения уровней (свойство OBJPROP_FIRSTLEVEL+n) используется функция <a href="help://objects_ObjectSet">ObjectSet()</a></td></tr>
        <tr><td>OBJ_FIBOCHANNEL</td><td>15</td><td>Канал Фибоначчи. Использует 3 координаты. Для установки количества уровней (свойство OBJPROP_FIBOLEVELS) и значения уровней (свойство OBJPROP_FIRSTLEVEL+n) используется функция <a href="help://objects_ObjectSet">ObjectSet()</a></td></tr>
        <tr><td>OBJ_RECTANGLE</td><td>16</td><td>Прямоугольник. Использует 2 координаты</td></tr>
        <tr><td>OBJ_TRIANGLE</td><td>17</td><td>Треугольник. Использует 3 координаты</td></tr>
        <tr><td>OBJ_ELLIPSE</td><td>18</td><td>Эллипс. Использует 2 координаты. Для установки соотношения между временной и ценовой шкалами (свойство OBJPROP_SCALE) используется функция <a href="help://objects_ObjectSet">ObjectSet()</a></td></tr>
        <tr><td>OBJ_PITCHFORK</td><td>19</td><td>Вилы Эндрюса. Использует 3 координаты</td></tr>
        <tr><td>OBJ_CYCLES</td><td>20</td><td>Временные ряды (циклические линии). Использует 2 координаты</td></tr>
        <tr><td>OBJ_TEXT</td><td>21</td><td>Текст. Использует 1 координату. Для установки угла выводимого текста (свойство OBJPROP_ANGLE) используется функция <a href="help://objects_ObjectSet">ObjectSet()</a>. Для изменения текста используется функция <a href="help://objects_ObjectSetText">ObjectSetText()</a></td></tr>
        <tr><td>OBJ_ARROW</td><td>22</td><td>Стрелки (символы). Использует 1 координату. Для установки кода символа (свойство OBJPROP_ARROWCODE) используется функция <a href="help://objects_ObjectSet">ObjectSet()</a></td></tr>
        <tr><td>OBJ_LABEL</td><td>23</td><td>Текстовая метка. Не использует координат. Для установки координат, задаваемых в пикселях относительно угла привязки (свойства OBJPROP_CORNER, OBJPROP_XDISTANCE, OBJPROP_YDISTANCE) используется функция <a href="help://objects_ObjectSet">ObjectSet()</a>. Для изменения текста используется функция <a href="help://objects_ObjectSetText">ObjectSetText()</a></td></tr>
        </table><br/>
      </content>
    </text>

    <text>
      tag=constants_objects_properties
      caption=Свойства объектов
      <keywords>
      ;OBJPROP_TIME1;OBJPROP_PRICE1;OBJPROP_TIME2;OBJPROP_PRICE2;OBJPROP_TIME3;OBJPROP_PRICE3;OBJPROP_COLOR;OBJPROP_DEVIATION;
      ;OBJPROP_STYLE;OBJPROP_WIDTH;OBJPROP_BACK;OBJPROP_RAY;OBJPROP_ELLIPSE;OBJPROP_SCALE;OBJPROP_ANGLE;OBJPROP_TIMEFRAMES;
      ;OBJPROP_ARROWCODE;OBJPROP_FONTSIZE;OBJPROP_CORNER;OBJPROP_XDISTANCE;OBJPROP_YDISTANCE;OBJPROP_FIBOLEVELS;OBJPROP_FIRSTLEVEL;
      ;OBJPROP_LEVELCOLOR;OBJPROP_LEVELSTYLE;OBJPROP_LEVELWIDTH;
      </keywords>
      <content>
        <p>Идентификаторы свойств объекта используются в функциях <a href="help://objects_ObjectGet">ObjectGet()</a> и 
        <a href="help://objects_ObjectSet">ObjectSet()</a>. Mогут быть любыми из следующих величин:</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums">
        <tr><th width="15%">Константа</th><th width="7%">Значение</th><th width="8%">Тип</th><th width="70%">Описание</th></tr>
        <tr><td>OBJPROP_TIME1</td><td>0</td><td>datetime</td><td>Получает/устанавливает первую координату времени</td></tr>
        <tr><td>OBJPROP_PRICE1</td><td>1</td><td>double</td><td>Получает/устанавливает первую координату цены</td></tr>
        <tr><td>OBJPROP_TIME2</td><td>2</td><td>datetime</td><td>Получает/устанавливает вторую координату времени</td></tr>
        <tr><td>OBJPROP_PRICE2</td><td>3</td><td>double</td><td>Получает/устанавливает вторую координату цены</td></tr>
        <tr><td>OBJPROP_TIME3</td><td>4</td><td>datetime</td><td>Получает/устанавливает третью координату времени</td></tr>
        <tr><td>OBJPROP_PRICE3</td><td>5</td><td>double</td><td>Получает/устанавливает третью координату цены</td></tr>
        <tr><td>OBJPROP_COLOR</td><td>6</td><td>color</td><td>Получает/устанавливает <a href="help://constants_colors">цвет</a> объекта</td></tr>
        <tr><td>OBJPROP_STYLE</td><td>7</td><td>int</td><td>Получает/устанавливает <a href="help://constants_drawstyles">стиль линии</a> объекта</td></tr>
        <tr><td>OBJPROP_WIDTH</td><td>8</td><td>int</td><td>Получает/устанавливает ширину линии объекта</td></tr>
        <tr><td>OBJPROP_BACK</td><td>9</td><td>bool</td><td>Получает/устанавливает флаг фонового отображения объекта</td></tr>
        <tr><td>OBJPROP_RAY</td><td>10</td><td>bool</td><td>Получает/устанавливает флаг свойства луч для объектов типа OBJ_TREND и ему подобных</td></tr>
        <tr><td>OBJPROP_ELLIPSE</td><td>11</td><td>bool</td><td>Получает/устанавливает флаг отображения полного эллипса для объекта OBJ_FIBOARC</td></tr>
        <tr><td>OBJPROP_SCALE</td><td>12</td><td>double</td><td>Получает/устанавливает значение масштаба объекта</td></tr>
        <tr><td>OBJPROP_ANGLE</td><td>13</td><td>double</td><td>Получает/устанавливает значение угла в градусах объекта OBJ_TRENDBYANGLE</td></tr>
        <tr><td>OBJPROP_ARROWCODE</td><td>14</td><td>int</td><td>Получает/устанавливает код стрелки объекта OBJ_ARROW. Может быть одним из символов <a href="help://constants_wingdings">wingdings</a> или один из предопределенных <a href="help://constants_arrows">кодов стрелок</a></td></tr>
        <tr><td>OBJPROP_TIMEFRAMES</td><td>15</td><td>int</td><td>Получает/устанавливает свойство отображения объекта на различных периодах. Может быть одним или комбинацией нескольких из <a href="help://constants_objects_visible">констант видимости объекта</a>.</td></tr>
        <tr><td>OBJPROP_DEVIATION</td><td>16</td><td>double</td><td>Получает/устанавливает размер отклонения для объекта OBJ_STDDEVCHANNEL</td></tr>
        <tr><td>OBJPROP_FONTSIZE</td><td>100</td><td>int</td><td>Получает/устанавливает размер шрифта для объектов OBJ_TEXT и OBJ_LABEL</td></tr>
        <tr><td>OBJPROP_CORNER</td><td>101</td><td>int</td><td>Получает/устанавливает номер угла привязки для объекта OBJ_LABEL. Принимает значения 0-3</td></tr>
        <tr><td>OBJPROP_XDISTANCE</td><td>102</td><td>int</td><td>Получает/устанавливает расстояние X-координаты в пикселях относительно угла привязки для объекта OBJ_LABEL</td></tr>
        <tr><td>OBJPROP_YDISTANCE</td><td>103</td><td>int</td><td>Получает/устанавливает расстояние Y-координаты в пикселях относительно угла привязки для объекта OBJ_LABEL</td></tr>
        <tr><td>OBJPROP_FIBOLEVELS</td><td>200</td><td>int</td><td>Получает/устанавливает число уровней объекта Fibonacci. Может быть от 1 до 32</td></tr>
        <tr><td>OBJPROP_LEVELCOLOR</td><td>201</td><td>color</td><td>Получает/устанавливает <a href="help://constants_colors">цвет</a> линии уровня объекта</td></tr>
        <tr><td>OBJPROP_LEVELSTYLE</td><td>202</td><td>int</td><td>Получает/устанавливает стиль линии уровня объекта</td></tr>
        <tr><td>OBJPROP_LEVELWIDTH</td><td>203</td><td>int</td><td>Получает/устанавливает ширину линии уровня объекта</td></tr>
        <tr><td>OBJPROP_FIRSTLEVEL+<i>n</i></td><td>210+n</td><td>int</td><td>Получает/устанавливает значения уровня объекта Fibonacci с индексом <i>n</i>. Индекс <i>n</i> может быть от 0 до (количество уровней -1), но не более 31</td></tr>
        </table><br/>
      </content>
    </text>


    <text>
      tag=constants_objects_visible
      caption=Видимость объектов
      <keywords>
      ;OBJ_PERIOD_M1;OBJ_PERIOD_M5;OBJ_PERIOD_M15;OBJ_PERIOD_M30;OBJ_PERIOD_H1;OBJ_PERIOD_H4;
      ;OBJ_PERIOD_D1;OBJ_PERIOD_W1;OBJ_PERIOD_MN1;OBJ_ALL_PERIODS;
      </keywords>
      <content>
        <p>Сочетание флагов видимости объекта определяет периоды графика, на которых объект отображаем. 
        Для установки/получения значения свойства OBJPROP_TIMEFRAMES можно использовать функции 
        <a href="help://objects_ObjectSet">ObjectSet()</a>/<a href="help://objects_ObjectGet">ObjectGet()</a>.</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums">
        <tr><th width="15%">Константа</th><th width="10%">Значение</th><th width="75%">Описание</th></tr>
        <tr><td>OBJ_PERIOD_M1</td><td>0x0001</td><td>Объект рисуется только на 1-минутных графиках. </td></tr>
        <tr><td>OBJ_PERIOD_M5</td><td>0x0002</td><td>Объект рисуется только на 5-минутных графиках</td></tr>
        <tr><td>OBJ_PERIOD_M15</td><td>0x0004</td><td>Объект рисуется только на 15-минутных графиках</td></tr>
        <tr><td>OBJ_PERIOD_M30</td><td>0x0008</td><td>Объект рисуется только на 30-минутных графиках</td></tr>
        <tr><td>OBJ_PERIOD_H1</td><td>0x0010</td><td>Объект рисуется только на 1-часовых графиках</td></tr>
        <tr><td>OBJ_PERIOD_H4</td><td>0x0020</td><td>Объект рисуется только на 4-часовых графиках</td></tr>
        <tr><td>OBJ_PERIOD_D1</td><td>0x0040</td><td>Объект рисуется только на дневных графиках</td></tr>
        <tr><td>OBJ_PERIOD_W1</td><td>0x0080</td><td>Объект рисуется только на недельных графиках</td></tr>
        <tr><td>OBJ_PERIOD_MN1</td><td>0x0100</td><td>Объект рисуется только на месячных графиках</td></tr>
        <tr><td>OBJ_ALL_PERIODS</td><td>0x01FF</td><td>Объект рисуется на всех таймфреймах</td></tr>
        <tr><td>NULL</td><td>0</td><td>Объект рисуется на всех таймфреймах</td></tr>
        <tr><td>EMPTY</td><td>-1</td><td>Объект скрыт на всех таймфреймах</td></tr>
        </table><br/>
      </content>
    </text>

    <text>
      tag=constants_uninit
      caption=Причины деинициализации
      keywords=;REASON_REMOVE;REASON_RECOMPILE;REASON_CHARTCHANGE;REASON_CHARTCLOSE;REASON_PARAMETERS;REASON_ACCOUNT;
      <content>
        <p>Коды причины деинициализации, возвращаемые функцией <a href="help://check_UninitializeReason">UninitializeReason()</a>. 
        Mогут иметь любые из следующих значений:</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums">
        <tr><th width="15%">Константа</th><th width="10%">Значение</th><th width="75%">Описание</th></tr>
        <tr><td>&nbsp;</td><td>0</td><td>Скрипт самостоятельно завершил свою работу</td></tr>
        <tr><td>REASON_REMOVE</td><td>1</td><td>Программа удалена с графика</td></tr>
        <tr><td>REASON_RECOMPILE</td><td>2</td><td>Программа перекомпилирована</td></tr>
        <tr><td>REASON_CHARTCHANGE</td><td>3</td><td>Символ или период графика был изменен</td></tr>
        <tr><td>REASON_CHARTCLOSE</td><td>4</td><td>График закрыт</td></tr>
        <tr><td>REASON_PARAMETERS</td><td>5</td><td>Входные параметры были изменены пользователем</td></tr>
        <tr><td>REASON_ACCOUNT</td><td>6</td><td>Активирован другой счет</td></tr>
        </table>
      </content>
    </text>

    <text>
      tag=constants_special
      caption=Специальные константы
      keywords=;NULL;EMPTY_VALUE;CLR_NONE;EMPTY;WHOLE_ARRAY;
      <content>
        <p>Специальные константы, используемые для указания состояния параметров и переменных.
        Mогут быть следующими величинами:</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums">
        <tr><th width="15%">Константа</th><th width="10%">Значение</th><th width="75%">Описание</th></tr>
        <tr><td>NULL</td><td>0</td><td>Указывает пустое состояние строки</td></tr>
        <tr><td>EMPTY</td><td>-1</td><td>Указывает пустое состояние параметра</td></tr>
        <tr><td>EMPTY_VALUE</td><td>0x7FFFFFFF</td><td>Значение по умолчанию, указатель пустого значения. Используется в <a href="help://customind_SetIndexEmptyValue">пользовательских индикаторах</a></td></tr>
        <tr><td>CLR_NONE</td><td>0xFFFFFFFF</td><td>Указывает отсутствие цвета</td></tr>
        <tr><td>WHOLE_ARRAY</td><td>0</td><td>Используется с <a href="help://array">функциями массивов</a>. Указывает, что все элементы массива должны быть обработаны</td></tr>
        </table>
      </content>
    </text>

    <text>
      tag=constants_errors
      caption=Коды ошибок
      <keywords>
      ;ERR_NO_ERROR;ERR_NO_RESULT;ERR_COMMON_ERROR;ERR_INVALID_TRADE_PARAMETERS;ERR_SERVER_BUSY;
      ;ERR_OLD_VERSION;ERR_NO_CONNECTION;ERR_NOT_ENOUGH_RIGHTS;ERR_TOO_FREQUENT_REQUESTS;ERR_MALFUNCTIONAL_TRADE;
      ;ERR_ACCOUNT_DISABLED;ERR_INVALID_ACCOUNT;ERR_TRADE_TIMEOUT;ERR_INVALID_PRICE;ERR_INVALID_STOPS;
      ;ERR_INVALID_TRADE_VOLUME;ERR_MARKET_CLOSED;ERR_TRADE_DISABLED;ERR_NOT_ENOUGH_MONEY;ERR_PRICE_CHANGED;
      ;ERR_OFF_QUOTES;ERR_BROKER_BUSY;ERR_REQUOTE;ERR_ORDER_LOCKED;ERR_LONG_POSITIONS_ONLY_ALLOWED;
      ;ERR_TOO_MANY_REQUESTS;ERR_TRADE_MODIFY_DENIED;ERR_TRADE_CONTEXT_BUSY;ERR_TRADE_EXPIRATION_DENIED;ERR_TRADE_TOO_MANY_ORDERS;
      ;ERR_NO_MQLERROR;ERR_WRONG_FUNCTION_POINTER;ERR_ARRAY_INDEX_OUT_OF_RANGE;
      ;ERR_NO_MEMORY_FOR_CALL_STACK;ERR_RECURSIVE_STACK_OVERFLOW;ERR_NOT_ENOUGH_STACK_FOR_PARAM;
      ;ERR_NO_MEMORY_FOR_PARAM_STRING;ERR_NO_MEMORY_FOR_TEMP_STRING;ERR_NOT_INITIALIZED_STRING;
      ;ERR_NOT_INITIALIZED_ARRAYSTRING;ERR_NO_MEMORY_FOR_ARRAYSTRING;ERR_TOO_LONG_STRING;ERR_REMAINDER_FROM_ZERO_DIVIDE;
      ;ERR_ZERO_DIVIDE;ERR_UNKNOWN_COMMAND;ERR_WRONG_JUMP;ERR_NOT_INITIALIZED_ARRAY;ERR_DLL_CALLS_NOT_ALLOWED;
      ;ERR_CANNOT_LOAD_LIBRARY;ERR_CANNOT_CALL_FUNCTION;ERR_EXTERNAL_CALLS_NOT_ALLOWED;
      ;ERR_NO_MEMORY_FOR_RETURNED_STR;ERR_SYSTEM_BUSY;ERR_INVALID_FUNCTION_PARAMSCNT;
      ;ERR_INVALID_FUNCTION_PARAMVALUE;ERR_STRING_FUNCTION_INTERNAL;ERR_SOME_ARRAY_ERROR;
      ;ERR_INCORRECT_SERIESARRAY_USING;ERR_CUSTOM_INDICATOR_ERROR;ERR_INCOMPATIBLE_ARRAYS;
      ;ERR_GLOBAL_VARIABLES_PROCESSING;ERR_GLOBAL_VARIABLE_NOT_FOUND;ERR_FUNC_NOT_ALLOWED_IN_TESTING;
      ;ERR_FUNCTION_NOT_CONFIRMED;ERR_SEND_MAIL_ERROR;ERR_STRING_PARAMETER_EXPECTED;ERR_INTEGER_PARAMETER_EXPECTED;
      ;ERR_DOUBLE_PARAMETER_EXPECTED;ERR_ARRAY_AS_PARAMETER_EXPECTED;ERR_END_OF_FILE;ERR_SOME_FILE_ERROR;
      ;ERR_WRONG_FILE_NAME;ERR_TOO_MANY_OPENED_FILES;ERR_CANNOT_OPEN_FILE;ERR_INCOMPATIBLE_FILEACCESS;
      ;ERR_NO_ORDER_SELECTED;ERR_UNKNOWN_SYMBOL;ERR_INVALID_PRICE_PARAM;ERR_INVALID_TICKET;ERR_TRADE_NOT_ALLOWED;
      ;ERR_LONGS_NOT_ALLOWED;ERR_SHORTS_NOT_ALLOWED;ERR_OBJECT_ALREADY_EXISTS;ERR_UNKNOWN_OBJECT_PROPERTY;
      ;ERR_OBJECT_DOES_NOT_EXIST;ERR_UNKNOWN_OBJECT_TYPE;ERR_NO_OBJECT_NAME;ERR_OBJECT_COORDINATES_ERROR;
      ;ERR_NO_SPECIFIED_SUBWINDOW;ERR_TRADE_MODIFY_DENIED;ERR_TRADE_CONTEXT_BUSY;ERR_TRADE_EXPIRATION_DENIED;
      ;ERR_SOME_OBJECT_ERROR,ERR_TRADE_ERROR,
      </keywords>
      <content>
        <p><a href="help://check_GetLastError">GetLastError()</a> - функция, возвращающая коды ошибок.
        Кодовые константы ошибок определены в файле <em>stderror.mqh</em>. Для вывода текстовых сообщений следует 
        использовать функцию <em>ErrorDescription()</em>, определенную в файле <em>stdlib.mqh</em>.</p>
        <p class="doctabhdr">Пример:</p>
        <pre class="docmql4">
#include &lt;stderror.mqh&gt;
#include &lt;stdlib.mqh&gt;

void SendMyMessage(string text)
  {
   int check;
   SendMail(&quot;Test&quot;, text);
   check=GetLastError();
   if(check!=ERR_NO_ERROR) Print(&quot;Сообщение не отправлено. Ошибка: &quot;,ErrorDescription(check));
  }</pre><br/>

        <p>Коды ошибок, возвращаемые торговым сервером:</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums">
        <tr><th width="15%">Константа</th><th width="10%">Значение</th><th width="75%">Описание</th></tr>
        <tr><td>ERR_NO_ERROR</td><td>0</td><td>Нет ошибки</td></tr>
        <tr><td>ERR_NO_RESULT</td><td>1</td><td>Нет ошибки, но результат неизвестен</td></tr>
        <tr><td>ERR_COMMON_ERROR</td><td>2</td><td>Общая ошибка</td></tr>
        <tr><td>ERR_INVALID_TRADE_PARAMETERS</td><td>3</td><td>Неправильные параметры</td></tr>
        <tr><td>ERR_SERVER_BUSY</td><td>4</td><td>Торговый сервер занят</td></tr>
        <tr><td>ERR_OLD_VERSION</td><td>5</td><td>Старая версия клиентского терминала</td></tr>
        <tr><td>ERR_NO_CONNECTION</td><td>6</td><td>Нет связи с торговым сервером</td></tr>
        <tr><td>ERR_NOT_ENOUGH_RIGHTS</td><td>7</td><td>Недостаточно прав</td></tr>
        <tr><td>ERR_TOO_FREQUENT_REQUESTS</td><td>8</td><td>Слишком частые запросы</td></tr>
        <tr><td>ERR_MALFUNCTIONAL_TRADE</td><td>9</td><td>Недопустимая операция нарушающая функционирование сервера</td></tr>
        <tr><td>ERR_ACCOUNT_DISABLED</td><td>64</td><td>Счет заблокирован</td></tr>
        <tr><td>ERR_INVALID_ACCOUNT</td><td>65</td><td>Неправильный номер счета</td></tr>
        <tr><td>ERR_TRADE_TIMEOUT</td><td>128</td><td>Истек срок ожидания совершения сделки</td></tr>
        <tr><td>ERR_INVALID_PRICE</td><td>129</td><td>Неправильная цена</td></tr>
        <tr><td>ERR_INVALID_STOPS</td><td>130</td><td>Неправильные стопы</td></tr>
        <tr><td>ERR_INVALID_TRADE_VOLUME</td><td>131</td><td>Неправильный объем</td></tr>
        <tr><td>ERR_MARKET_CLOSED</td><td>132</td><td>Рынок закрыт</td></tr>
        <tr><td>ERR_TRADE_DISABLED</td><td>133</td><td>Торговля запрещена</td></tr>
        <tr><td>ERR_NOT_ENOUGH_MONEY</td><td>134</td><td>Недостаточно денег для совершения операции</td></tr>
        <tr><td>ERR_PRICE_CHANGED</td><td>135</td><td>Цена изменилась</td></tr>
        <tr><td>ERR_OFF_QUOTES</td><td>136</td><td>Нет цен</td></tr>
        <tr><td>ERR_BROKER_BUSY</td><td>137</td><td>Брокер занят</td></tr>
        <tr><td>ERR_REQUOTE</td><td>138</td><td>Новые цены</td></tr>
        <tr><td>ERR_ORDER_LOCKED</td><td>139</td><td>Ордер заблокирован и уже обрабатывается</td></tr>
        <tr><td>ERR_LONG_POSITIONS_ONLY_ALLOWED</td><td>140</td><td>Разрешена только покупка</td></tr>
        <tr><td>ERR_TOO_MANY_REQUESTS</td><td>141</td><td>Слишком много запросов</td></tr>
        <tr><td>ERR_TRADE_MODIFY_DENIED</td><td>145</td><td>Модификация запрещена, так как ордер слишком близок к рынку</td></tr>
        <tr><td>ERR_TRADE_CONTEXT_BUSY</td><td>146</td><td>Подсистема торговли занята</td></tr>
        <tr><td>ERR_TRADE_EXPIRATION_DENIED</td><td>147</td><td>Использование даты истечения ордера запрещено брокером</td></tr>
        <tr><td>ERR_TRADE_TOO_MANY_ORDERS</td><td>148</td><td>Количество открытых и отложенных ордеров достигло предела, установленного брокером.</td></tr>
        <tr><td>ERR_TRADE_HEDGE_PROHIBITED</td><td>149</td><td>Попытка открыть противоположную позицию к уже существующей в случае, если хеджирование запрещено.</td></tr>
        <tr><td>ERR_TRADE_PROHIBITED_BY_FIFO</td><td>150</td><td>Попытка закрыть позицию по инструменту в противоречии с правилом FIFO.</td></tr>
        </table><br/>
        
        <p>Коды ошибок выполнения MQL4-программы:</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums">
        <tr><th width="15%">Константа</th><th width="10%">Значение</th><th width="75%">Описание</th></tr>
        <tr><td>ERR_NO_MQLERROR</td><td>4000</td><td>Нет ошибки</td></tr>
        <tr><td>ERR_WRONG_FUNCTION_POINTER</td><td>4001</td><td>Неправильный указатель функции</td></tr>
        <tr><td>ERR_ARRAY_INDEX_OUT_OF_RANGE</td><td>4002</td><td>Индекс массива - вне диапазона</td></tr>
        <tr><td>ERR_NO_MEMORY_FOR_CALL_STACK</td><td>4003</td><td>Нет памяти для стека функций</td></tr>
        <tr><td>ERR_RECURSIVE_STACK_OVERFLOW</td><td>4004</td><td>Переполнение стека после рекурсивного вызова</td></tr>
        <tr><td>ERR_NOT_ENOUGH_STACK_FOR_PARAM</td><td>4005</td><td>На стеке нет памяти для передачи параметров</td></tr>
        <tr><td>ERR_NO_MEMORY_FOR_PARAM_STRING</td><td>4006</td><td>Нет памяти для строкового параметра</td></tr>
        <tr><td>ERR_NO_MEMORY_FOR_TEMP_STRING</td><td>4007</td><td>Нет памяти для временной строки</td></tr>
        <tr><td>ERR_NOT_INITIALIZED_STRING</td><td>4008</td><td>Неинициализированная строка</td></tr>
        <tr><td>ERR_NOT_INITIALIZED_ARRAYSTRING</td><td>4009</td><td>Неинициализированная строка в массиве</td></tr>
        <tr><td>ERR_NO_MEMORY_FOR_ARRAYSTRING</td><td>4010</td><td>Нет памяти для строкового массива</td></tr>
        <tr><td>ERR_TOO_LONG_STRING</td><td>4011</td><td>Слишком длинная строка</td></tr>
        <tr><td>ERR_REMAINDER_FROM_ZERO_DIVIDE</td><td>4012</td><td>Остаток от деления на ноль</td></tr>
        <tr><td>ERR_ZERO_DIVIDE</td><td>4013</td><td>Деление на ноль</td></tr>
        <tr><td>ERR_UNKNOWN_COMMAND</td><td>4014</td><td>Неизвестная команда</td></tr>
        <tr><td>ERR_WRONG_JUMP</td><td>4015</td><td>Неправильный переход</td></tr>
        <tr><td>ERR_NOT_INITIALIZED_ARRAY</td><td>4016</td><td>Неинициализированный массив</td></tr>
        <tr><td>ERR_DLL_CALLS_NOT_ALLOWED</td><td>4017</td><td>Вызовы DLL не разрешены</td></tr>
        <tr><td>ERR_CANNOT_LOAD_LIBRARY</td><td>4018</td><td>Невозможно загрузить библиотеку</td></tr>
        <tr><td>ERR_CANNOT_CALL_FUNCTION</td><td>4019</td><td>Невозможно вызвать функцию</td></tr>
        <tr><td>ERR_EXTERNAL_CALLS_NOT_ALLOWED</td><td>4020</td><td>Вызовы внешних библиотечных функций не разрешены</td></tr>
        <tr><td>ERR_NO_MEMORY_FOR_RETURNED_STR</td><td>4021</td><td>Недостаточно памяти для строки, возвращаемой из функции</td></tr>
        <tr><td>ERR_SYSTEM_BUSY</td><td>4022</td><td>Система занята</td></tr>
        <tr><td>ERR_INVALID_FUNCTION_PARAMSCNT</td><td>4050</td><td>Неправильное количество параметров функции</td></tr>
        <tr><td>ERR_INVALID_FUNCTION_PARAMVALUE</td><td>4051</td><td>Недопустимое значение параметра функции</td></tr>
        <tr><td>ERR_STRING_FUNCTION_INTERNAL</td><td>4052</td><td>Внутренняя ошибка строковой функции</td></tr>
        <tr><td>ERR_SOME_ARRAY_ERROR</td><td>4053</td><td>Ошибка массива</td></tr>
        <tr><td>ERR_INCORRECT_SERIESARRAY_USING</td><td>4054</td><td>Неправильное использование массива-таймсерии</td></tr>
        <tr><td>ERR_CUSTOM_INDICATOR_ERROR</td><td>4055</td><td>Ошибка пользовательского индикатора</td></tr>
        <tr><td>ERR_INCOMPATIBLE_ARRAYS</td><td>4056</td><td>Массивы несовместимы</td></tr>
        <tr><td>ERR_GLOBAL_VARIABLES_PROCESSING</td><td>4057</td><td>Ошибка обработки глобальныех переменных</td></tr>
        <tr><td>ERR_GLOBAL_VARIABLE_NOT_FOUND</td><td>4058</td><td>Глобальная переменная не обнаружена</td></tr>
        <tr><td>ERR_FUNC_NOT_ALLOWED_IN_TESTING</td><td>4059</td><td>Функция не разрешена в тестовом режиме</td></tr>
        <tr><td>ERR_FUNCTION_NOT_CONFIRMED</td><td>4060</td><td>Функция не разрешена</td></tr>
        <tr><td>ERR_SEND_MAIL_ERROR</td><td>4061</td><td>Ошибка отправки почты</td></tr>
        <tr><td>ERR_STRING_PARAMETER_EXPECTED</td><td>4062</td><td>Ожидается параметр типа string</td></tr>
        <tr><td>ERR_INTEGER_PARAMETER_EXPECTED</td><td>4063</td><td>Ожидается параметр типа integer</td></tr>
        <tr><td>ERR_DOUBLE_PARAMETER_EXPECTED</td><td>4064</td><td>Ожидается параметр типа double</td></tr>
        <tr><td>ERR_ARRAY_AS_PARAMETER_EXPECTED</td><td>4065</td><td>В качестве параметра ожидается массив</td></tr>
        <tr><td>ERR_HISTORY_WILL_UPDATED</td><td>4066</td><td>Запрошенные исторические данные в состоянии обновления</td></tr>
        <tr><td>ERR_TRADE_ERROR</td><td>4067</td><td>Ошибка при выполнении торговой операции</td></tr>
        <tr><td>ERR_END_OF_FILE</td><td>4099</td><td>Конец файла</td></tr>
        <tr><td>ERR_SOME_FILE_ERROR</td><td>4100</td><td>Ошибка при работе с файлом</td></tr>
        <tr><td>ERR_WRONG_FILE_NAME</td><td>4101</td><td>Неправильное имя файла</td></tr>
        <tr><td>ERR_TOO_MANY_OPENED_FILES</td><td>4102</td><td>Слишком много открытых файлов</td></tr>
        <tr><td>ERR_CANNOT_OPEN_FILE</td><td>4103</td><td>Невозможно открыть файл</td></tr>
        <tr><td>ERR_INCOMPATIBLE_FILEACCESS</td><td>4104</td><td>Несовместимый режим доступа к файлу</td></tr>
        <tr><td>ERR_NO_ORDER_SELECTED</td><td>4105</td><td>Ни один ордер не выбран</td></tr>
        <tr><td>ERR_UNKNOWN_SYMBOL</td><td>4106</td><td>Неизвестный символ</td></tr>
        <tr><td>ERR_INVALID_PRICE_PARAM</td><td>4107</td><td>Неправильный параметр цены для торговой функции</td></tr>
        <tr><td>ERR_INVALID_TICKET</td><td>4108</td><td>Неверный номер тикета</td></tr>
        <tr><td>ERR_TRADE_NOT_ALLOWED</td><td>4109</td><td>Торговля не разрешена. Необходимо включить опцию "Разрешить советнику торговать" в свойствах эксперта.</td></tr>
        <tr><td>ERR_LONGS_NOT_ALLOWED</td><td>4110</td><td>Длинные позиции не разрешены. Необходимо проверить свойства эксперта.</td></tr>
        <tr><td>ERR_SHORTS_NOT_ALLOWED</td><td>4111</td><td>Короткие позиции не разрешены. Необходимо проверить свойства эксперта.</td></tr>
        <tr><td>ERR_OBJECT_ALREADY_EXISTS</td><td>4200</td><td>Объект уже существует</td></tr>
        <tr><td>ERR_UNKNOWN_OBJECT_PROPERTY</td><td>4201</td><td>Запрошено неизвестное свойство объекта</td></tr>
        <tr><td>ERR_OBJECT_DOES_NOT_EXIST</td><td>4202</td><td>Объект не существует</td></tr>
        <tr><td>ERR_UNKNOWN_OBJECT_TYPE</td><td>4203</td><td>Неизвестный тип объекта</td></tr>
        <tr><td>ERR_NO_OBJECT_NAME</td><td>4204</td><td>Нет имени объекта</td></tr>
        <tr><td>ERR_OBJECT_COORDINATES_ERROR</td><td>4205</td><td>Ошибка координат объекта</td></tr>
        <tr><td>ERR_NO_SPECIFIED_SUBWINDOW</td><td>4206</td><td>Не найдено указанное подокно</td></tr>
        <tr><td>ERR_SOME_OBJECT_ERROR</td><td>4207</td><td>Ошибка при работе с объектом</td></tr>
        <tr><td>ERR_NOTIFICATION_SEND_ERROR</td><td>4250</td><td>Ошибка постановки уведомления в очередь на отсылку</td></tr>
        <tr><td>ERR_NOTIFICATION_WRONG_PARAMETER</td><td>4251</td><td>Неверный параметр - в функцию SendNotification() передали пустую строку</td></tr>
        <tr><td>ERR_NOTIFICATION_WRONG_SETTINGS</td><td>4252</td><td>Неверные настройки для отправки уведомлений (не указан ID или не выставлено разрешение</td></tr>
        <tr><td>ERR_NOTIFICATION_TOO_FREQUENT</td><td>4253</td><td>Слишком частая отправка уведомлений</td></tr>
        </table><br/>
      </content>
    </text>
  </group>
  
  
  <group>
    tag=runtime
    caption=Выполнение программ
    <content>
    Для того, чтобы MQL4-программа могла работать, она должна быть откомпилирована (кнопка "Компилировать" или клавиша F5). Компиляция должна пройти
    без ошибок (допускаются предупреждения, которые необходимо проанализировать). При этом в соответствующем директории, <em>terminal_dir\experts</em>,
    <em>terminal_dir\experts\indicators</em> или <em>terminal_dir\experts\scripts</em>, должен быть создан выполняемый файл с тем же именем и расширением
    EX4. Именно этот файл может быть запущен на выполнение.<br/><br/>
    Эксперты, пользовательские индикаторы и скрипты прикрепляются к одному из открытых графиков путем перетаскивания мышью из окна "Навигатор" клиентского
    терминала на соответствующий график (технология Drag'n'Drop). MQL4-программы могут работать только при включенном клиентском терминале.<br/><br/>
    Для того, чтобы эксперт прекратил работать, его необходимо удалить с графика при помощи выбора "Советники - Удалить" из контекстного меню графика. На
    работу советника также влияет состояние кнопки "Разрешить/запретить советников".<br/><br/>
    Для того, чтобы пользовательский индикатор прекратил работу, его необходимо удалить с графика.<br/><br/>
    Пользовательские индикаторы и советники работают до тех пор пока их явно не удалят с графика, информация о прикрепленных советниках и пользовательских
    индикаторах сохраняется между запусками клиентского терминала. Скрипты выполняются однократно и удаляются автоматически по завершению своей работы либо
    по закрытию или изменению состояния текущего графика, либо по завершению работы клиентского терминала. При повторном запуске клиентского терминала
    скрипты не запускаются, так как информация о них не сохраняется.<br/><br/>
    На одном графике могут работать максимум по одному эксперту и скрипту и неограниченное количество индикаторов.
    </content>
    <text>
      tag=runtime_start
      caption=Выполнение программ
      keywords=;init;deinit;start;
      <content>
        <p>
        Сразу же после присоединения к графику программа начинает работу с функции init(). Функция init() присоединенного к графику советника или пользовательского индикатора
        запускается также сразу после старта клиентского терминала и подгрузки (это касается только советников и не касается индикаторов) исторических данных, после смены
        финансового инструмента и/или периода графика, после перекомпиляции программы в редакторе MetaEditor, после смены входных параметров из окна настройки эксперта или
        пользовательского индикатора. Советник также инициализируется после смены счёта<br/><br/>
        
        Каждая присоединенная к графику программа завершает работу функцией deinit(). Функция deinit() запускается также при завершении работы
        клиентского терминала, при закрытии графика, непосредственно перед сменой финансового инструмента и/или периода графика, при удачной перекомпиляции программы,
        при смене входных параметров, а также при смене счета. Причину деинициализации можно получить, используя функцию <a href="help://check_UninitializeReason">UninitializeReason()</a>
        при выполнении функции deinit(). Выполнение функции deinit() ограничивается 2.5 секундами. Если за это время функция не закончила свою работу, то ее выполнение
        завершается принудительно. Исключение составляют скрипты, которые как правило, самостоятельно завершают свою работу без команды извне. Если же скрипт работает долго
        (например, по причине бесконечного цикла), то его можно завершить командой извне (при удалении скрипта из контекстного меню графика, при присоединении
        к графику нового скрипта, при закрытии графика, при смене финансового инструмента и/или периода графика). В этом случае deinit() также ограничивается 2.5 секундами.<br/><br/>
        
        При поступлении новых котировок выполняется функция start() у присоединенных советников и пользовательских индикаторов. Если при
        поступлении новой котировки выполнялась функция start(), запущенная на предыдущей котировке, то пришедшая котировка будет проигнорирована советником.
        Все пришедшие во время выполнения программы новые котировки программой игнорируются до тех пор, пока не завершится очередное выполнение функции start().
        После этого функция start() будет запущена только после прихода очередной новой котировки. У пользовательских индикаторов функция start() запускается для пересчета также после
        смены символа или периода текущего графика вне зависимости от поступления новых котировок. Функция start() не запускается при включенном запрете
        использования советников (кнопка "Разрешить/запретить советников"). Однако запрещение работы советников путем нажатия на указанную кнопку не прерывает
        текущее выполнение функции start(). Функция start() не запускается на выполнение при открытом окне свойств советника. Окно свойств не может быть открыто в момент выполнения
        советника.<br/><br/>
        
        Отсоединение программы от графика, смена финансового инструмента и/или периода графика, смена счета, закрытие графика, а также завершение работы
        клиентского терминала прерывает выполнение программы. Если функция start() выполнялась на момент команды на завершение работы, оставшееся время работы
        ограничивается 2.5 секундами. Программа может узнать, что её пытаются завершить при помощи встроенной функции <a href="help://check_IsStopped">IsStopped()</a>
        и корректно закончить свою работу.<br/><br/>
        
        Выполнение скриптов не зависит от приходящих котировок. При смене финансового инструмента и/или периода графика скрипт завершает свою работу и выгружается
        из клиентского терминала.<br/>
        Скрипты и эксперты работают в собственном потоке. Пользовательские индикаторы работают в интерфейсном потоке. Если же пользовательский индикатор вызван
        при помощи функции <a href="help://indicators_iCustom">iCustom()</a>, то этот индикатор работает в потоке вызвавшей его программы. Библиотечные (импортируемые) функции также
        работают в потоке вызывающей программы.
        </p>
      </content>
    </text>
    <text>
      tag=runtime_imports
      caption=Вызов импортируемых функций
      keywords=;init;deinit;start;
      <content>
        <p>
        Для <a href="help://basis_preprosessor_import">импорта функций</a> во время выполнения mql4-программы используется так называемое позднее связывание. 
        Это значит, что пока не вызвана импортируемая функция, соответствующий модуль (ex4 или dll) не загружается.
        Библиотеки MQL4 и DLL выполняются в потоке вызывающего модуля.<br/><br/>

        Не рекомендуется использовать полностью квалифицированное имя загружаемого модуля вида 
        <em>Drive:\Directory\FileName.Ext</em>. Библиотеки MQL4 загружаются из папки <em>terminal_dir\experts\libraries</em>.
        Если библиотека не была найдена, то производится попытка загрузить библиотеку из папки <em>terminal_dir\experts</em>.<br/><br/>

        Системные библиотеки (DLL) загружаются по правилам операционной системы. Если библиотека уже загружена
        (например, другим экспертом и даже из другого клиентского терминала, запущенного параллельно), то обращение идет к уже 
        загруженной библиотеке. В противном случае поиск идет в следующей последовательности:<br/>
        1. Директория <em>terminal_dir\experts\libraries</em>.<br/>
        2. Директория, из которой запущен клиентский терминал <em>terminal_dir</em>.<br/>
        3. Текущая директория.<br/>
        4. Системная директория <em>windows_dir\SYSTEM32</em> ( или <em>windows_dir\SYSTEM</em> для Win98).<br/>
        5. Директория, в которую установлена операционная система  <em>windows_dir</em>.<br/>
        6. Директории, перечисленные в системной переменной окружения PATH.<br/><br/>

        Если библиотека DLL использует в своей работе другую DLL, то в случае отсутствия второй DLL первая не сможет загрузиться.<br/><br/>

        В отличие от системных библиотек пользовательские библиотеки (MQL4) загружаются для каждого вызывающего модуля отдельно, независимо от того,
        была ли загружена вызываемая библиотека каким-либо другим модулем. Например, модуль caller.ex4 вызывает функции из библиотеки lib1.ex4 и
        lib2.ex4. В свою очередь, библиотека lib1.ex4 вызывает функции из библиотеки lib2.ex4. В этом случае будет загружена одна копия библиотеки lib1.ex4
        и две копии библиотеки lib2.ex4, несмотря на то, что все вызовы исходят из модуля caller.ex4.<br/><br/>

        Функции, импортируемые из DLL в mql4-программу, должны обеспечивать соглашение о связях, принятое для функций Windows API.
        Для обеспечения такого соглашения в исходном тексте программ, написанных на языках C или C++ используется ключевое слово __stdcall,
        которое является специфическим для компиляторов от фирмы Microsoft(r). Обсуждаемое соглашение о связях характеризуется следующим:<br/>
         - вызывающая функция (в нашем случае mql4-программа) должна "видеть" прототип вызываемой (импортируемой из DLL) функции, для того чтобы правильно сложить параметры на стек;<br/>
         - вызывающая функция (в нашем случае mql4-программа) складывает параметры на стек в обратном порядке, справа налево - именно в таком порядке импортируемая функция считывает переданные ей параметры;<br/>
         - параметры передаются по значению, за исключением тех, которые явно передаются по ссылке (в нашем случае строк)<br/>
         - импортируемая функция, считывая переданные ей параметры, сама очищает стек.<br/><br/>

         При описании прототипа импортируемой <a href="help://basis_functions">функции</a> использовать параметры со значениями по умолчанию бесполезно, т.к.
         все параметры в импортируемую функцию следует передавать явно.<br/><br/>

         В случае если вызов импортируемой функции оказался неудачным (в настройках эксперта запрещено использовать импортируемые функции либо соответствующая
         библиотека не смогла загрузиться), эксперт останавливает свою работу с соответствующим сообщением "expert stopped" в журнале. При этом эксперт
         не будет запускаться, пока не будет заново проинициализирован. Эксперт может быть переинициализирован в результате перекомпиляции либо после
         открытия таблицы свойств эксперта и нажатия кнопки OK.
        </p>
      </content>
    </text>
    <text>
      tag=runtime_errors
      caption=Ошибки выполнения
      <keywords>
      ;ERR_NO_ERROR;ERR_NO_RESULT;ERR_COMMON_ERROR;ERR_INVALID_TRADE_PARAMETERS;ERR_SERVER_BUSY;
      ;ERR_OLD_VERSION;ERR_NO_CONNECTION;ERR_NOT_ENOUGH_RIGHTS;ERR_TOO_FREQUENT_REQUESTS;ERR_MALFUNCTIONAL_TRADE;
      ;ERR_ACCOUNT_DISABLED;ERR_INVALID_ACCOUNT;ERR_TRADE_TIMEOUT;ERR_INVALID_PRICE;ERR_INVALID_STOPS;
      ;ERR_INVALID_TRADE_VOLUME;ERR_MARKET_CLOSED;ERR_TRADE_DISABLED;ERR_NOT_ENOUGH_MONEY;ERR_PRICE_CHANGED;
      ;ERR_OFF_QUOTES;ERR_BROKER_BUSY;ERR_REQUOTE;ERR_ORDER_LOCKED;ERR_LONG_POSITIONS_ONLY_ALLOWED;
      ;ERR_TOO_MANY_REQUESTS;ERR_TRADE_MODIFY_DENIED;ERR_TRADE_CONTEXT_BUSY;ERR_TRADE_EXPIRATION_DENIED;ERR_TRADE_TOO_MANY_ORDERS;
      ;ERR_NO_MQLERROR;ERR_WRONG_FUNCTION_POINTER;ERR_ARRAY_INDEX_OUT_OF_RANGE;
      ;ERR_NO_MEMORY_FOR_CALL_STACK;ERR_RECURSIVE_STACK_OVERFLOW;ERR_NOT_ENOUGH_STACK_FOR_PARAM;
      ;ERR_NO_MEMORY_FOR_PARAM_STRING;ERR_NO_MEMORY_FOR_TEMP_STRING;ERR_NOT_INITIALIZED_STRING;
      ;ERR_NOT_INITIALIZED_ARRAYSTRING;ERR_NO_MEMORY_FOR_ARRAYSTRING;ERR_TOO_LONG_STRING;ERR_REMAINDER_FROM_ZERO_DIVIDE;
      ;ERR_ZERO_DIVIDE;ERR_UNKNOWN_COMMAND;ERR_WRONG_JUMP;ERR_NOT_INITIALIZED_ARRAY;ERR_DLL_CALLS_NOT_ALLOWED;
      ;ERR_CANNOT_LOAD_LIBRARY;ERR_CANNOT_CALL_FUNCTION;ERR_EXTERNAL_CALLS_NOT_ALLOWED;
      ;ERR_NO_MEMORY_FOR_RETURNED_STR;ERR_SYSTEM_BUSY;ERR_INVALID_FUNCTION_PARAMSCNT;
      ;ERR_INVALID_FUNCTION_PARAMVALUE;ERR_STRING_FUNCTION_INTERNAL;ERR_SOME_ARRAY_ERROR;
      ;ERR_INCORRECT_SERIESARRAY_USING;ERR_CUSTOM_INDICATOR_ERROR;ERR_INCOMPATIBLE_ARRAYS;
      ;ERR_GLOBAL_VARIABLES_PROCESSING;ERR_GLOBAL_VARIABLE_NOT_FOUND;ERR_FUNC_NOT_ALLOWED_IN_TESTING;
      ;ERR_FUNCTION_NOT_CONFIRMED;ERR_SEND_MAIL_ERROR;ERR_STRING_PARAMETER_EXPECTED;ERR_INTEGER_PARAMETER_EXPECTED;
      ;ERR_DOUBLE_PARAMETER_EXPECTED;ERR_ARRAY_AS_PARAMETER_EXPECTED;ERR_END_OF_FILE;ERR_SOME_FILE_ERROR;
      ;ERR_WRONG_FILE_NAME;ERR_TOO_MANY_OPENED_FILES;ERR_CANNOT_OPEN_FILE;ERR_INCOMPATIBLE_FILEACCESS;
      ;ERR_NO_ORDER_SELECTED;ERR_UNKNOWN_SYMBOL;ERR_INVALID_PRICE_PARAM;ERR_INVALID_TICKET;ERR_TRADE_NOT_ALLOWED;
      ;ERR_LONGS_NOT_ALLOWED;ERR_SHORTS_NOT_ALLOWED;ERR_OBJECT_ALREADY_EXISTS;ERR_UNKNOWN_OBJECT_PROPERTY;
      ;ERR_OBJECT_DOES_NOT_EXIST;ERR_UNKNOWN_OBJECT_TYPE;ERR_NO_OBJECT_NAME;ERR_OBJECT_COORDINATES_ERROR;
      ;ERR_NO_SPECIFIED_SUBWINDOW;ERR_TRADE_MODIFY_DENIED;ERR_TRADE_CONTEXT_BUSY;ERR_TRADE_EXPIRATION_DENIED;
      ;ERR_SOME_OBJECT_ERROR,ERR_TRADE_ERROR,
      </keywords>
      <content>
        <p>
         В исполняющей подсистеме клиентского терминала существует возможность сохранения кода ошибки в случае ее возникновения
         при выполнении mql4-программы. Для каждой исполняемой mql4-программы предусмотрена своя собственная специальная
         переменная last_error. Перед запуском функции init переменная last_error обнуляется. При возникновении ошибочной
         ситуации во время вычислений или в процессе вызова встроенной функции переменная last_error принимает соответствующий
         <a href="help://constants_errors">код ошибки</a>. Значение, сохраненное в этой переменной, можно получить при помощи функции <a href="help://check_GetLastError">GetLastError()</a>.
         При этом переменная last_error обнуляется.
        </p>
        <p>
         Существует ряд критических ошибок, при возникновении которых выполнение программы немедленно прерывается:</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums">
        <tr><th width="15%">Константа</th><th width="10%">Значение</th><th width="75%">Описание</th></tr>
        <tr><td>ERR_WRONG_FUNCTION_POINTER</td><td>4001</td><td>При вызове внутренней функции обнаружен неправильный указатель вызываемой функции</td></tr>
        <tr><td>ERR_NO_MEMORY_FOR_CALL_STACK</td><td>4003</td><td>При вызове внутренней функции невозможно перераспределить память для стека вызовов функции</td></tr>
        <tr><td>ERR_RECURSIVE_STACK_OVERFLOW</td><td>4004</td><td>При рекурсивном вызове функции исчерпан стек данных</td></tr>
        <tr><td>ERR_NO_MEMORY_FOR_PARAM_STRING</td><td>4006</td><td>При вызове внутренней функции невозможно распределить память для передачи строки в качестве параметра функции</td></tr>
        <tr><td>ERR_NO_MEMORY_FOR_TEMP_STRING</td><td>4007</td><td>Невозможно распределить временный буфер для операций со строками</td></tr>
        <tr><td>ERR_NO_MEMORY_FOR_ARRAYSTRING</td><td>4010</td><td>При присвоении невозможно перераспределить память для строки в массиве</td></tr>
        <tr><td>ERR_TOO_LONG_STRING</td><td>4011</td><td>При присвоении слишком длинная результатная строка для помещения в служебный буфер (невозможно перераспределить память для служебного буфера)</td></tr>
        <tr><td>ERR_REMAINDER_FROM_ZERO_DIVIDE</td><td>4012</td><td>Деление на 0 при взятии остатка от деления</td></tr>
        <tr><td>ERR_ZERO_DIVIDE</td><td>4013</td><td>Деление на 0</td></tr>
        <tr><td>ERR_UNKNOWN_COMMAND</td><td>4014</td><td>Неизвестная инструкция</td></tr>
        </table>
        <p>
         Если работа программы была прервана из-за критической ошибки, то при следующем запуске функции start или функции deinit
         можно прочитать код этой ошибки, используя функцию <a href="help://check_GetLastError">GetLastError()</a>. Перед запуском функций start и deinit переменная
         last_error не сбрасывается.
        </p>
        <p><br/>
         Существует ряд критических ошибок, связанных с <a href="help://runtime_imports">вызовом импортируемых функций</a>, при возникновении которых выполнение
         эксперта или индикатора немедленно прерывается и функция start не запускается до тех пор, пока не будет произведена переинициализация эксперта
         или индикатора.</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums">
        <tr><th width="15%">Константа</th><th width="10%">Значение</th><th width="75%">Описание</th></tr>
        <tr><td>ERR_CANNOT_LOAD_LIBRARY</td><td>4018</td><td>При вызове импортируемой функции произошла ошибка загрузки dll или ex4-библиотеки</td></tr>
        <tr><td>ERR_CANNOT_CALL_FUNCTION</td><td>4019</td><td>При вызове импортируемой из функции выяснилось, что dll или ex4-библиотека не содержит эту функцию</td></tr>
        <tr><td>ERR_DLL_CALLS_NOT_ALLOWED</td><td>4017</td><td>При вызове импортируемой из dll функции выяснилось, что установлен запрет на вызовы из dll</td></tr>
        <tr><td>ERR_EXTERNAL_CALLS_NOT_ALLOWED</td><td>4020</td><td>При вызове импортируемой из ex4-библиотеки выяснилось, что установлен запрет на вызовы из ex4</td></tr>
        <tr><td>ERR_FUNCTION_NOT_CONFIRMED</td><td>4060</td><td>Не подтвержден вызов импортируемой из dll функции. Если нажата кнопка &quot;Нет&quot;, то выполнение программы не прерывается. Если нажата кнопка &quot;Отмена&quot;, то выполнение программы немедленно прерывается</td></tr>
        </table>
        <p><br/>
         Остальные ошибки не прерывают работу программы.</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums">
        <tr><th width="15%">Константа</th><th width="10%">Значение</th><th width="75%">Описание</th></tr>
        <tr><td>ERR_ARRAY_INDEX_OUT_OF_RANGE</td><td>4002</td><td>Обращение к элементу массива, номер которого находится за пределами массива</td></tr>
        <tr><td>ERR_NOT_INITIALIZED_STRING</td><td>4008</td><td>Неинициализированная строка; строке, участвующей в каком-либо выражении, не присвоено никакого значения</td></tr>
        <tr><td>ERR_NOT_INITIALIZED_ARRAYSTRING</td><td>4009</td><td>Неинициализированная строка в массиве строк; строке, участвующей в каком-либо выражении, не присвоено никакого значения</td></tr>
        <tr><td>ERR_NO_MEMORY_FOR_RETURNED_STR</td><td>4021</td><td>Невозможно перераспределить память для строки, возвращаемой из функции</td></tr>
        </table>
        <p><br/>
         Никогда не генерируется код ERR_NO_MQLERROR (4000).
        </p>
        <p>
         Существует ряд ошибок, которые возможны только в результате сбоя. При регулярном проявлении какой-либо из нижеперечисленных ошибок необходимо связаться с разработчиками.</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums">
        <tr><th width="15%">Константа</th><th width="10%">Значение</th><th width="75%">Описание</th></tr>
        <tr><td>ERR_WRONG_FUNCTION_POINTER</td><td>4001</td><td>При вызове внутренней функции обнаружен неправильный указатель вызываемой функции</td></tr>
        <tr><td>ERR_UNKNOWN_COMMAND</td><td>4014</td><td>Неизвестная инструкция</td></tr>
        <tr><td>ERR_NOT_INITIALIZED_ARRAY</td><td>4016</td><td>Неинициализированный массив</td></tr>
        <tr><td>ERR_INVALID_FUNCTION_PARAMSCNT</td><td>4050</td><td>Неверное количество параметров, передаваемых во встроенную функцию</td></tr>
        <tr><td>ERR_STRING_FUNCTION_INTERNAL</td><td>4052</td><td>Ошибка при работе со строками</td></tr>
        <tr><td>ERR_TRADE_ERROR</td><td>4067</td><td>Ошибка при выполнении торговой функции</td></tr>
        <tr><td>ERR_SOME_OBJECT_ERROR</td><td>4207</td><td>Ошибка при работе с объектами</td></tr>
        </table>
        <p><br/>
         Существует несколько встроенных функций, которые всегда меняют значение переменной last_error.</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums">
        <tr><th width="15%">Функция</th><th width="85%">Коды ошибок</th></tr>
        <tr><td><a href="help://account_AccountFreeMarginCheck">AccountFreeMarginCheck</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_INTEGER_PARAMETER_EXPECTED (4063), ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_UNKNOWN_SYMBOL (4106), ERR_NOT_ENOUGH_MONEY (134)</td></tr>
        <tr><td><a href="help://trading_OrderSend">OrderSend</a></td><td>ERR_CUSTOM_INDICATOR_ERROR (4055), ERR_STRING_PARAMETER_EXPECTED (4062), ERR_INTEGER_PARAMETER_EXPECTED (4063), ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_INVALID_PRICE_PARAM (4107), ERR_UNKNOWN_SYMBOL (4106), ERR_TRADE_NOT_ALLOWED (4109), ERR_LONGS_NOT_ALLOWED (4110), ERR_SHORTS_NOT_ALLOWED (4111), <a href="help://trading_errors">коды от торгового сервера</a></td></tr>
        <tr><td><a href="help://trading_OrderClose">OrderClose</a></td><td>ERR_CUSTOM_INDICATOR_ERROR (4055), ERR_INTEGER_PARAMETER_EXPECTED (4063), ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_INVALID_PRICE_PARAM (4107), ERR_INVALID_TICKET (4108), ERR_UNKNOWN_SYMBOL (4106), ERR_TRADE_NOT_ALLOWED (4109), <a href="help://trading_errors">коды от торгового сервера</a></td></tr>
        <tr><td><a href="help://trading_OrderCloseBy">OrderCloseBy</a></td><td>ERR_CUSTOM_INDICATOR_ERROR (4055), ERR_INTEGER_PARAMETER_EXPECTED (4063), ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_INVALID_TICKET (4108), ERR_UNKNOWN_SYMBOL (4106), ERR_TRADE_NOT_ALLOWED (4109), <a href="help://trading_errors">коды от торгового сервера</a></td></tr>
        <tr><td><a href="help://trading_OrderDelete">OrderDelete</a></td><td>ERR_CUSTOM_INDICATOR_ERROR (4055), ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_INVALID_TICKET (4108), ERR_UNKNOWN_SYMBOL (4106), ERR_TRADE_NOT_ALLOWED (4109), коды от <a href="help://trading_errors">торгового сервера</a></td></tr>
        <tr><td><a href="help://trading_OrderModify">OrderModify</a></td><td>ERR_CUSTOM_INDICATOR_ERROR (4055), ERR_INTEGER_PARAMETER_EXPECTED (4063), ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_INVALID_PRICE_PARAM (4107), ERR_INVALID_TICKET (4108), ERR_UNKNOWN_SYMBOL (4106), ERR_TRADE_NOT_ALLOWED (4109), <a href="help://trading_errors">коды от торгового сервера</a></td></tr>
        <tr><td><a href="help://check_GetLastError">GetLastError</a></td><td>ERR_NO_ERROR (0)</td></tr>
        </table>
        <p><br/>
         Некоторые функции меняют значение переменной last_error только в случае возникновения какой-либо ошибки.</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums">
        <tr><th width="15%">Функция</th><th width="85%">Коды ошибок</th></tr>
        <tr><td><a href="help://array_ArrayBsearch">ArrayBsearch</a></td><td>ERR_ARRAY_AS_PARAMETER_EXPECTED (4065), ERR_SOME_ARRAY_ERROR (4053), ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://array_ArrayCopy">ArrayCopy</a></td><td>ERR_ARRAY_AS_PARAMETER_EXPECTED (4065), ERR_SOME_ARRAY_ERROR (4053), ERR_INCOMPATIBLE_ARRAYS (4056), ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://array_ArrayCopyRates">ArrayCopyRates</a></td><td>ERR_ARRAY_AS_PARAMETER_EXPECTED (4065), ERR_SOME_ARRAY_ERROR (4053), ERR_INCOMPATIBLE_ARRAYS (4056), ERR_STRING_PARAMETER_EXPECTED (4062),</td></tr>
        <tr><td><a href="help://array_ArrayCopySeries">ArrayCopySeries</a></td><td>ERR_ARRAY_AS_PARAMETER_EXPECTED (4065), ERR_SOME_ARRAY_ERROR (4053), ERR_INCORRECT_SERIESARRAY_USING (4054), ERR_INCOMPATIBLE_ARRAYS (4056), ERR_STRING_PARAMETER_EXPECTED (4062), ERR_HISTORY_WILL_UPDATED (4066), ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://array_ArrayDimension">ArrayDimension</a></td><td>ERR_ARRAY_AS_PARAMETER_EXPECTED (4065), ERR_SOME_ARRAY_ERROR (4053)</td></tr>
        <tr><td><a href="help://array_ArrayGetAsSeries">ArrayGetAsSeries</a></td><td>ERR_ARRAY_AS_PARAMETER_EXPECTED (4065), ERR_SOME_ARRAY_ERROR (4053)</td></tr>
        <tr><td><a href="help://array_ArrayInitialize">ArrayInitialize</a></td><td>ERR_ARRAY_AS_PARAMETER_EXPECTED (4065), ERR_SOME_ARRAY_ERROR (4053), ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://array_ArrayIsSeries">ArrayIsSeries</a></td><td>ERR_ARRAY_AS_PARAMETER_EXPECTED (4065), ERR_SOME_ARRAY_ERROR (4053)</td></tr>
        <tr><td><a href="help://array_ArrayMaximum">ArrayMaximum</a></td><td>ERR_ARRAY_AS_PARAMETER_EXPECTED (4065), ERR_SOME_ARRAY_ERROR (4053), ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://array_ArrayMinimum">ArrayMinimum</a></td><td>ERR_ARRAY_AS_PARAMETER_EXPECTED (4065), ERR_SOME_ARRAY_ERROR (4053), ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://array_ArrayRange">ArrayRange</a></td><td>ERR_ARRAY_AS_PARAMETER_EXPECTED (4065), ERR_SOME_ARRAY_ERROR (4053), ERR_INTEGER_PARAMETER_EXPECTED (4063), ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://array_ArrayResize">ArrayResize</a></td><td>ERR_ARRAY_AS_PARAMETER_EXPECTED (4065), ERR_SOME_ARRAY_ERROR (4053), ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://array_ArraySetAsSeries">ArraySetAsSeries</a></td><td>ERR_ARRAY_AS_PARAMETER_EXPECTED (4065), ERR_SOME_ARRAY_ERROR (4053)</td></tr>
        <tr><td><a href="help://array_ArraySize">ArraySize</a></td><td>ERR_ARRAY_AS_PARAMETER_EXPECTED (4065), ERR_SOME_ARRAY_ERROR (4053)</td></tr>
        <tr><td><a href="help://array_ArraySort">ArraySort</a></td><td>ERR_ARRAY_AS_PARAMETER_EXPECTED (4065), ERR_SOME_ARRAY_ERROR (4053), ERR_INCORRECT_SERIESARRAY_USING (4054), ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://files_FileClose">FileClose</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://files_FileDelete">FileDelete</a></td><td>ERR_WRONG_FILE_NAME (4101), ERR_SOME_FILE_ERROR (4100)</td></tr>
        <tr><td><a href="help://files_FileFlush">FileFlush</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://files_FileIsEnding">FileIsEnding</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://files_FileIsLineEnding">FileIsLineEnding</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://files_FileOpen">FileOpen</a></td><td>ERR_TOO_MANY_OPENED_FILES (4102), ERR_WRONG_FILE_NAME (4101), ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_SOME_FILE_ERROR (4100), ERR_CANNOT_OPEN_FILE (4103)</td></tr>
        <tr><td><a href="help://files_FileOpenHistory">FileOpenHistory</a></td><td>ERR_TOO_MANY_OPENED_FILES (4102), ERR_WRONG_FILE_NAME (4101), ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_SOME_FILE_ERROR (4100), ERR_CANNOT_OPEN_FILE (4103)</td></tr>
        <tr><td><a href="help://files_FileReadArray">FileReadArray</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_INCOMPATIBLE_FILEACCESS (4104), ERR_SOME_ARRAY_ERROR (4053), ERR_SOME_FILE_ERROR (4100), ERR_END_OF_FILE (4099)</td></tr>
        <tr><td><a href="help://files_FileReadDouble">FileReadDouble</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_INCOMPATIBLE_FILEACCESS (4104), ERR_END_OF_FILE (4099)</td></tr>
        <tr><td><a href="help://files_FileReadInteger">FileReadInteger</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_INCOMPATIBLE_FILEACCESS (4104), ERR_END_OF_FILE (4099)</td></tr>
        <tr><td><a href="help://files_FileReadNumber">FileReadNumber</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_INCOMPATIBLE_FILEACCESS (4104), ERR_SOME_FILE_ERROR (4100), ERR_END_OF_FILE (4099)</td></tr>
        <tr><td><a href="help://files_FileReadString">FileReadString</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_INCOMPATIBLE_FILEACCESS (4104), ERR_SOME_FILE_ERROR (4100), ERR_TOO_LONG_STRING (4011), ERR_END_OF_FILE (4099)</td></tr>
        <tr><td><a href="help://files_FileSeek">FileSeek</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://files_FileSize">FileSize</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://files_FileTell">FileTell</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://files_FileWrite">FileWrite</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_SOME_FILE_ERROR (4100)</td></tr>
        <tr><td><a href="help://files_FileWriteDouble">FileWriteDouble</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_INCOMPATIBLE_FILEACCESS (4104), ERR_SOME_FILE_ERROR (4100)</td></tr>
        <tr><td><a href="help://files_FileWriteInteger">FileWriteInteger</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_INCOMPATIBLE_FILEACCESS (4104), ERR_SOME_FILE_ERROR (4100)</td></tr>
        <tr><td><a href="help://files_FileWriteString">FileWriteString</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_INCOMPATIBLE_FILEACCESS (4104), ERR_SOME_FILE_ERROR (4100), ERR_STRING_PARAMETER_EXPECTED (4062)</td></tr>
        <tr><td><a href="help://files_FileWriteArray">FileWriteArray</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_INCOMPATIBLE_FILEACCESS (4104), ERR_SOME_FILE_ERROR (4100),</td></tr>
        <tr><td><a href="help://globals_GlobalVariableCheck">GlobalVariableCheck</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062)</td></tr>
        <tr><td><a href="help://globals_GlobalVariableDel">GlobalVariableDel</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_GLOBAL_VARIABLES_PROCESSING (4057)</td></tr>
        <tr><td><a href="help://globals_GlobalVariableGet">GlobalVariableGet</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_GLOBAL_VARIABLE_NOT_FOUND (4058)</td></tr>
        <tr><td><a href="help://globals_GlobalVariablesDeleteAll">GlobalVariablesDeleteAll</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_GLOBAL_VARIABLES_PROCESSING (4057)</td></tr>
        <tr><td><a href="help://globals_GlobalVariableSet">GlobalVariableSet</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_GLOBAL_VARIABLES_PROCESSING (4057)</td></tr>
        <tr><td><a href="help://globals_GlobalVariableSetOnCondition">GlobalVariableSetOnCondition</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_GLOBAL_VARIABLE_NOT_FOUND (4058)</td></tr>
        <tr><td><a href="help://indicators_iCustom">iCustom</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://indicators">технические индикаторы</a>, <a href="help://series">функции доступа к таймсериям</a></td><td>ERR_HISTORY_WILL_UPDATED (4066)</td></tr>
        <tr><td><a href="help://indicators">технические индикаторы OnArray</a></td><td>ERR_ARRAY_AS_PARAMETER_EXPECTED (4065), ERR_SOME_ARRAY_ERROR (4053)</td></tr>
        <tr><td><a href="help://customind_IndicatorBuffers">IndicatorBuffers</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://customind_IndicatorDigits">IndicatorDigits</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://customind_IndicatorShortName">IndicatorShortName</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://common_MarketInfo">MarketInfo</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_FUNC_NOT_ALLOWED_IN_TESTING (4059), ERR_UNKNOWN_SYMBOL (4106), ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://math_MathArccos">MathArccos</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://math_MathArcsin">MathArcsin</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://math_MathMod">MathMod</a></td><td>ERR_ZERO_DIVIDE (4013)</td></tr>
        <tr><td><a href="help://math_MathSqrt">MathSqrt</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://common_MessageBox">MessageBox</a></td><td>ERR_FUNC_NOT_ALLOWED_IN_TESTING (4059), ERR_CUSTOM_INDICATOR_ERROR (4055), ERR_STRING_PARAMETER_EXPECTED (4062)</td></tr>
        <tr><td><a href="help://objects_ObjectCreate">ObjectCreate</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_NO_OBJECT_NAME (4204), ERR_UNKNOWN_OBJECT_TYPE (4203), ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_OBJECT_ALREADY_EXISTS (4200), ERR_NO_SPECIFIED_SUBWINDOW (4206)</td></tr>
        <tr><td><a href="help://objects_ObjectDelete">ObjectDelete</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_NO_OBJECT_NAME (4204), ERR_OBJECT_DOES_NOT_EXIST (4202)</td></tr>
        <tr><td><a href="help://objects_ObjectDescription">ObjectDescription</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_NO_OBJECT_NAME (4204), ERR_OBJECT_DOES_NOT_EXIST (4202)</td></tr>
        <tr><td><a href="help://objects_ObjectFind">ObjectFind</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_NO_OBJECT_NAME (4204)</td></tr>
        <tr><td><a href="help://objects_ObjectGet">ObjectGet</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_NO_OBJECT_NAME (4204), ERR_OBJECT_DOES_NOT_EXIST (4202), ERR_UNKNOWN_OBJECT_PROPERTY (4201)</td></tr>
        <tr><td><a href="help://objects_ObjectGetFiboDescription">ObjectGetFiboDescription</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_NO_OBJECT_NAME (4204), ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_OBJECT_DOES_NOT_EXIST (4202), ERR_UNKNOWN_OBJECT_TYPE (4203), ERR_UNKNOWN_OBJECT_PROPERTY (4201)</td></tr>
        <tr><td><a href="help://objects_ObjectGetShiftByValue">ObjectGetShiftByValue</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_NO_OBJECT_NAME (4204), ERR_OBJECT_DOES_NOT_EXIST (4202), ERR_OBJECT_COORDINATES_ERROR (4205)</td></tr>
        <tr><td><a href="help://objects_ObjectGetValueByShift">ObjectGetValueByShift</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_NO_OBJECT_NAME (4204), ERR_OBJECT_DOES_NOT_EXIST (4202), ERR_OBJECT_COORDINATES_ERROR (4205)</td></tr>
        <tr><td><a href="help://objects_ObjectMove">ObjectMove</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_NO_OBJECT_NAME (4204), ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_OBJECT_DOES_NOT_EXIST (4202)</td></tr>
        <tr><td><a href="help://objects_ObjectName">ObjectName</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_ARRAY_INDEX_OUT_OF_RANGE (4002)</td></tr>
        <tr><td><a href="help://objects_ObjectSet">ObjectSet</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_NO_OBJECT_NAME (4204), ERR_OBJECT_DOES_NOT_EXIST (4202), ERR_UNKNOWN_OBJECT_PROPERTY (4201)</td></tr>
        <tr><td><a href="help://objects_ObjectSetText">ObjectSetText</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_NO_OBJECT_NAME (4204), ERR_OBJECT_DOES_NOT_EXIST (4202)</td></tr>
        <tr><td><a href="help://objects_ObjectSetFiboDescription">ObjectSetFiboDescription</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_NO_OBJECT_NAME (4204), ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_STRING_PARAMETER_EXPECTED (4062), ERR_OBJECT_DOES_NOT_EXIST (4202), ERR_UNKNOWN_OBJECT_TYPE (4203), ERR_UNKNOWN_OBJECT_PROPERTY (4201)</td></tr>
        <tr><td><a href="help://objects_ObjectType">ObjectType</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_NO_OBJECT_NAME (4204), ERR_OBJECT_DOES_NOT_EXIST (4202)</td></tr>
        <tr><td><a href="help://trading_OrderClosePrice">OrderClosePrice</a></td><td>ERR_NO_ORDER_SELECTED (4105)</td></tr>
        <tr><td><a href="help://trading_OrderCloseTime">OrderCloseTime</a></td><td>ERR_NO_ORDER_SELECTED (4105)</td></tr>
        <tr><td><a href="help://trading_OrderComment">OrderComment</a></td><td>ERR_NO_ORDER_SELECTED (4105)</td></tr>
        <tr><td><a href="help://trading_OrderCommission">OrderCommission</a></td><td>ERR_NO_ORDER_SELECTED (4105)</td></tr>
        <tr><td><a href="help://trading_OrderExpiration">OrderExpiration</a></td><td>ERR_NO_ORDER_SELECTED (4105)</td></tr>
        <tr><td><a href="help://trading_OrderLots">OrderLots</a></td><td>ERR_NO_ORDER_SELECTED (4105)</td></tr>
        <tr><td><a href="help://trading_OrderMagicNumber">OrderMagicNumber</a></td><td>ERR_NO_ORDER_SELECTED (4105)</td></tr>
        <tr><td><a href="help://trading_OrderOpenPrice">OrderOpenPrice</a></td><td>ERR_NO_ORDER_SELECTED (4105)</td></tr>
        <tr><td><a href="help://trading_OrderOpenTime">OrderOpenTime</a></td><td>ERR_NO_ORDER_SELECTED (4105)</td></tr>
        <tr><td><a href="help://trading_OrderPrint">OrderPrint</a></td><td>ERR_NO_ORDER_SELECTED (4105)</td></tr>
        <tr><td><a href="help://trading_OrderProfit">OrderProfit</a></td><td>ERR_NO_ORDER_SELECTED (4105)</td></tr>
        <tr><td><a href="help://trading_OrderStopLoss">OrderStopLoss</a></td><td>ERR_NO_ORDER_SELECTED (4105)</td></tr>
        <tr><td><a href="help://trading_OrderSwap">OrderSwap</a></td><td>ERR_NO_ORDER_SELECTED (4105)</td></tr>
        <tr><td><a href="help://trading_OrderSymbol">OrderSymbol</a></td><td>ERR_NO_ORDER_SELECTED (4105)</td></tr>
        <tr><td><a href="help://trading_OrderTakeProfit">OrderTakeProfit</a></td><td>ERR_NO_ORDER_SELECTED (4105)</td></tr>
        <tr><td><a href="help://trading_OrderTicket">OrderTicket</a></td><td>ERR_NO_ORDER_SELECTED (4105)</td></tr>
        <tr><td><a href="help://trading_OrderType">OrderType</a></td><td>ERR_NO_ORDER_SELECTED (4105)</td></tr>
        <tr><td><a href="help://common_PlaySound">PlaySound</a></td><td>ERR_WRONG_FILE_NAME (4101)</td></tr>
        <tr><td><a href="help://common_SendFTP">SendFTP</a></td><td>ERR_FUNC_NOT_ALLOWED_IN_TESTING (4059), ERR_CUSTOM_INDICATOR_ERROR (4055), ERR_STRING_PARAMETER_EXPECTED (4062)</td></tr>
        <tr><td><a href="help://common_SendMail">SendMail</a></td><td>ERR_FUNC_NOT_ALLOWED_IN_TESTING (4059), ERR_STRING_PARAMETER_EXPECTED (4062), ERR_FUNCTION_NOT_CONFIRMED (4060), ERR_SEND_MAIL_ERROR (4061)</td></tr>
        <tr><td><a href="help://common_SendNotification">SendNotification</a></td><td>ERR_FUNC_NOT_ALLOWED_IN_TESTING (4059), ERR_STRING_PARAMETER_EXPECTED (4062), ERR_NOTIFICATION_SEND_ERROR (4250), ERR_NOTIFICATION_WRONG_PARAMETER (4251), ERR_NOTIFICATION_WRONG_SETTINGS (4252), ERR_NOTIFICATION_TOO_FREQUENT (4253)</td></tr>
        <tr><td><a href="help://customind_SetIndexArrow">SetIndexArrow</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://customind_SetIndexBuffer">SetIndexBuffer</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_INCORRECT_SERIESARRAY_USING (4054), ERR_INCOMPATIBLE_ARRAYS (4056)</td></tr>
        <tr><td><a href="help://customind_SetIndexDrawBegin">SetIndexDrawBegin</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://customind_SetIndexEmptyValue">SetIndexEmptyValue</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://customind_SetIndexLabel">SetIndexLabel</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_STRING_PARAMETER_EXPECTED (4062)</td></tr>
        <tr><td><a href="help://customind_SetIndexShift">SetIndexShift</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://customind_SetIndexStyle">SetIndexStyle</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://customind_SetLevelValue">SetLevelValue</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://common_Sleep">Sleep</a></td><td>ERR_CUSTOM_INDICATOR_ERROR (4055)</td></tr>
        <tr><td><a href="help://strings_StringFind">StringFind</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062)</td></tr>
        <tr><td><a href="help://strings_StringGetChar">StringGetChar</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_NOT_INITIALIZED_STRING (4008), ERR_ARRAY_INDEX_OUT_OF_RANGE (4002)</td></tr>
        <tr><td><a href="help://strings_StringLen">StringLen</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062)</td></tr>
        <tr><td><a href="help://strings_StringSetChar">StringSetChar</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_NOT_INITIALIZED_STRING (4008), ERR_TOO_LONG_STRING (4011), ERR_ARRAY_INDEX_OUT_OF_RANGE (4002)</td></tr>
        <tr><td><a href="help://strings_StringSubstr">StringSubstr</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_TOO_LONG_STRING (4011)</td></tr>
        <tr><td><a href="help://strings_StringTrimLeft">StringTrimLeft</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062)</td></tr>
        <tr><td><a href="help://strings_StringTrimRight">StringTrimRight</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062)</td></tr>
        <tr><td><a href="help://windows_WindowIsVisible">WindowIsVisible</a></td><td>ERR_FUNC_NOT_ALLOWED_IN_TESTING (4059)</td></tr>
        <tr><td><a href="help://windows_WindowFind">WindowFind</a></td><td>ERR_FUNC_NOT_ALLOWED_IN_TESTING (4059), ERR_STRING_PARAMETER_EXPECTED (4062), ERR_NOT_INITIALIZED_STRING (4008)</td></tr>
        <tr><td><a href="help://windows_WindowHandle">WindowHandle</a></td><td>ERR_FUNC_NOT_ALLOWED_IN_TESTING (4059), ERR_STRING_PARAMETER_EXPECTED (4062), ERR_NOT_INITIALIZED_STRING (4008)</td></tr>
        <tr><td><a href="help://windows_WindowScreenShot">WindowScreenShot</a></td><td>ERR_WRONG_FILE_NAME (4101), ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        </table>
        <p><br/>
         Остальные функции не меняют значение переменной last_error ни при каких условиях.<br/>
         <a href="help://account_AccountBalance">AccountBalance</a>,
         <a href="help://account_AccountCompany">AccountCompany</a>,
         <a href="help://account_AccountCredit">AccountCredit</a>,
         <a href="help://account_AccountCurrency">AccountCurrency</a>,
         <a href="help://account_AccountEquity">AccountEquity</a>,
         <a href="help://account_AccountFreeMargin">AccountFreeMargin</a>,
         <a href="help://account_AccountLeverage">AccountLeverage</a>,
         <a href="help://account_AccountMargin">AccountMargin</a>,
         <a href="help://account_AccountName">AccountName</a>,
         <a href="help://account_AccountNumber">AccountNumber</a>,
         <a href="help://account_AccountProfit">AccountProfit</a>,
         <a href="help://account_AccountServer">AccountServer</a>,
         <a href="help://common_Alert">Alert</a>,
         <a href="help://convert_CharToStr">CharToStr</a>,
         <a href="help://common_Comment">Comment</a>,
         <a href="help://dateandtime_Day">Day</a>,
         <a href="help://dateandtime_DayOfWeek">DayOfWeek</a>,
         <a href="help://dateandtime_DayOfYear">DayOfYear</a>,
         <a href="help://convert_DoubleToStr">DoubleToStr</a>,
         <a href="help://common_GetTickCount">GetTickCount</a>,
         <a href="help://windows_HideTestIndicators">HideTestIndicators</a>,
         <a href="help://dateandtime_Hour">Hour</a>,
         <a href="help://customind_IndicatorCounted">IndicatorCounted</a>,
         <a href="help://check_IsConnected">IsConnected</a>,
         <a href="help://check_IsDemo">IsDemo</a>,
         <a href="help://check_IsDllsAllowed">IsDllsAllowed</a>,
         <a href="help://check_IsExpertEnabled">IsExpertEnabled</a>,
         <a href="help://check_IsLibrariesAllowed">IsLibrariesAllowed</a>,
         <a href="help://check_IsOptimization">IsOptimization</a>,
         <a href="help://check_IsStopped">IsStopped</a>,
         <a href="help://check_IsTesting">IsTesting</a>,
         <a href="help://check_IsTradeAllowed">IsTradeAllowed</a>,
         <a href="help://check_IsTradeContextBusy">IsTradeContextBusy</a>,
         <a href="help://check_IsVisualMode">IsVisualMode</a>,
         <a href="help://math_MathAbs">MathAbs</a>,
         <a href="help://math_MathArctan">MathArctan</a>,
         <a href="help://math_MathCeil">MathCeil</a>,
         <a href="help://math_MathCos">MathCos</a>,
         <a href="help://math_MathExp">MathExp</a>,
         <a href="help://math_MathFloor">MathFloor</a>,
         <a href="help://math_MathLog">MathLog</a>,
         <a href="help://math_MathMax">MathMax</a>,
         <a href="help://math_MathMin">MathMin</a>,
         <a href="help://math_MathPow">MathPow</a>,
         <a href="help://math_MathRand">MathRand</a>,
         <a href="help://math_MathRound">MathRound</a>,
         <a href="help://math_MathSin">MathSin</a>,
         <a href="help://math_MathSrand">MathSrand</a>,
         <a href="help://math_MathTan">MathTan</a>,
         <a href="help://dateandtime_Minute">Minute</a>,
         <a href="help://dateandtime_Month">Month</a>,
         <a href="help://convert_NormalizeDouble">NormalizeDouble</a>,
         <a href="help://objects_ObjectsDeleteAll">ObjectsDeleteAll</a>,
         <a href="help://objects_ObjectsTotal">ObjectsTotal</a>,
         <a href="help://trading_OrderSelect">OrderSelect</a>,
         <a href="help://trading_OrdersHistoryTotal">OrdersHistoryTotal</a>,
         <a href="help://windows_Period">Period</a>,
         <a href="help://common_Print">Print</a>,
         <a href="help://windows_RefreshRates">RefreshRates</a>,
         <a href="help://dateandtime_Seconds">Seconds</a>,
         <a href="help://customind_SetLevelStyle">SetLevelStyle</a>,
         <a href="help://strings_StringConcatenate">StringConcatenate</a>,
         <a href="help://convert_StrToTime">StrToTime</a>,
         <a href="help://convert_StrToDouble">StrToDouble</a>,
         <a href="help://windows_Symbol">Symbol</a>,
         <a href="help://terminal_TerminalCompany">TerminalCompany</a>,
         <a href="help://terminal_TerminalName">TerminalName</a>,
         <a href="help://terminal_TerminalPath">TerminalPath</a>,
         <a href="help://dateandtime_TimeCurrent">TimeCurrent</a>,
         <a href="help://dateandtime_TimeDay">TimeDay</a>,
         <a href="help://dateandtime_TimeDayOfWeek">TimeDayOfWeek</a>,
         <a href="help://dateandtime_TimeDayOfYear">TimeDayOfYear</a>,
         <a href="help://dateandtime_TimeHour">TimeHour</a>,
         <a href="help://dateandtime_TimeLocal">TimeLocal</a>,
         <a href="help://dateandtime_TimeMinute">TimeMinute</a>,
         <a href="help://dateandtime_TimeMonth">TimeMonth</a>,
         <a href="help://dateandtime_TimeSeconds">TimeSeconds</a>,
         <a href="help://convert_TimeToStr">TimeToStr</a>,
         <a href="help://dateandtime_TimeYear">TimeYear</a>,
         <a href="help://check_UninitializeReason">UninitializeReason</a>,
         <a href="help://windows_WindowBarsPerChart">WindowBarsPerChart</a>,
         <a href="help://windows_WindowFirstVisibleBar">WindowFirstVisibleBar</a>,
         <a href="help://windows_WindowPriceOnDropped">WindowPriceOnDropped</a>,
         <a href="help://windows_WindowTimeOnDropped">WindowTimeOnDropped</a>,
         <a href="help://windows_WindowsTotal">WindowsTotal</a>,
         <a href="help://windows_WindowOnDropped">WindowOnDropped</a>,
         <a href="help://windows_WindowRedraw">WindowRedraw</a>,
         <a href="help://windows_WindowXOnDropped">WindowXOnDropped</a>,
         <a href="help://windows_WindowYOnDropped">WindowYOnDropped</a>,
         <a href="help://dateandtime_Year">Year</a>
        </p>
      </content>
    </text>
  </group>

  
  <group>
    tag=predefined_variables
    caption=Предопределенные переменные
    <content>
    Для каждой выполняющейся MQL4-программы поддерживается ряд предопределенных переменных, которые отражают состояние текущего ценового графика на момент
    запуска программы - эксперта, скрипта или пользовательского индикатора.<br/><br/>
    Библиотеки пользуются переменными вызвавшего их модуля.<br/><br/>
    Для безопасного и быстрого доступа к этим данным клиентский терминал обеспечивает локальные копии предопределенных переменных для каждой запущенной
    программы отдельно. Эти данные обновляются при каждом новом запуске прикрепленного эксперта или пользовательского индикатора автоматически, либо при помощи вызова функции
    <a href="help://windows_RefreshRates">RefreshRates()</a>.
    </content>
    <variable>
      tag=predefined_variables_ask
      caption=Ask
      type=double
      <content>
      Последняя известная цена продажи (запрашиваемая цена) текущего инструмента. Для обновления необходимо использовать функцию <a href="help://windows_RefreshRates">RefreshRates()</a>.<br/>
      <b>См. также</b> <a href="help://common_MarketInfo">MarketInfo()</a>.
      </content>
      <example>
  if(iRSI(NULL,0,14,PRICE_CLOSE,0)&lt;25)
    {
     OrderSend(Symbol(),OP_BUY,Lots,Ask,3,Bid-StopLoss*Point,Ask+TakeProfit*Point,
               &quot;Order Buy #2&quot;,3,D'2005.10.10 12:30',Red);
     return;
    }
      </example>
    </variable>
    <variable>
      tag=predefined_variables_bars
      caption=Bars
      type=int
      <content>
      Количество баров на текущем графике.<br/>
      <b>См. также</b> <a href="help://series_iBars">iBars()</a>.
      </content>
      <example>
  int counter=1;
  for(int i=1; i&lt;=Bars; i++)
    {
     Print(Close[i-1]);
    }
      </example>
    </variable>
    <variable>
      tag=predefined_variables_bid
      caption=Bid
      type=double
      <content>
      Последняя известная цена покупки (предложение на покупку) текущего инструмента. Для обновления необходимо использовать функцию <a href="help://windows_RefreshRates">RefreshRates()</a>.<br/>
      <b>См. также</b> <a href="help://common_MarketInfo">MarketInfo()</a>.
      </content>
      <example>
  if(iRSI(NULL,0,14,PRICE_CLOSE,0)&gt;75)
    {
     OrderSend(&quot;EURUSD&quot;,OP_SELL,Lots,Bid,3,Ask+StopLoss*Point,Bid-TakeProfit*Point,
               &quot;Мой заказ #2&quot;,3,D'2005.10.10 12:30',Red);
     return(0);
    }
      </example>
    </variable>
    <variable>
      tag=predefined_variables_close
      caption=Close[]
      keywords=;Close;
      type=double
      <content>
Массив-таймсерия, содержащий цены закрытия каждого бара текущего графика.<br/><br/>
Индексация элементов таймсерий производится задом наперед, от последнего к первому.
Текущий бар, самый последний в массиве, имеет индекс 0. Самый старый бар, первый на графике, имеет индекс <a href="help://predefined_variables_Bars">Bars</a>-1.<br/><br/>
<b>См. также</b> <a href="help://series_iClose">iClose()</a>.
      </content>
      <example>
  int handle = FileOpen(&quot;file.csv&quot;, FILE_CSV|FILE_WRITE, &quot;;&quot;);
  if(handle&gt;0)
    {
     // запись заголовков столбцов таблицы
     FileWrite(handle, &quot;Time;Open;High;Low;Close;Volume&quot;);
     // запись данных
     for(int i=0; i&lt;Bars; i++)
       FileWrite(handle, Time[i], Open[i], High[i], Low[i], Close[i], Volume[i]);
     FileClose(handle);
    }
      </example>
    </variable>
    <variable>
      tag=predefined_variables_digits
      caption=Digits
      type=int
      <content>
      Количество цифр после десятичной точки в цене текущего инструмента.<br/>
      <b>См. также</b> <a href="help://common_MarketInfo">MarketInfo()</a>.
      </content>
      example=Print(DoubleToStr(Close[0], Digits));
    </variable>
    <variable>
      tag=predefined_variables_high
      caption=High[]
      keywords=;High;
      type=double
      <content>
Массив-таймсерия, содержащий максимальные цены каждого бара текущего графика.<br/><br/>
Индексация элементов таймсерий производится задом наперед, от последнего к первому.
Текущий бар, самый последний в массиве, имеет индекс 0. Самый старый бар, первый на графике, имеет индекс <a href="help://predefined_variables_Bars">Bars</a>-1.<br/><br/>
<b>См. также</b> <a href="help://series_iHigh">iHigh()</a>.
      </content>
      <example>
//---- maximums counting
   i=Bars-KPeriod;
   if(counted_bars&gt;KPeriod) i=Bars-counted_bars-1;
   while(i&gt;=0)
     {
      double max=-1000000;
      k=i+KPeriod-1;
      while(k&gt;=i)
        {
         price=High[k];
         if(max&lt;price) max=price;
         k--;
        }
      HighesBuffer[i]=max;
      i--;
     }
//----
      </example>
    </variable>
    <variable>
      tag=predefined_variables_low
      caption=Low[]
      keywords=;Low;
      type=double
      <content>
Массив-таймсерия, содержащий минимальные цены каждого бара текущего графика.<br/><br/>
Индексация элементов таймсерий производится задом наперед, от последнего к первому.
Текущий бар, самый последний в массиве, имеет индекс 0. Самый старый бар, первый на графике, имеет индекс <a href="help://predefined_variables_Bars">Bars</a>-1.<br/><br/>
<b>См. также</b> <a href="help://series_iLow">iLow()</a>.
      </content>
      <example>
//---- minimums counting
   i=Bars-KPeriod;
   if(counted_bars&gt;KPeriod) i=Bars-counted_bars-1;
   while(i&gt;=0)
     {
      double min=1000000;
      k=i+KPeriod-1;
      while(k&gt;=i)
        {
         price=Low[k];
         if(min&gt;price) min=price;
         k--;
        }
      LowesBuffer[i]=min;
      i--;
     }
      </example>
    </variable>
    <variable>
      tag=predefined_variables_open
      caption=Open[]
      keywords=;Open;
      type=double
      <content>
Массив-таймсерия, содержащий цены открытия каждого бара текущего графика.<br/><br/>
Индексация элементов таймсерий производится задом наперед, от последнего к первому.
Текущий бар, самый последний в массиве, имеет индекс 0. Самый старый бар, первый на графике, имеет индекс <a href="help://predefined_variables_Bars">Bars</a>-1.<br/><br/>
<b>См. также</b> <a href="help://series_iOpen">iOpen()</a>.
      </content>
      <example>
   i = Bars - counted_bars - 1;
   while(i&gt;=0)
     {
      double high  = High[i];
      double low   = Low[i];
      double open  = Open[i];
      double close = Close[i];
      AccumulationBuffer[i] = (close-low) - (high-close);
      if(AccumulationBuffer[i] != 0)
        {
         double diff = high - low;
         if(0==diff)
            AccumulationBuffer[i] = 0;
         else
           {
            AccumulationBuffer[i] /= diff;
            AccumulationBuffer[i] *= Volume[i];
           }
        }
      if(i&lt;Bars-1) AccumulationBuffer[i] += AccumulationBuffer[i+1];
      i--;
     }
      </example>
    </variable>
    <variable>
      tag=predefined_variables_point
      caption=Point
      type=double
      <content>
      Размер пункта текущего инструмента в валюте котировки.<br/>
      <b>См. также</b> <a href="help://common_MarketInfo">MarketInfo()</a>.
      </content>
      example=OrderSend(Symbol(),OP_BUY,Lots,Ask,3,0,Ask+TakeProfit*Point);
    </variable>

    <variable>
      tag=predefined_variables_time
      caption=Time[]
      keywords=;Time;
      type=datetime
      <content>
Массив-таймсерия, содержащий время открытия каждого бара текущего графика. Данные типа datetime представляют собой время в секундах, прошедшее с 00:00 1 января 1970 года.<br/><br/>
Индексация элементов таймсерий производится задом наперед, от последнего к первому.
Текущий бар, самый последний в массиве, имеет индекс 0. Самый старый бар, первый на графике, имеет индекс <a href="help://predefined_variables_Bars">Bars</a>-1.<br/><br/>
<b>См. также</b> <a href="help://series_iTime">iTime()</a>.
      </content>
      <example>
   for(i=Bars-2; i&gt;=0; i--)
     {
      if(High[i+1] &gt; LastHigh) LastHigh = High[i+1];
      if(Low[i+1] &lt; LastLow)   LastLow  = Low[i+1];
      //----
      if(TimeDay(Time[i]) != TimeDay(Time[i+1]))
        {
         P = (LastHigh + LastLow + Close[i+1])/3;
         R1 = P*2 - LastLow;
         S1 = P*2 - LastHigh;
         R2 = P + LastHigh - LastLow;
         S2 = P - (LastHigh - LastLow);
         R3 = P*2 + LastHigh - LastLow*2;
         S3 = P*2 - (LastHigh*2 - LastLow);
         LastLow  = Open[i];
         LastHigh = Open[i];
        }
      //----
      PBuffer[i]  = P;
      S1Buffer[i] = S1;
      R1Buffer[i] = R1;
      S2Buffer[i] = S2;
      R2Buffer[i] = R2;
      S3Buffer[i] = S3;
      R3Buffer[i] = R3;
     }
      </example>
    </variable>
    <variable>
      tag=predefined_variables_volume
      caption=Volume[]
      keywords=;Volume;
      type=double
      <content>
Массив-таймсерия, содержащий тиковые объемы каждого бара текущего графика.<br/><br/>
Индексация элементов таймсерий производится задом наперед, от последнего к первому.
Текущий бар, самый последний в массиве, имеет индекс 0. Самый старый бар, первый на графике, имеет индекс <a href="help://predefined_variables_Bars">Bars</a>-1.<br/><br/>
<b>См. также</b> <a href="help://series_iVolume">iVolume()</a>.
      </content>
      <example>
      if(i==0 &amp;&amp; time0&lt;i_time+periodseconds)
        {
         d_volume += Volume[0];
         if(Low[0]&lt;d_low)   d_low = Low[0];
         if(High[0]&gt;d_high) d_high = High[0];
         d_close = Close[0];
        }
      last_fpos = FileTell(ExtHandle);
      last_volume = Volume[i];
      FileWriteInteger(ExtHandle, i_time, LONG_VALUE);
      FileWriteDouble(ExtHandle, d_open, DOUBLE_VALUE);
      FileWriteDouble(ExtHandle, d_low, DOUBLE_VALUE);
      FileWriteDouble(ExtHandle, d_high, DOUBLE_VALUE);
      FileWriteDouble(ExtHandle, d_close, DOUBLE_VALUE);
      FileWriteDouble(ExtHandle, d_volume, DOUBLE_VALUE);
      </example>
    </variable>
  </group>

  
  <group>
    tag=account
    caption=Информация о счете
    <content>
    Группа функций для доступа к информации об активном счете.
    </content>
    <function>
      tag=account_AccountBalance
      caption=AccountBalance()
      type=double
      keywords=;AccountBalance();
      <content>
      Возвращает значение баланса активного счета (сумма денежных средств на счете).
      </content>
      example=Print(&quot;Баланс счета = &quot;,AccountBalance());
    </function>
    
    <function>
      tag=account_AccountCredit
      caption=AccountCredit()
      type=double
      keywords=;AccountCredit;
      <content>
      Возвращает значение кредита для активного счета.
      </content>
      example=Print(&quot;Кредит счета &quot;, AccountCredit());
    </function>

    <function>
      tag=account_AccountCompany
      caption=AccountCompany()
      type=string
      <content>
      Возвращает название брокерской компании, в которой зарегистрирован текущий счет.
      </content>
      example=Print(&quot;Счет зарегистрирован в компании &quot;, AccountCompany());
    </function>

    <function>
      tag=account_AccountCurrency
      caption=AccountCurrency()
      keywords=;AccountCurrency;
      type=string
      <content>
      Возвращает наименование валюты для текущего счета.
      </content>
      example=Print(&quot;Валюта счета&quot;, AccountCurrency());
    </function>

    <function>
      tag=account_AccountEquity
      caption=AccountEquity()
      keywords=;AccountEquity;
      type=double
      <content>
      Возвращает сумму собственных средств для текущего счета. Расчет equity зависит от настроек торгового сервера.
      </content>
      example=Print(&quot;Средства счета = &quot;,AccountEquity());
    </function>

    <function>
      tag=account_AccountFreeMargin
      caption=AccountFreeMargin()
      type=double
      keywords=;AccountFreeMargin;
      <content>
      Возвращает значение свободных средств, разрешенных для открытия позиций на текущем счете.
      </content>
      example=Print(&quot;Свободная маржа счета = &quot;,AccountFreeMargin());
    </function>

    <function>
      tag=account_AccountFreeMarginCheck
      caption=AccountFreeMarginCheck()
      type=double
      keywords=;AccountFreeMarginCheck;
      <content>
      Возвращает размер свободных средств, которые останутся после открытия указанной позиции по текущей цене на текущем счете. Если свободных средств
      не хватает, то будет сгенерирована <a href="help://constants_errors">ошибка</a> 134 (ERR_NOT_ENOUGH_MONEY).
      </content>
      example=if(AccountFreeMarginCheck(Symbol(),OP_BUY,Lots)&lt;=0 || GetLastError()==134) return;
      <parameter>
        type=string
        name=symbol
        description=Наименование финансового инструмента, с которым должна проводиться торговая операция.
      </parameter>
      <parameter>
        type=int
        name=cmd
        <description>
Торговая операция. Может быть либо <a href="help://constants_trading">OP_BUY</a>, либо <a href="help://constants_trading">OP_SELL</a>.
        </description>
      </parameter>
      <parameter>
        type=double
        name=volume
        description=Количество лотов.
      </parameter>
    </function>

    <function>
      tag=account_AccountFreeMarginMode
      caption=AccountFreeMarginMode()
      type=double
      keywords=;AccountFreeMarginMode;
      <content>
      Режим расчета свободных средств, разрешенных для открытия позиций на текущем счете. Режим расчета может принимать следующие значения:<br/><br/>
      0 - при расчете не используются нереализованные прибыли и убытки;<br/>
      1 - при расчете свободных средств используется как нереализованная прибыль, так и убыток по открытым позициям на текущем счете;<br/>
      2 - при расчете используется только значение прибыли, текущий убыток по открытым позициям не учитывается;<br/>
      3 - при расчете используется только значение убытка, текущая прибыль по открытым позициям не учитывается.
      </content>
      <example>
if(AccountFreeMarginMode()==0)
   Print(&quot;Нереализованные прибыли/убытки не используются.&quot;);
      </example>
    </function>

    <function>
      tag=account_AccountLeverage
      caption=AccountLeverage()
      type=int
      keywords=;AccountLeverage;
      <content>
      Возвращает значение плеча для текущего счета.
      </content>
      example=Print(&quot;Счет #&quot;,AccountNumber(), &quot; плечо &quot;, AccountLeverage());
    </function>

    <function>
      tag=account_AccountMargin
      caption=AccountMargin()
      type=double
      <content>
      Возвращает сумму залоговых средств, используемых для поддержания открытых позиций на текущем счете.
      </content>
      example=Print(&quot;Сумма залоговых средств = &quot;, AccountMargin());
    </function>

    <function>
      tag=account_AccountName
      caption=AccountName()
      type=string
      <content>
      Возвращает имя пользователя текущего счета.
      </content>
      example=Print(&quot;Имя = &quot;, AccountName());
    </function>

    <function>
      tag=account_AccountNumber
      caption=AccountNumber()
      type=int
      <content>
      Возвращает номер текущего счета.
      </content>
      example=Print(&quot;Номер счета = &quot;, AccountNumber());
    </function>

    <function>
      tag=account_AccountProfit
      caption=AccountProfit()
      type=double
      <content>
      Возвращает значение прибыли для текущего счета в базовой валюте.
      </content>
      example=Print(&quot;Прибыль &quot;, AccountProfit());
    </function>

    <function>
      tag=account_AccountServer
      caption=AccountServer()
      type=string
      <content>
      Возвращает имя активного сервера.
      </content>
      example=Print(&quot;Адрес Сервера &quot;, AccountServer());
    </function>

    <function>
      tag=account_AccountStopoutLevel
      caption=AccountStopoutLevel()
      type=int
      <content>
      Возвращает значение уровня, по которому определяется состояние Stop Out.
      </content>
      example=Print(&quot;StopOut level = &quot;, AccountStopoutLevel());
    </function>

    <function>
      tag=account_AccountStopoutMode
      caption=AccountStopoutMode()
      type=int
      <content>
      Возвращает режим расчета уровня Stop Out. Режим расчета может принимать следующие значения:<br/><br/>
      0 - расчет процентного соотношения залоговой маржи к средствам;<br/>
      1 - сравнение уровня свободной маржи с абсолютным значением.
      </content>
      <example>
int level=AccountStopoutLevel();
if(AccountStopoutMode()==0)
   Print(&quot;StopOut level = &quot;, level, &quot;%&quot;);
else
   Print(&quot;StopOut level = &quot;, level, &quot; &quot;, AccountCurrency());
      </example>
    </function>
  </group>


  <group>
    tag=array
    caption=Операции с массивами
    <content>
    Группа функций для работы с массивами.<br/><br/>
    Допускаются не более чем четырехмерные массивы. Индексация каждого измерения производится от 0 до <b>размер измерения</b>-1.
    В частном случае одномерного массива из 50 элементов обращение к первому элементу будет выглядеть как array[0], к последнему элементу - array[49].<br/><br/>
    При помощи данных функций (кроме тех функций, которые меняют качественные и количественные характеристики массива) могут обрабатываться и
    предопределенные массивы-таймсерии <a href="help://predefined_variables_time">Time[]</a>, <a href="help://predefined_variables_open">Open[]</a>,
    <a href="help://predefined_variables_high">High[]</a>, <a href="help://predefined_variables_low">Low[]</a>,
    <a href="help://predefined_variables_close">Close[]</a>, <a href="help://predefined_variables_volume">Volume[]</a>
    </content>
    <function>
      tag=array_ArrayBsearch
      caption=ArrayBsearch()
      type=int
      <content>
        Возвращает индекс первого найденного элемента в первом измерении массива.<br/>
        Если элемент с указанным значением в массиве отсутствует, функция вернет индекс ближайшего меньшего по значению из элементов, между которыми расположено искомое значение.<br/>
        Функция не может применяться к массивами строк и таймсериям (исключение составляет таймсерия времени открытия бара).<br/><br/>
        
        Замечание: двоичный поиск обрабатывает только сортированные массивы.
        Для сортировки числового массива используется функция <a href="help://array_ArraySort">ArraySort()</a>.
      </content>
      <example>
datetime daytimes[];
int      shift=10,dayshift;
// Все Time[] серии времени отсортировано в направлении убывания
ArrayCopySeries(daytimes,MODE_TIME,Symbol(),PERIOD_D1);
if(Time[shift]&gt;=daytimes[0]) dayshift=0;
else
  {
   dayshift=ArrayBsearch(daytimes,Time[shift],WHOLE_ARRAY,0,MODE_DESCEND);
   if(Period()&lt;PERIOD_D1) dayshift++;
  }
Print(TimeToStr(Time[shift]),&quot; corresponds to &quot;,dayshift,&quot; day bar opened at &quot;,
      TimeToStr(daytimes[dayshift]));
      </example>
      <parameter>
        type=double
        name=array[]
        description=Числовой массив для поиска.
      </parameter>
      <parameter>
        type=double
        name=value
        description=Значение для поиска.
      </parameter>
      <parameter>
        type=int
        name=count
        def_value=WHOLE_ARRAY
        description=Количество элементов для поиска. По умолчанию, ищется в целом массиве.
      </parameter>
      <parameter>
        type=int
        name=start
        def_value=0
        description=Начальный индекс для поиска. По умолчанию, поиск начинается с первого элемента.
      </parameter>
      <parameter>
        type=int
        name=direction
        def_value=MODE_ASCEND
        <description>
Направление поиска. Может быть любой из следующих величин:<br/>
MODE_ASCEND поиск в направлении возрастания,<br/>
MODE_DESCEND поиск в направлении убывания.
        </description>
      </parameter>
    </function>

    <function>
      tag=array_ArrayCopy
      caption=ArrayCopy()
      type=int
      <content>
        Копирует один массив в другой. Массивы должны иметь одинаковый тип.
        Массивы типа double[], int[], datetime[], color[], и bool[], можно копировать как массивы одного типа.<br/>
        Возвращает количество скопированных элементов.
      </content>
      <example>
double array1[][6];
double array2[10][6];
// array2 заполнен некоторыми данными
ArrayCopyRates(array1);
ArrayCopy(array2,array1,0,0,60);
// теперь array2 содержит  первые 10 баров из истории (имеется в виду, что первый бар - это бар с индексом [Bars-1])
ArrayCopy(array2,array1,0,Bars*6-60,60);
// теперь array2 содержит 10 последних баров из истории (имеется в виду, что последний бар - это текущий бар, бар с индексом [0])
      </example>
      <parameter>
        type=object&amp;
        name=dest[]
        description=Массив-приемник.
      </parameter>
      <parameter>
        type=object
        name=source[]
        description=Массив-источник.
      </parameter>
      <parameter>
        type=int
        name=start_dest
        def_value=0
        description=Начальный индекс для приемного массива. По умолчанию, стартовый индекс - 0.
      </parameter>
      <parameter>
        type=int
        name=start_source
        def_value=0
        description=Начальный индекс для исходного массива. По умолчанию, стартовый индекс - 0.
      </parameter>
      <parameter>
        type=int
        name=count
        def_value=WHOLE_ARRAY
        description=Количество элементов, которые нужно скопировать. По умолчанию, весь массив (WHOLE_ARRAY).
      </parameter>
    </function>

    <function>
      tag=array_ArrayCopyRates
      caption=ArrayCopyRates()
      type=int
      <content>
        Копирует в двухмерный массив, вида RateInfo[][6], данные баров текущего графика и возвращает количество скопированных баров, либо -1 в случае неудачи.
        Первое измерение содержит количество баров. Второе измерение имеет 6 элементов со значениями:<br/>
        <div class="content">
        0 - время (time),<br/>
        1 - цена открытия (open),<br/>
        2 - наименьшая цена (low),<br/>
        3 - наивысшая цена (high),<br/>
        4 - цена закрытия (close),<br/>
        5 - объём (volume).<br/>
        </div><br/>
        Если копируются данные "чужого" инструмента и/или таймфрейма, то возможна ситуация отсутствия требуемых данных.
        В этом случае в переменную <a href="help://runtime_errors">last_error</a> будет помещена <a href="help://constants_errors">ошибка</a>
        ERR_HISTORY_WILL_UPDATED (4066 - запрошенные исторические данные в состоянии обновления) и необходимо через некоторое время повторить попытку копирования.<br/><br/>
        
        Замечания: обычно массив используется, чтобы передать данные в DLL функцию.<br/>
        Реального распределения памяти под массив данных и копирования не происходит. При обращении
        к такому массиву производится перенаправление доступа.
      </content>
      <example>
double array1[][6];
ArrayCopyRates(array1,"EURUSD", PERIOD_H1);
Print("Текущий бар ",TimeToStr(array1[0][0]),"цена открытия ", array1[0][1]);
      </example>
      <parameter>
        type=double&amp;
        name=<nobr>dest_array[]</nobr>
        description=Ссылка на двумерный массив.
      </parameter>
      <parameter>
        type=string
        name=symbol
        def_value=NULL
        description=Наименование инструмента (символ валютной пары).
      </parameter>
      <parameter>
        type=int
        name=timeframe
        def_value=0
        description=Период. Может быть любым значением из <a href="help://constants_timeframes">перечисленных периодов</a>.
      </parameter>
    </function>

    <function>
      tag=array_ArrayCopySeries
      caption=ArrayCopySeries()
      type=int
      <content>
        Копирует массив-таймсерию в пользовательский массив и возвращает количество скопированных элементов.<br/><br/>

        Реального распределения памяти под массив данных и копирования не происходит. При обращении
        к такому массиву производится перенаправление доступа. Исключение составляют массивы, <a href="help://customind_SetIndexBuffer">назначенные в качестве индексных</a>
        в пользовательских индикаторах. В этом случае производится реальное копирование данных.<br/><br/>
        Если копируются данные "чужого" инструмента и/или таймфрейма, то возможна ситуация отсутствия требуемых данных.
        В этом случае в переменную <a href="help://runtime_errors">last_error</a> будет помещена <a href="help://constants_errors">ошибка</a>
        ERR_HISTORY_WILL_UPDATED (4066 - запрошенные исторические данные в состоянии обновления) и необходимо через некоторое время повторить попытку копирования.<br/><br/>
        
        Замечание: если series_index - MODE_TIME, то передаваемый в функцию массив должен иметь тип datetime[].
      </content>
      <example>
datetime daytimes[];
int      shift=10,dayshift,error;
//---- массив Time[] отсортирован в порядке убывания
ArrayCopySeries(daytimes,MODE_TIME,Symbol(),PERIOD_D1);
error=GetLastError();
if(error==4066)
  {
   //---- делаем еще 2 попытки чтения
   for(int i=0;i&lt;2; i++)
     {
      Sleep(5000);
      ArrayCopySeries(daytimes,MODE_TIME,Symbol(),PERIOD_D1);
      //---- проверим время текущего дневного бара
      datetime last_day=daytimes[0];
      if(Year()==TimeYear(last_day) &amp;&amp; Month()==TimeMonth(last_day) &amp;&amp; Day()==TimeDay(last_day)) break;
     }
  }
if(Time[shift]&gt;=daytimes[0]) dayshift=0;
else
  {
   dayshift=ArrayBsearch(daytimes,Time[shift],WHOLE_ARRAY,0,MODE_DESCEND);
   if(Period()&lt;PERIOD_D1) dayshift++;
  }
Print(TimeToStr(Time[shift])," corresponds to ",dayshift," day bar opened at ", TimeToStr(daytimes[dayshift]));
      </example>
      <parameter>
        type=double&amp;
        name=<nobr>array[]</nobr>
        description=Ссылка на одномерный числовой массив.
      </parameter>
      <parameter>
        type=int
        name=series_index
        description=Идентификатор массива-таймсерии. Должен быть одним из перечисленных идентификаторов <a href="help://constants_series">таймсерий</a>.
      </parameter>
      <parameter>
        type=string
        name=symbol
        def_value=NULL
        description=Наименование инструмента (символ валютной пары).
      </parameter>
      <parameter>
        type=int
        name=timeframe
        def_value=0
        description=Период графика (таймфрейм). Может быть любым значением из <a href="help://constants_timeframes">перечисленных периодов</a>.
      </parameter>
    </function>

    <function>
      tag=array_ArrayDimension
      caption=ArrayDimension()
      type=int
      <content>
      Возвращает ранг многомерного массива.
      </content>
      <example>
int num_array[10][5];
int dim_size;
dim_size=ArrayDimension(num_array);
// dim_size=2
      </example>
      <parameter>
        type=object
        name=<nobr>array[]</nobr>
        description=Массив, для которого будет возвращен ранг.
      </parameter>
    </function>

    <function>
      tag=array_ArrayGetAsSeries
      caption=ArrayGetAsSeries()
      type=bool
      <content>
        Возвращается TRUE, если массив организован как таймсерия (элементы массива индексируются от последнего к первому), иначе возвращается FALSE.
      </content>
      <example>
if(ArrayGetAsSeries(array1)==true)
  Print(&quot;array1 индексирован как таймсерия&quot;);
else
  Print(&quot;array1 индексирован обычно (слева направо)&quot;);
      </example>
      <parameter>
        type=object
        name=<nobr>array[]</nobr>
        description=Проверяемый массив.
      </parameter>
    </function>

    <function>
      tag=array_ArrayInitialize
      caption=ArrayInitialize()
      type=int
      <content>
        Устанавливает все элементы числового массива в одну величину. Возвращает количество инициализированных элементов.<br/><br/>

        Замечание: не рекомендуется инициализировать индексные буферы в функции <i>init()</i> пользовательских индикаторов,
        так как они инициализируются автоматически <a href="help://customind_SetIndexEmptyValue">&quot;пустым значением&quot;</a> при
        распределении и перераспределении буферов.
      </content>
      <example>
//---- инициализация всех элементов массива значением 2.1
double myarray[10];
ArrayInitialize(myarray,2.1);
      </example>
      <parameter>
        type=double&amp;
        name=<nobr>array[]</nobr>
        description=Числовой массив, который нужно инициализировать.
      </parameter>
      <parameter>
        type=double
        name=value
        description=Новая величина, которая нужно установить.
      </parameter>
    </function>

    <function>
      tag=array_ArrayIsSeries
      caption=ArrayIsSeries()
      type=bool
      <content>
      Возвращается TRUE, если проверяемый массив является массивом-таймсерией (Time[],Open[],Close[],High[],Low[] или Volume[]), иначе возвращается FALSE.
      </content>
      <example>
if(ArrayIsSeries(array1)==false)
  ArrayInitialize(array1,0);
else
  {
   Print("Таймсерия не может быть инициализирована!");
   return(-1);
  }
      </example>
      <parameter>
        type=object
        name=<nobr>array[]</nobr>
        description=Проверяемый массив.
      </parameter>
    </function>

    <function>
      tag=array_ArrayMaximum
      caption=ArrayMaximum()
      type=int
      <content>
      Поиск элемента с максимальным значением. Функция возвращает позицию максимального элемента в массиве.
      </content>
      <example>
double num_array[15]={4,1,6,3,9,4,1,6,3,9,4,1,6,3,9};
int    maxValueIdx=ArrayMaximum(num_array);
Print(&quot;Max value = &quot;, num_array[maxValueIdx]);
      </example>
      <parameter>
        type=double
        name=<nobr>array[]</nobr>
        description=Числовой массив, в котором производится поиск.
      </parameter>
      <parameter>
        type=int
        name=count
        def_value=WHOLE_ARRAY
        description=Количество элементов для поиска.
      </parameter>
      <parameter>
        type=int
        name=start
        def_value=0
        description=Начальный индекс для поиска.
      </parameter>
    </function>

    <function>
      tag=array_ArrayMinimum
      caption=ArrayMinimum()
      type=int
      <content>
      Поиск элемента с минимальным значением. Функция возвращает позицию минимального элемента в массиве.
      </content>
      <example>
double num_array[15]={4,1,6,3,9,4,1,6,3,9,4,1,6,3,9};
int    minValueidx=ArrayMinimum(num_array);
Print(&quot;Min value = &quot;, num_array[minValueIdx]);
      </example>
      <parameter>
        type=double
        name=<nobr>array[]</nobr>
        description=Числовой массив, в котором производится поиск.
      </parameter>
      <parameter>
        type=int
        name=count
        def_value=WHOLE_ARRAY
        description=Количество элементов для поиска.
      </parameter>
      <parameter>
        type=int
        name=start
        def_value=0
        description=Начальный индекс для поиска.
      </parameter>
    </function>

    <function>
      tag=array_ArrayRange
      caption=ArrayRange()
      type=int
      <content>
        Возвращает число элементов в указанном измерении массива.
        Поскольку индексы начинаются с нуля, размер измерения на 1 больше, чем самый большой индекс.
      </content>
      <example>
int    dim_size;
double num_array[10,10,10];
dim_size=ArrayRange(num_array, 1);
      </example>
      <parameter>
        type=object
        name=<nobr>array[]</nobr>
        description=Проверяемый массив
      </parameter>
      <parameter>
        type=int
        name=range_index
        description=Индекс измерения.
      </parameter>
    </function>

    <function>
      tag=array_ArrayResize
      caption=ArrayResize()
      type=int
      <content>
        Устанавливает новый размер в первом измерении массива.
        При успешном выполнении функция возвращает количество всех элементов, содержащихся в массиве после изменения размера,
        в противном случае возвращает -1, и массив не меняет размеры.<br/>
        Замечание: массив, объявленный на локальном уровне в какой-либо функции, у которого был изменен размер, останется неизменным после завершения работы функции.
        При повторном вызове функции такой массив будет иметь размер, отличный от объявленного.
      </content>
      <example>
double array1[][4];
int    element_count=ArrayResize(array1, 20);
// новый размер - 80 элементов
      </example>
      <parameter>
        type=object&amp;
        name=<nobr>array[]</nobr>
        description=Массив для изменения размеров.
      </parameter>
      <parameter>
        type=int
        name=new_size
        description=Новый размер для первого измерения.
      </parameter>
    </function>

    <function>
      tag=array_ArraySetAsSeries
      caption=ArraySetAsSeries()
      type=bool
      <content>
        Устанавливает направление индексирования в массиве.
        Значение параметра <i>set</i> TRUE устанавливает направление индексирования в обратном порядке,
        то есть, последний элемент имеет нулевой индекс. Значение FALSE устанавливает нормальное направление индексирования.
        Функция возвращает предыдущее состояние.
      </content>
      <example>
double macd_buffer[300];
double signal_buffer[300];
int    i,limit=ArraySize(macd_buffer);
ArraySetAsSeries(macd_buffer,true);
 
for(i=0; i&lt;limit; i++)
   macd_buffer[i]=iMA(NULL,0,12,0,MODE_EMA,PRICE_CLOSE,i)-iMA(NULL,0,26,0,MODE_EMA,PRICE_CLOSE,i);
   
for(i=0; i&lt;limit; i++)
   signal_buffer[i]=iMAOnArray(macd_buffer,limit,9,0,MODE_SMA,i);
      </example>
      <parameter>
        type=double&amp;
        name=<nobr>array[]</nobr>
        description=Числовой массив для установки.
      </parameter>
      <parameter>
        type=bool
        name=set
        description=Направление индексирования массива.
      </parameter>
    </function>

    <function>
      tag=array_ArraySize
      caption=ArraySize()
      type=int
      <content>
        Возвращает количество элементов массива. Для одномерного массива значение, возвращаемое функцией ArraySize,
        равно значению <a href="help://array_ArrayRange">ArrayRange(array,0)</a>.
      </content>
      <example>
int count=ArraySize(array1);
for(int i=0; i&lt;count; i++)
  {
   // некоторые вычисления.
  }
      </example>
      <parameter>
        type=object
        name=<nobr>array[]</nobr>
        description=Массив любого типа.
      </parameter>
    </function>

    <function>
      tag=array_ArraySort
      caption=ArraySort()
      type=int
      keywords=;MODE_ASCEND;MODE_DESCEND;
      <content>
      Сортировка числовых массивов по первому измерению. Массивы-таймсерии не могут быть отсортированы.
      </content>
      <example>
double num_array[5]={4,1,6,3,9};
// массив содержит величины 4,1,6,3,9
ArraySort(num_array);
// теперь массив отсортирован 1,3,4,6,9
ArraySort(num_array,WHOLE_ARRAY,0,MODE_DESCEND);
// теперь массив отсортирован 9,6,4,3,1
      </example>
      <parameter>
        type=double&amp;
        name=<nobr>array[]</nobr>
        description=Числовой массив для сортировки.
      </parameter>
      <parameter>
        type=int
        name=count
        def_value=WHOLE_ARRAY
        description=Количество элементов для сортировки.
      </parameter>
      <parameter>
        type=int
        name=start
        def_value=0
        description=Начальный индекс.
      </parameter>
      <parameter>
        type=int
        name=sort_dir
        def_value=MODE_ASCEND
        <description>
          Направление сортировки массива. Это может быть любым из следующего величин<br/>
          MODE_ASCEND - сортировка в порядке возрастания<br/>
          MODE_DESCEND - сортировка в порядке убывания.
        </description>
      </parameter>
    </function>
  </group>

  <group>
    tag=check
    caption=Проверка состояния
    <content>
    Группа функций, позволяющих определить текущее состояние клиентского терминала, в том числе состояние окружения выполняемой MQL4-программы.
    </content>

    <function>
      tag=check_GetLastError
      caption=GetLastError()
      type=int
      <content>
Функция возвращает <a href="help://constants_errors">код последней ошибки</a>, после чего значение специальной переменной <a href="help://runtime_errors">last_error</a>, в которой хранится код последней ошибки обнуляется. Так что последующий вызов GetLastError() вернет значение 0.
      </content>
      <example>
  int err;
  int handle=FileOpen(&quot;somefile.dat&quot;, FILE_READ|FILE_BIN);
  if(handle&lt;1)
    {
     err=GetLastError();
     Print(&quot;error(&quot;,err,&quot;): &quot;,ErrorDescription(err));
     return(0);
    }
      </example>
    </function>

    <function>
      tag=check_IsConnected
      caption=IsConnected()
      type=bool
      <content>
      Возвращает состояние главного соединения клиентского терминала с сервером, по которому производится подкачка данных. TRUE - связь с сервером установлена, FALSE - связь с сервером отсутствует или прервана.
      </content>
      <example>
  if(!IsConnected())
    {
     Print(&quot;Связь отсутствует!&quot;);
     return(0);
    }
  // Тело скрипта, нуждающегося в открытом подключении
  // ...
      </example>
    </function>   
    <function>
      tag=check_IsDemo
      caption=IsDemo()
      type=bool
      <content>
      Возвращается TRUE, если программа работает на демонстрационном счете, в противном случае возвращает FALSE.
      </content>
      <example>
  if(IsDemo()) Print(&quot;Я работаю на демонстрационном счете&quot;);
  else Print(&quot;Я работаю на реальном счете&quot;);
      </example>
    </function>

    <function>
      tag=check_IsDllsAllowed
      caption=IsDllsAllowed()
      type=bool
      <content>
Возвращает TRUE, если DLL вызов функции разрешены для эксперта, иначе возвращает FALSE.<br/>
<b>См. также</b> <a href="help://check_IsLibrariesAllowed">IsLibrariesAllowed()</a>, <a href="help://check_IsTradeAllowed">IsTradeAllowed()</a>.
      </content>
      <example>
  #import &quot;user32.dll&quot;
     int     MessageBoxA(int hWnd, string szText, string szCaption,int nType);
  ...
  ...
  if(IsDllsAllowed()==false)
    {
     Print(&quot;Вызов из библиотек (DLL) невозможен. Эксперт не может выполняться.&quot;);
     return(0);
    }
  // Тело Эксперта, вызывающее внешние функции DLL
  MessageBoxA(0,&quot;an message&quot;,&quot;Message&quot;,MB_OK);
      </example>
    </function>

    <function>
      tag=check_IsExpertEnabled
      caption=IsExpertEnabled()
      type=bool
      <content>
Возвращает TRUE, если в клиентском терминале разрешен запуск экспертов, иначе возвращает FALSE.
      </content>
      <example>
  while(!IsStopped())
    {
     ...
     if(!IsExpertEnabled()) break;
    }
      </example>
    </function>

    <function>
      tag=check_IsLibrariesAllowed
      caption=IsLibrariesAllowed()
      type=bool
      <content>
Возвращает TRUE, если эксперт может назвать библиотечную функцию, иначе возвращает FALSE.<br/>
<b>См. также</b> <a href="help://check_IsDllsAllowed">IsDllsAllowed()</a>, <a href="help://check_IsTradeAllowed">IsTradeAllowed()</a>.
      </content>
      <example>
  #import &quot;somelibrary.ex4&quot;
     int somefunc();
  ...
  ...
  if(IsLibrariesAllowed()==false)
    {
     Print(&quot;Библиотечные вызовы запрещены.&quot;);
     return(0);
    }
  // Тело Эксперта, вызывающее внешние функции DLL
  somefunc();
      </example>
    </function>

    <function>
      tag=check_IsOptimization
      caption=IsOptimization()
      type=bool
      <content>
      Возвращается TRUE, если эксперт работает в режиме оптимизации тестирования, иначе возвращает FALSE.
      </content>
      <example>
  if(IsOptimization()) return(0);
      </example>
    </function>

    <function>
      tag=check_IsStopped
      caption=IsStopped()
      type=bool
      <content>
Возвращается TRUE, если программа (эксперт или скрипт) получила команду на завершение своей работы, иначе возвращает FALSE.
Программа может работать еще 2.5 секунды прежде, чем клиентский терминал принудительно завершит ее <a href="help://runtime_start">выполнение</a>.
      </content>
      <example>
  while(expr!=false)
    {
     if(IsStopped()==true) return(0);
     // цикл с длительным временем исполнения
     // ...
    }
      </example>
    </function>

    <function>
      tag=check_IsTesting
      caption=IsTesting()
      type=bool
      <content>
      Возвращается TRUE, если эксперт работает в режиме тестирования, иначе возвращает FALSE.
      </content>
      <example>
  if(IsTesting()) Print(&quot;Тестирование эксперта&quot;);
      </example>
    </function>

    <function>
      tag=check_IsTradeAllowed
      caption=IsTradeAllowed()
      type=bool
      <content>
Возвращается TRUE, если эксперту разрешено торговать и поток для выполнения торговых операций свободен, иначе возвращает FALSE.<br/>
<b>См. также</b> <a href="help://check_IsDllsAllowed">IsDllsAllowed()</a>, <a href="help://check_IsLibrariesAllowed">IsLibrariesAllowed()</a>, <a href="help://check_IsTradeContextBusy">IsTradeContextBusy()</a>.
      </content>
      <example>
  if(IsTradeAllowed()) Print(&quot;Торговля разрешена&quot;);
      </example>
    </function>

    <function>
      tag=check_IsTradeContextBusy
      caption=IsTradeContextBusy()
      type=bool
      <content>
Возвращается TRUE, если поток для выполнения торговых операций занят, иначе возвращает FALSE.<br/>
<b>См. также</b> <a href="help://check_IsTradeAllowed">IsTradeAllowed()</a>.
      </content>
      <example>
  if(IsTradeContextBusy()) Print(&quot;Торговый поток занят. Подождите&quot;);
      </example>
    </function>

    <function>
      tag=check_IsVisualMode
      caption=IsVisualMode()
      type=bool
      <content>
      Возвращается TRUE, если эксперт тестируется в режиме визуализации, иначе возвращает FALSE.
      </content>
      <example>
  if(IsVisualMode()) Comment("Визуализация включена");
      </example>
    </function>

    <function>
      tag=check_UninitializeReason
      caption=UninitializeReason()
      type=int
      <content>
Возвращает код причины завершения экспертов, пользовательских индикаторов и скриптов. Возвращаемые значения могут быть одним из
<a href="help://constants_uninit">кодов деинициализации</a>. Эту функцию можно также вызывать в функции init()
для анализа причин деинициализации предыдущего запуска.
      </content>
      <example>
  // пример
  int deinit()
    {
     switch(UninitializeReason())
       {
        case REASON_CHARTCLOSE:
        case REASON_REMOVE:      CleanUp(); break;    // очистка и освобождение ресурсов.
        case REASON_RECOMPILE:
        case REASON_CHARTCHANGE:
        case REASON_PARAMETERS:
        case REASON_ACCOUNT:     StoreData(); break;  // подготовка к рестарту.
       }
     //...
    }
      </example>
    </function>
</group>

  <group>
    tag=terminal
    caption=Клиентский терминал
    <content>
    Функции, возвращающие информацию о клиентском терминале.
    </content>

    <function>
      tag=terminal_TerminalCompany
      caption=TerminalCompany()
      type=string
      <content>
      Возвращает наименование компании-владельца клиентского терминала.
      </content>
      example=Print(&quot;Компания &quot;,TerminalCompany());
    </function>

    <function>
      tag=terminal_TerminalName
      caption=TerminalName()
      type=string
      <content>
      Возвращает имя клиентского терминала.
      </content>
      example=Print(&quot;Работает терминал &quot;,TerminalName());
    </function>

    <function>
      tag=terminal_TerminalPath
      caption=TerminalPath()
      type=string
      <content>
      Возвращает директорий, из которого запущен клиентский терминал.
      </content>
      example=Print(&quot;Рабочий директорий &quot;,TerminalPath());
    </function>
</group>

  <group>
    tag=common
    caption=Общие функции
    <content>
    Функции общего назначения, которые не вошли ни в одну из специализированных групп.
    </content>

    <function>
      tag=common_Alert
      caption=Alert()
      type=void
      <content>
Отображает диалоговое окно, содержащие пользовательские данные.
Параметры могут быть любого типа. Количество параметров не может превышать 64.<br/><br/>
Массивы нельзя передавать в функцию Alert(). Массивы должны выводиться поэлементно.<br/><br/>
Данные типа double выводятся с 4 десятичными цифрами после точки.
Для вывода чисел с большей точностью используйте функцию <a href="help://convert_DoubleToStr">DoubleToStr()</a>.<br/>
Данные типы bool, datetime и color будут выведены как числа.<br/>
Чтобы вывести данные типа datetime в виде строки, необходимо использовать функцию <a href="help://convert_TimeToStr">TimeToStr()</a>.<br/><br/>
Для разделения выводимой информации на несколько строк можно использовать символ перевода строки "\n" либо "\r\n".<br/>
<b>См. также</b> функции <a href="help://common_Comment">Comment()</a> и <a href="help://common_Print">Print()</a>.
      </content>
      <example>
  if(Close[0]&gt;SignalLevel)
    Alert(&quot;Price &quot;, Close[0],&quot; is coming!!!&quot;);
      </example>
      <parameter>
        type=...
        name=
        description=Любые значения, разделенные запятыми.
      </parameter>
    </function>

    <function>
      tag=common_Comment
      caption=Comment()
      type=void
      <content>
Функция выводит комментарий, определенный пользователем, в левый верхний угол графика. Параметры могут иметь любой тип. Количество параметров не может превышать 64.<br/><br/>
Массивы нельзя передавать в функцию Comment(). Массивы должны печататься поэлементно.<br/><br/>
Данные типа double выводятся с 4 десятичными цифрами после точки.
Для вывода чисел с большей точностью необходимо использовать функцию <a href="help://convert_DoubleToStr">DoubleToStr()</a>.<br/>
Типы bool, datetime и color будут напечатаны как числа.<br/>
Чтобы вывести данные типа datetime в виде строки используйте функцию <a href="help://convert_TimeToStr">TimeToStr()</a>.<br/><br/>
Для разделения выводимой информации на несколько строк можно использовать символ перевода строки "\n" либо "\r\n".<br/>
<b>См. также</b> функции <a href="help://common_Alert">Alert()</a> и <a href="help://common_Print">Print()</a>.
      </content>
      <example>
  double free=AccountFreeMargin();
  Comment(&quot;Account free margin is &quot;,DoubleToStr(free,2),"\n",&quot;Current time is &quot;,TimeToStr(TimeCurrent()));
      </example>
      <parameter>
        type=...
        name=
        description=Любые значения, разделенные запятыми.
      </parameter>
    </function>

    <function>
      tag=common_GetTickCount
      caption=GetTickCount()
      type=int
      <content>
      Функция GetTickCount() возвращает количество миллисекунд, прошедших с момента старта системы.
      Счетчик ограничен разрешающей способностью системного таймера. Так как время хранится как беззнаковое
      целое, то он переполняется каждые 49.7 дней.
      </content>
      <example>
  int start=GetTickCount();
  // некие серьёзные вычисления...
  Print(&quot;Время вычисления &quot;, GetTickCount()-start, &quot; миллисекунд.&quot;);
      </example>
    </function>
   
    <function>
      tag=common_MarketInfo
      caption=MarketInfo()
      type=double
      <content>
      Возвращает различную информацию о финансовых инструментах, перечисленных в окне &quot;Обзор рынка&quot;.
      Часть информации о текущем финансовом инструменте хранится в <a href="help://predefined_variables">предопределенных переменных</a>. 
      </content>
      <example>
   double bid   =MarketInfo(&quot;EURUSD&quot;,MODE_BID);
   double ask   =MarketInfo(&quot;EURUSD&quot;,MODE_ASK);
   double point =MarketInfo(&quot;EURUSD&quot;,MODE_POINT);
   int    digits=MarketInfo(&quot;EURUSD&quot;,MODE_DIGITS);
   int    spread=MarketInfo(&quot;EURUSD&quot;,MODE_SPREAD);
      </example>
      <parameter>
        type=string
        name=symbol
        description=Символ инструмента.
      </parameter>
      <parameter>
        type=int
        name=type
        description=Идентификатор запроса, определяющий тип возвращаемой информации. Может быть любым из значений <a href="help://constants_marketinfo">идентификаторов запроса</a>.
      </parameter>
    </function>

    <function>
      tag=common_MessageBox
      caption=MessageBox()
      type=int
      keywords=;MessageBox;
      <content>
Функция MessageBox создает и отображает окно сообщений, а также управляет им. Окно сообщений содержит определенные приложением сообщение и заголовок,
любую комбинацию предопределенных значков и командных кнопок. Если функция успешно выполняется, возвращаемое значение - одно из значений 
<a href="help://constants_messagebox">кодов возврата</a> MessageBox().<br/>
Функцию нельзя вызывать из пользовательских индикаторов, так как индикаторы <a href="help://runtime_start">выполняются</a> в интерфейсном потоке и не должны его тормозить.
      </content>
      <example>
  #include &lt;WinUser32.mqh&gt;
  
  if(ObjectCreate(&quot;text_object&quot;, OBJ_TEXT, 0, D'2004.02.20 12:30', 1.0045)==false)
    {
     int ret=MessageBox(&quot;Функция ObjectCreate() вернула ошибку &quot;+GetLastError()+&quot;\nПродолжить?&quot;, &quot;Question&quot;, MB_YESNO|MB_ICONQUESTION);
     if(ret==IDNO) return(false);
    }
  // продолжение
      </example>
      <parameter>
        type=string
        name=text
        def_value=NULL
        description=Текст, содержащий сообщение для отображения.
      </parameter>
      <parameter>
        type=string
        name=caption
        def_value=NULL
        <description>
Необязательный текст для отображения в заголовке окна сообщения.
 Если этот параметр пустой, в заголовке окна будет отображено название эксперта.
        </description>
      </parameter>
      <parameter>
        type=int
        name=flags
        def_value=EMPTY
        <description>
Необязательные флаги, определяющие вид и поведение диалогового окна.
 Флаги могут быть комбинацией <a href="help://constants_messagebox"> флагов</a> из следующих групп флагов.
        </description>
      </parameter>
    </function>

    <function>
      tag=common_PlaySound
      caption=PlaySound()
      type=void
      <content>
      Функция воспроизводит звуковой файл. Файл должен быть расположен в каталоге <em>каталог_терминала\sounds</em> или его подкаталоге.
      </content>
      <example>
  if(IsDemo()) PlaySound(&quot;alert.wav&quot;);
      </example>
      <parameter>
        type=string
        name=filename
        description=путь к звуковому файлу.
      </parameter>
    </function>

    <function>
      tag=common_Print
      caption=Print()
      type=void
      keywords=;Print;
      <content>
Печатает некоторое сообщение в журнал экспертов. Параметры могут иметь любой тип. Количество параметров не может превышать 64.<br/><br/>
Массивы нельзя передать в функцию Print(). Массивы должны быть напечатаны поэлементно.<br/><br/>
Данные типа double выводятся с 4 десятичными цифрами после точки. Чтобы получить большую точность, следует использовать функцию <a href="help://convert_DoubleToStr">DoubleToStr()</a>.<br/>
Данные типов bool, datetime и color будут напечатаны в виде чисел.<br/>
Чтобы печатать значения datetime как строку с датой, следует использовать функцию <a href="help://convert_TimeToStr">TimeToStr()</a>.<br/>
<b>См. также</b> функции <a href="help://common_Alert">Alert()</a> и <a href="help://common_Comment">Comment()</a>.
      </content>
      <example>
  Print(&quot;Свободная маржа счета &quot;, AccountFreeMargin());
  Print(&quot;Текущее время &quot;, TimeToStr(TimeCurrent()));
  double pi=3.141592653589793;
  Print(&quot;Число PI &quot;, DoubleToStr(pi,8));
  // Выход: число PI 3.14159265
  // Печать массива
  for(int i=0;i&lt;10;i++)
    Print(Close[i]);
      </example>
      <parameter>
        type=...
        name=
        description=Любые значения, разделенные запятыми.
      </parameter>
    </function>

    <function>
      tag=common_SendFTP
      caption=SendFTP()
      type=bool
      <content>
Посылает файл по адресу, указанному в окне настроек на закладке "Публикация". В случае неудачи возвращает FALSE.<br/>
Функция не работает в режиме тестирования. Из пользовательских индикаторов также нельзя вызывать эту функцию.<br/>
Отсылаемый файл должен находиться в папке <em>каталог_терминала\experts\files</em> или ее подпапках.<br/>
Отсылка не производится, если в настройках не указан адрес FTP и/или пароль доступа.
      </content>
      <example>
  int lasterror=0;
  if(!SendFTP("report.txt"))
    lasterror=GetLastError();
      </example>
      <parameter>    
        type=string
        name=filename
        description=Имя отсылаемого файла.
      </parameter>
      <parameter>
        type=string
        name=ftp_path
        description=Каталог FTP. Если каталог не указан, то используется каталог, описанный в настройках.
        def_value=NULL
      </parameter>
    </function>

    <function>
      tag=common_SendMail
      caption=SendMail()
      type=void
      <content>
Посылает электронное письмо по адресу, указанному в окне настроек на закладке "Почта".<br/>
Отсылка может быть запрещена в настройках, также может быть не указан адрес электронной почты.
Чтобы получить информацию об ошибке, необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.
      </content>
      <example>
  double lastclose=Close[0];
  if(lastclose&lt;my_signal)
    SendMail(&quot;из Вашего эксперта&quot;, &quot;Цена изменилась &quot;+DoubleToStr(lastclose,Digits));
      </example>
      <parameter>    
        type=string
        name=subject
        description=Заголовок письма.
      </parameter>
      <parameter>
        type=string
        name=some_text
        description=Тело письма.
      </parameter>
    </function>

    <function>
      tag=common_SendNotification
      caption=SendNotification()
      type=bool
      <content>
Посылает Push-уведомление на мобильные терминалы, чьи MetaQuotes ID указаны в окне настроек на закладке "Уведомления".<br/>
Отсылка может быть запрещена в настройках, также может быть не указан ID.</br>
В случае ошибки возвращает false. Чтобы получить информацию об ошибке, необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.<br/><br/>
Замечание: Для функции SendNotification() установлены жесткие ограничения по использованию: не более 2-х вызовов в секунду и не более 10 вызовов в минуту. Контроль за частотой использования осуществляется динамически, и функция может быть заблокирована при нарушении.
      </content>
      <example>
  double lastclose=Close[0];
  if(lastclose&lt;my_signal)
    SendNotification(&quot;Цена изменилась &quot;+DoubleToStr(lastclose,Digits));
      </example>
      <parameter>
        type=string
        name=message
        description=Текст сообщения длиною не более 255 символов.
      </parameter>
    </function>


    <function>
      tag=common_Sleep
      caption=Sleep()
      type=void
      <content>
      Функция задерживает выполнение текущего эксперта или скрипта на определенный интервал.<br/>
      Функцию Sleep() нельзя вызывать из пользовательских индикаторов, так как индикаторы <a href="help://runtime_start">выполняются</a> в интерфейсном потоке и не должны его тормозить.<br/>
      В функцию встроена проверка <a href="help://check_IsStopped">состояния флага остановки</a> эксперта каждую 0.1 секунды.
      </content>
      <example>
//---- wait for 10 seconds
   Sleep(10000);
      </example>
      <parameter>
        type=int
        name=milliseconds
        description=Интервал задержки в миллисекундах.
      </parameter>
    </function>
  </group>


  <group>
    tag=convert
    caption=Преобразования данных
    <content>
    Группа функций, обеспечивающих преобразование данных из одного формата в данные другого формата.<br/><br/>
    Особо следует отметить функцию <a href="help://convert_NormalizeDouble">NormalizeDouble()</a>, которая обеспечивает требуемую точность представления
    цены. В торговых операциях нельзя использовать ненормализованные цены, чья точность превышает требуемую торговым сервером хотя бы на один знак.
    </content>

    <function>
      tag=convert_CharToStr
      caption=CharToStr()
      type=string
      <content>
      Преобразование кода символа в односимвольную строку.
      </content>
      <example>
  string str=&quot;WORL&quot;+CharToStr(44); // 44 - код для 'D'
  // результирующая строка будет WORLD
      </example>
      <parameter>
        type=int
        name=char_code
        description=ASCII-код символа.
      </parameter>
    </function>

    <function>
      tag=convert_DoubleToStr
      caption=DoubleToStr()
      type=string
      <content>
Преобразование числового значения в текстовую строку, содержащую символьное представление числа в указанном формате точности.
      </content>
      <example>
  string value=DoubleToStr(1.28473418, 5);
  // содержимое строки value - &quot;1.28473&quot;
      </example>
      <parameter>
        type=double
        name=value
        description=Величина с плавающей точкой.
      </parameter>
      <parameter>
        type=int
        name=digits
        description=Формат точности, число цифр после десятичной точки (0-8).
      </parameter>
    </function>

    <function>
      tag=convert_NormalizeDouble
      caption=NormalizeDouble()
      type=double
      <content>
      Округление числа с плавающей запятой до указанной точности.<br/>
      Рассчитываемые значения StopLoss, TakeProfit, а также значения цены <a href="help://trading_OrderSend">открытия</a> отложенных
      ордеров должны быть нормализованы с точностью, значение которой хранится в предопределенной переменной <a href="help://predefined_variables_Digits">Digits</a>.
      </content>
      <example>
  double var1=0.123456789;
  Print(DoubleToStr(NormalizeDouble(var1,5),8));
  // вывод: 0.12346000
      </example>
      <parameter>
        type=double
        name=value
        description=Величина с плавающей точкой.
      </parameter>
      <parameter>
        type=int
        name=digits
        description=Формат точности, число цифр после десятичной точки (0-8).
      </parameter>
    </function>

    <function>
      tag=convert_StrToDouble
      caption=StrToDouble()
      type=double
      <content>
      Преобразование строки, содержащей символьное представление числа, в число типа double (формат двойной точности с плавающей точкой).
      </content>
      <example>
  double var=StrToDouble(&quot;103.2812&quot;);
      </example>
      <parameter>
        type=string
        name=value
        description=Строка, содержащая символьное представление числа.
      </parameter>
    </function>

    <function>
      tag=convert_StrToInteger
      caption=StrToInteger()
      type=int
      <content>
      Преобразование строки, содержащей символьное представление числа, в число типа int (целое).
      </content>
      <example>
  int var1=StrToInteger(&quot;1024&quot;);
      </example>
      <parameter>
        type=string
        name=value
        description=Строка, содержащая число.
      </parameter>
    </function>

    <function>
      tag=convert_StrToTime
      caption=StrToTime()
      type=datetime
      <content>
      Преобразование строки, содержащей время и/или дату в формате &quot;yyyy.mm.dd [hh:mi]&quot;, в число типа datetime (количество секунд, прошедших с 01.01.1970).
      </content>
      <example>
  datetime var1,var2,var3;
  var1=StrToTime(&quot;2003.8.12 17:35&quot;);
  var2=StrToTime(&quot;17:35&quot;);      // возврат текущей даты с указанным временем
  var3=StrToTime(&quot;2003.8.12&quot;);  // возврат даты с полуночным временем &quot;00:00&quot;
      </example>
      <parameter>
        type=string
        name=value
        description=Строка в формате &quot;yyyy.mm.dd hh:mi&quot;.
      </parameter>
    </function>

    <function>
      tag=convert_TimeToStr
      caption=TimeToStr()
      type=string
      <content>
      Преобразование значения, содержащего время в секундах, прошедшее с 01.01.1970, в строку формата &quot;yyyy.mm.dd hh:mi&quot;.
      </content>
      keywords=;TIME_DATE;TIME_MINUTES;TIME_SECONDS;
      <example>
  string var1=TimeToStr(TimeCurrent(),TIME_DATE|TIME_SECONDS);
      </example>
      <parameter>
        type=datetime
        name=value
        description=Время в секундах от 00:00 1 января 1970.
      </parameter>
      <parameter>
        type=int
        name=mode
        def_value=TIME_DATE|TIME_MINUTES
        <description>
Дополнительный режим вывода данных. Может быть одним или комбинированным флагом:<br/>
TIME_DATE получает результат в форме &quot;yyyy.mm.dd&quot;,<br/>
TIME_MINUTES получает результат в форме &quot;hh:mi&quot;,<br/>
TIME_SECONDS получает результат в форме &quot;hh:mi:ss&quot;.
        </description>
      </parameter>
    </function>
  </group>


  <group>
    tag=customind
    caption=Пользовательские индикаторы
    <content>
    Группа функций, используемых при оформлении пользовательских индикаторов.<br/><br/>
    Данные функции нельзя использовать при написании советников и скриптов.
    </content>
  
    <function>
      tag=customind_IndicatorBuffers
      caption=IndicatorBuffers()
      type=void
      <content>
Распределяет память для буферов, используемых для вычислений пользовательского индикатора.
Количество буферов не может превышать 8 и быть менее значения, указанного в свойстве <a href="help://basis_preprosessor_compilation">indicator_buffers</a>.
Если пользовательский индикатор требует дополнительных буферов для счета, следует использовать эту функцию для указания общего числа буферов.
      </content>
      <example>
#property  indicator_separate_window
#property  indicator_buffers 1
#property  indicator_color1  Silver
//---- параметры индикатора
extern int FastEMA=12;
extern int SlowEMA=26;
extern int SignalSMA=9;
//---- буферы индикатора
double     ind_buffer1[];
double     ind_buffer2[];
double     ind_buffer3[];

//+------------------------------------------------------------------+
//| специальная функция инициализации индикатора                     |
//+------------------------------------------------------------------+
int init()
  {
//---- 2 дополнительных буфера, используемых для расчета.
   IndicatorBuffers(3);
//---- параметры рисования
   SetIndexStyle(0,DRAW_HISTOGRAM,STYLE_SOLID,3);
   SetIndexDrawBegin(0,SignalSMA);
   IndicatorDigits(MarketInfo(Symbol(),MODE_DIGITS)+2);
//---- 3 распределенных буфера индикатора
   SetIndexBuffer(0,ind_buffer1);
   SetIndexBuffer(1,ind_buffer2);
   SetIndexBuffer(2,ind_buffer3);
//---- маркировка именами для DataWindow и подокна (subwindow) индикатора
   IndicatorShortName("OsMA("+FastEMA+","+SlowEMA+","+SignalSMA+")");
//---- инициализация завершена
   return(0);
  }
      </example>
      <parameter>
        type=int
        name=count
        description=Количество расчетных буферов. от indicator_buffers до 8 буферов.
      </parameter>
    </function>

    <function>
      tag=customind_IndicatorCounted
      caption=IndicatorCounted()
      type=int
      <content>
Функция возвращает количество баров, не измененных после последнего вызова индикатора. Большинство подсчитанных баров не нуждается в пересчете.
Функция используется для оптимизации вычислений.<br/><br/>
Замечание: самый последний бар не считается посчитанным, и в большинстве случаев необходимо пересчитывать только его. Однако бывают
пограничные случаи, когда вызов пользовательского индикатора производится из эксперта на первом тике нового бара. Возможна ситуация, что последний
тик предыдущего бара не обработан (по той причине, что в момент прихода этого последнего тика <a href="help://runtime_start">обрабатывался</a> предпоследний тик), и пользовательский
индикатор не был вызван и поэтому не был рассчитан. Чтобы избежать в такой ситуации ошибок расчета индикатора, функция IndicatorCounted() возвращает
реально посчитанное количество баров минус один.
      </content>
      <example>
  int start()
    {
     int limit;
     int counted_bars=IndicatorCounted();
  //---- последний посчитанный бар будет пересчитан
     if(counted_bars&gt;0) counted_bars--;
     limit=Bars-counted_bars;
  //---- основной цикл
     for(int i=0; i&lt;limit; i++)
       {
        //---- ma_shift присваивается 0, потому что SetIndexShift, вызываемый выше
        ExtBlueBuffer[i]=iMA(NULL,0,JawsPeriod,0,MODE_SMMA,PRICE_MEDIAN,i);
        ExtRedBuffer[i]=iMA(NULL,0,TeethPeriod,0,MODE_SMMA,PRICE_MEDIAN,i);
        ExtLimeBuffer[i]=iMA(NULL,0,LipsPeriod,0,MODE_SMMA,PRICE_MEDIAN,i);
       }
  //----
     return(0);
    }
      </example>
    </function>

    <function>
      tag=customind_IndicatorDigits
      caption=IndicatorDigits()
      type=void
      <content>
      Установка формата точности (количество знаков после десятичной точки) для визуализации значений индикатора. 
      По умолчанию используется <a href="help://predefined_variables_Digits">точность цены</a> финансового инструмента, к графику которого присоединен индикатор.
      </content>
      <example>
int init()
  {
//---- 2 дополнительных буфера используются для подсчета.
   IndicatorBuffers(3);
//---- настройка параметров отрисовки
   SetIndexStyle(0,DRAW_HISTOGRAM,STYLE_SOLID,3);
   SetIndexDrawBegin(0,SignalSMA);
   IndicatorDigits(Digits+2);
//---- 3 распределенных буферов индикатора
   SetIndexBuffer(0,ind_buffer1);
   SetIndexBuffer(1,ind_buffer2);
   SetIndexBuffer(2,ind_buffer3);
//---- "короткое имя" для DataWindow и подокна индикатора
   IndicatorShortName("OsMA("+FastEMA+","+SlowEMA+","+SignalSMA+")");
//---- инициализация сделана
   return(0);
  }
      </example>
      <parameter>
        type=int
        name=digits
        description=Формат точности, число цифр после десятичной точки.
      </parameter>
    </function>

    <function>
      tag=customind_IndicatorShortName
      caption=IndicatorShortName()
      type=void
      <content>
      Установка &quot;короткого&quot; имени пользовательского индикатора для отображения в подокне индикатора и в окне DataWindow.
      </content>
      <example>
int init()
  {
//---- 2 дополнительных буфера используются для подсчета.
   IndicatorBuffers(3);
//---- настройка параметров отрисовки
   SetIndexStyle(0,DRAW_HISTOGRAM,STYLE_SOLID,3);
   SetIndexDrawBegin(0,SignalSMA);
   IndicatorDigits(Digits+2);
//---- 3 распределенных буферов индикатора
   SetIndexBuffer(0,ind_buffer1);
   SetIndexBuffer(1,ind_buffer2);
   SetIndexBuffer(2,ind_buffer3);
//---- "короткое имя" для DataWindow и подокна индикатора
   IndicatorShortName("OsMA("+FastEMA+","+SlowEMA+","+SignalSMA+")");
//---- инициализация сделана
   return(0);
  }
      </example>
      <parameter>
        type=string
        name=name
        description=Новое короткое имя.
      </parameter>
    </function>

    <function>
      tag=customind_SetIndexArrow
      caption=SetIndexArrow()
      type=void
      <content>
      Назначение значка для линии индикаторов, имеющей стиль <a href="help://constants_drawstyles">DRAW_ARROW</a>.<br/>
      Нельзя использовать <a href="help://constants_arrows">коды стрелок</a> вне диапазона 33-255.
      </content>
      <example>
int init()
  {
//---- 2 распределенных буфера индикатора  
    SetIndexBuffer(0,ExtUppperBuffer);
    SetIndexBuffer(1,ExtLowerBuffer);   
//---- настройка параметров отрисовки
    SetIndexStyle(0,DRAW_ARROW);
    SetIndexArrow(0,217);
    SetIndexStyle(1,DRAW_ARROW);
    SetIndexArrow(1,218);
//---- отображение в DataWindow
    SetIndexLabel(0,"Fractal Up");
    SetIndexLabel(1,"Fractal Down");
//---- инициализация сделана
   return(0);
  }
      </example>
      <parameter>
        type=int
        name=index
        description=Порядковый номер линии. Должен быть от 0 до 7.
      </parameter>
      <parameter>
        type=int
        name=code
        description=Код символа из шрифта <a href="help://constants_wingdings">Wingdings</a> или одним из <a href="help://constants_arrows">предопределенных стрелок</a>.
      </parameter>
    </function>

    <function>
      tag=customind_SetIndexBuffer
      caption=SetIndexBuffer()
      type=bool
      <content>
Связывает переменную-массив, объявленный на глобальном уровне, с предопределенным буфером пользовательского индикатора.
Количество буферов, необходимых для расчета индикатора, задается с помощью функции <a href="help://customind_IndicatorBuffers">IndicatorBuffers()</a> и не может быть больше 8.
В случае успешного связывания возвращается TRUE, иначе FALSE.
Чтобы получить расширенные сведения об ошибке, следует вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.
     </content>
      <example>
  double ExtBufferSilver[];
  int init()
    {
      SetIndexBuffer(0, ExtBufferSilver); // буфер для первой линии
      // ...
    }
      </example>
      <parameter>
        type=int
        name=index
        description=Порядковый номер линии. Должен быть от 0 до 7.
      </parameter>
      <parameter>
        type=double
        name=<nobr>array[]</nobr>
        description=Ссылка на массив, который будет связан с расчетным буфером.
      </parameter>
    </function>

    <function>
      tag=customind_SetIndexDrawBegin
      caption=SetIndexDrawBegin()
      type=void
      <content>
Установка порядкового номера бара от начала данных, с которого должна начинаться отрисовка указанной линии индикатора.
Отрисовка индикатора производится слева направо. Значения индикаторного массива, находящиеся левее указанного бара, не будут рисоваться
на графике и отображаться в окне DataWindow. По умолчанию устанавливается значение 0.
      </content>
      <example>
int init()
  {
//---- 2 дополнительных буфера используются для подсчета.
   IndicatorBuffers(3);
//---- настройка параметров рисунка
   SetIndexStyle(0,DRAW_HISTOGRAM,STYLE_SOLID,3);
   SetIndexDrawBegin(0,SignalSMA);
   IndicatorDigits(Digits+2);
//---- 3 распределенных буферов индикатора
   SetIndexBuffer(0,ind_buffer1);
   SetIndexBuffer(1,ind_buffer2);
   SetIndexBuffer(2,ind_buffer3);
//---- "короткое имя" для DataWindow и подокна индикатора
   IndicatorShortName("OsMA("+FastEMA+","+SlowEMA+","+SignalSMA+")");
//---- инициализация сделана
   return(0);
  }
      </example>
      <parameter>
        type=int
        name=index
        description=Порядковый номер линии. Должен быть от 0 до 7.
      </parameter>
      <parameter>
        type=int
        name=begin
        description=Номер позиции начала отрисовки линии индикатора.
      </parameter>
    </function>

    <function>
      tag=customind_SetIndexEmptyValue
      caption=SetIndexEmptyValue()
      type=void
      <content>
Устанавливает значение пустой величины для линии индикатора.
Пустые значения не рисуются и не показываются в DataWindow.
По умолчанию значение пустой величины - EMPTY_VALUE.
      </content>
      <example>
int init()
  {
//---- 2 распределенных буфера индикатора  
    SetIndexBuffer(0,ExtUppperBuffer);
    SetIndexBuffer(1,ExtLowerBuffer);   
//---- настройка параметров отрисовки
    SetIndexStyle(0,DRAW_ARROW);
    SetIndexArrow(0,217);
    SetIndexStyle(1,DRAW_ARROW);
    SetIndexArrow(1,218);
//---- значение 0 отображаться не будет
    SetIndexEmptyValue(0,0.0);
    SetIndexEmptyValue(1,0.0);
//---- отображение в DataWindow
    SetIndexLabel(0,"Fractal Up");
    SetIndexLabel(1,"Fractal Down");
//---- инициализация сделана
   return(0);
  }
      </example>
      <parameter>
        type=int
        name=index
        description=Порядковый номер линии. Должен быть от 0 до 7.
      </parameter>
      <parameter>
        type=double
        name=value
        description=Новое &quot;пустое&quot; значение.
      </parameter>
    </function>

    <function>
      tag=customind_SetIndexLabel
      caption=SetIndexLabel()
      type=void
      <content>
      Установка имени линии индикатора для отображения информации в окне DataWindow и всплывающей подсказке.
      </content>
      <example>
//+------------------------------------------------------------------+
//| Функция инициализации Ichimoku Kinko Hyo                       |
//+------------------------------------------------------------------+
int init()
  {
//---- линия Tenkan Sen
   SetIndexStyle(0,DRAW_LINE);
   SetIndexBuffer(0,Tenkan_Buffer);
   SetIndexDrawBegin(0,Tenkan-1);
   SetIndexLabel(0,"Tenkan Sen");
//---- линия Kijun Sen
   SetIndexStyle(1,DRAW_LINE);
   SetIndexBuffer(1,Kijun_Buffer);
   SetIndexDrawBegin(1,Kijun-1);
   SetIndexLabel(1,"Kijun Sen");
//---- гистограмма облака Kumo Up
   a_begin=Kijun; if(a_begin&lt;Tenkan) a_begin=Tenkan;
   SetIndexStyle(2,DRAW_HISTOGRAM,STYLE_DOT);
   SetIndexBuffer(2,SpanA_Buffer);
   SetIndexDrawBegin(2,Kijun+a_begin-1);
   SetIndexShift(2,Kijun);
//---- в DataWindow не показываем, так как есть ограничивающая линия Senkou Span A
   SetIndexLabel(2,NULL);
//---- линия Senkou Span A
   SetIndexStyle(5,DRAW_LINE,STYLE_DOT);
   SetIndexBuffer(5,SpanA2_Buffer);
   SetIndexDrawBegin(5,Kijun+a_begin-1);
   SetIndexShift(5,Kijun);
   SetIndexLabel(5,"Senkou Span A");
//---- гистограмма облака Kumo Down
   SetIndexStyle(3,DRAW_HISTOGRAM,STYLE_DOT);
   SetIndexBuffer(3,SpanB_Buffer);
   SetIndexDrawBegin(3,Kijun+Senkou-1);
   SetIndexShift(3,Kijun);
//---- в DataWindow не показываем, так как есть ограничивающая линия Senkou Span B
   SetIndexLabel(3,NULL);
//---- линия Senkou Span B
   SetIndexStyle(6,DRAW_LINE,STYLE_DOT);
   SetIndexBuffer(6,SpanB2_Buffer);
   SetIndexDrawBegin(6,Kijun+Senkou-1);
   SetIndexShift(6,Kijun);
   SetIndexLabel(6,"Senkou Span B");
//---- линия Chinkou Span
   SetIndexStyle(4,DRAW_LINE);
   SetIndexBuffer(4,Chinkou_Buffer);
   SetIndexShift(4,-Kijun);
   SetIndexLabel(4,"Chinkou Span");
//----
   return(0);
  }
      </example>
      <parameter>
        type=int
        name=index
        description=Порядковый номер линии индикатора. Должен быть от 0 до 7.
      </parameter>
      <parameter>
        type=string
        name=text
        description=Текст описания линии индикатора. NULL означает, что значение этой линии не показывается в DataWindow.
      </parameter>
    </function>

    <function>
      tag=customind_SetIndexShift
      caption=SetIndexShift()
      type=void
      <content>
Установка смещения линии индикатора относительно начала графика. При положительном значении изображение линии смещается вправо, при отрицательном - влево.
Т.е. значение, рассчитанное на текущем баре, рисуется с указанным смещением относительно текущего бара.
      </content>
      <example>
//+------------------------------------------------------------------+
//| Функция инициализации Аллигатора                                 |
//+------------------------------------------------------------------+
int init()
  {
//---- смещение линий баланса относительно начала графика
   SetIndexShift(0,JawsShift);
   SetIndexShift(1,TeethShift);
   SetIndexShift(2,LipsShift);
//---- начала линий баланса должны быть пропущены при отрисовке
   SetIndexDrawBegin(0,JawsShift+JawsPeriod);
   SetIndexDrawBegin(1,TeethShift+TeethPeriod);
   SetIndexDrawBegin(2,LipsShift+LipsPeriod);
//---- 3 распределенных буфера индикатора
   SetIndexBuffer(0,ExtBlueBuffer);
   SetIndexBuffer(1,ExtRedBuffer);
   SetIndexBuffer(2,ExtLimeBuffer);
//---- установка стилей линий
   SetIndexStyle(0,DRAW_LINE);
   SetIndexStyle(1,DRAW_LINE);
   SetIndexStyle(2,DRAW_LINE);
//---- имена линий для отображения в DataWindow
   SetIndexLabel(0,"Gator Jaws");
   SetIndexLabel(1,"Gator Teeth");
   SetIndexLabel(2,"Gator Lips");
//---- инициализация сделана
   return(0);
  }
      </example>
      <parameter>
        type=int
        name=index
        description=Порядковый номер линии. Должно быть от 0 до 7.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Величина смещения в барах.
      </parameter>
    </function>

    <function>
      tag=customind_SetIndexStyle
      caption=SetIndexStyle()
      type=void
      <content>
      Устанавливает новый тип, стиль, ширину и цвет для указанной линии индикатора.
      </content>
      <example>
  SetIndexStyle(3, DRAW_LINE, EMPTY, 2, Red);
      </example>
      <parameter>
        type=int
        name=index
        description=Порядковый номер линии. Должен быть от 0 до 7.
      </parameter>
      <parameter>
        type=int
        name=type
        <description>
Стиль отрисовки линии индикатора. Может быть одним из перечисленных <a href="help://constants_drawstyles">стилей отрисовки линии</a>.
        </description>
      </parameter>
      <parameter>
        type=int
        name=style
        def_value=EMPTY
        <description>
Стиль линии. Используется для линий толщиной в 1 пиксель.
 Может быть одним из перечисленных <a href="help://constants_drawstyles">стилей линии</a>.
 Пустое значение (EMPTY) указывает, что стиль не будет изменен.
        </description>
      </parameter>
      <parameter>
        type=int
        name=width
        def_value=EMPTY
        <description>
Ширина линии. Допустимые значения - 1,2,3,4,5. Пустое значение (EMPTY) указывает, что ширина не будет изменена.
        </description>
      </parameter>
      <parameter>
        type=color
        name=clr
        def_value=CLR_NONE
        description=Цвет линии. Отсутствие параметра означает, что цвет не будет изменен.
      </parameter>
    </function>

    <function>
      tag=customind_SetLevelStyle
      caption=SetLevelStyle()
      type=void
      <content>
Устанавливает новый стиль, ширину и цвет для горизонтальных уровней индикатора, выводимого в отдельное окно.
      </content>
      <example>
//---- уровни в виде толстой красной линии
   SetLevelStyle(STYLE_SOLID,2,Red)
      </example>
      <parameter>
        type=int
        name=draw_style
        <description>
Стиль линии. Может быть одним из перечисленных <a href="help://constants_drawstyles">стилей линии</a>. Пустое значение (EMPTY) указывает, что стиль не будет изменен.
        </description>
      </parameter>
      <parameter>
        type=int
        name=line_width
        <description>
Ширина линии. Допустимые значения - 1,2,3,4,5. Пустое значение (EMPTY) указывает, что ширина не будет изменена.
        </description>
      </parameter>
      <parameter>
        type=color
        name=clr
        def_value=CLR_NONE
        description=Цвет линии. Пустое значение CLR_NONE указывает, что цвет не будет изменен.
      </parameter>
    </function>

    <function>
      tag=customind_SetLevelValue
      caption=SetLevelValue()
      type=void
      <content>
      Устанавливает значение для указанного горизонтального уровня индикатора, выводимого в отдельное окно.
      </content>
      <example>
   SetLevelValue(1,3.14);
      </example>
      <parameter>
        type=int
        name=level
        description=Номер уровня (0-31).
      </parameter>
      <parameter>
        type=double
        name=value
        description=Значение для указанного уровня.
      </parameter>
    </function>
  </group>


  <group>
    tag=dateandtime
    caption=Дата и время
    <content>
    Группа функций, обеспечивающих работу с данными типа datetime (целое число, представляющее собой количество секунд, прошедших с 0 часов 1 января 1970 года).
    </content>

    <function>
      tag=dateandtime_Day
      caption=Day()
      type=int
      <content>
      Возвращает текущий день месяца, т.е день месяца последнего известного времени сервера.<br/>
      Замечание: при тестировании последнее известное время сервера моделируется.
      </content>
      <example>
  if(Day()&lt;5) return(0);
      </example>
    </function>

    <function>
      tag=dateandtime_DayOfWeek
      caption=DayOfWeek()
      type=int
      <content>
      Возвращает порядковый номер дня недели (воскресенье-0,1,2,3,4,5,6) последнего известного времени сервера.<br/>
      Замечание: при тестировании последнее известное время сервера моделируется.
      </content>
      <example>
  // не работает в выходные дни.
  if(DayOfWeek()==0 || DayOfWeek()==6) return(0);
      </example>
    </function>

    <function>
      tag=dateandtime_DayOfYear
      caption=DayOfYear()
      type=int
      <content>
      Возвращает текущий день года (1-1 января,..,365(6) - 31 декабря), т.е день года последнего известного времени сервера.<br/>
      Замечание: при тестировании последнее известное время сервера моделируется.
      </content>
      <example>
  if(DayOfYear()==245)
    return(true);
      </example>
    </function>

    <function>
      tag=dateandtime_Hour
      caption=Hour()
      type=int
      <content>
      Возвращает текущий час (0,1,2,..23) последнего известного серверного времени на момент старта программы (в процессе выполнения программы это значение не меняется).<br/>
      Замечание: при тестировании последнее известное время сервера моделируется.
      </content>
      <example>
  bool is_siesta=false;
  if(Hour()&gt;=12 || Hour()&lt;17)
     is_siesta=true;
      </example>
    </function>

    <function>
      tag=dateandtime_Minute
      caption=Minute()
      type=int
      <content>
      Возвращает текущую минуту (0,1,2,..59) последнего известного серверного времени на момент старта программы (в процессе выполнения программы это значение не меняется).<br/>
      Замечание: при тестировании последнее известное время сервера моделируется.
      </content>
      <example>
  if(Minute()&lt;=15)
    return("first quarter");
      </example>
    </function>

    <function>
      tag=dateandtime_Month
      caption=Month()
      type=int
      <content>
      Возвращает номер текущего месяца (1-Январь,2,3,4,5,6,7,8,9,10,11,12), т.е. номер месяца последнего известного времени сервера.<br/>
      Замечание: при тестировании последнее известное время сервера моделируется.
      </content>
      <example>
  if(Month()&lt;=5)
    return(&quot;первое полугодие&quot;);
      </example>
    </function>

    <function>
      tag=dateandtime_Seconds
      caption=Seconds()
      type=int
      <content>
      Возвращает количество секунд, прошедших с начала текущей минуты последнего известного серверного времени на момент старта программы (в процессе выполнения программы это значение не меняется).<br/>
      Замечание: при тестировании последнее известное время сервера моделируется.
      </content>
      <example>
  if(Seconds()&lt;=15)
    return(0);
      </example>
    </function>

    <function>
      tag=dateandtime_TimeCurrent
      caption=TimeCurrent()
      type=datetime
      <content>
      Возвращает последнее известное время сервера (время прихода последней котировки) в виде количества секунд, прошедших после 00:00 1 января 1970 года.<br/><br/>
      Замечание: при тестировании последнее известное время сервера моделируется.
      </content>
      <example>
  if(TimeCurrent()-OrderOpenTime()&lt;360) return(0);
      </example>
    </function>

    <function>
      tag=dateandtime_TimeDay
      caption=TimeDay()
      type=int
      <content>
      Возвращает день месяца (1 - 31) для указанной даты.
      </content>
      <example>
  int day=TimeDay(D'2003.12.31');
  // день 31
      </example>
      <parameter>
        type=datetime
        name=date
        description=Дата, представленная в виде количества секунд, прошедших после 00:00 1 января 1970 года.
      </parameter>
    </function>

    <function>
      tag=dateandtime_TimeDayOfWeek
      caption=TimeDayOfWeek()
      type=int
      <content>
      Возвращает день недели (0-Воскресенье,1,2,3,4,5,6) для указанной даты.
      </content>
      <example>
  int weekday=TimeDayOfWeek(D'2004.11.2');
  // день 2 - вторник
      </example>
      <parameter>
        type=datetime
        name=date
        description=Дата, представленная в виде количества секунд, прошедших после 00:00 1 января 1970 года.
      </parameter>
    </function>

    <function>
      tag=dateandtime_TimeDayOfYear
      caption=TimeDayOfYear()
      type=int
      <content>
      Возвращает день  (1 - 1 января,..,365(6) - 31 декабря) года для указанной даты.
      </content>
      <example>
  int day=TimeDayOfYear(TimeCurrent());
      </example>
      <parameter>
        type=datetime
        name=date
        description=Дата, представленная в виде количества секунд, прошедших после 00:00 1 января 1970 года.
      </parameter>
    </function>

    <function>
      tag=dateandtime_TimeHour
      caption=TimeHour()
      type=int
      <content>
      Возвращает час для указанного времени.
      </content>
    <example>
  int h=TimeHour(TimeCurrent());
      </example>
      <parameter>
        type=datetime
        name=time
        description=Дата, представленная в виде количества секунд, прошедших после 00:00 1 января 1970 года.
      </parameter>
    </function>

    <function>
      tag=dateandtime_TimeLocal
      caption=TimeLocal()
      type=datetime
      <content>
      Возвращает локальное компьютерное время в виде количества секунд, прошедших после 00:00 1 января 1970 года.<br/>
      Замечание: при тестировании локальное время моделируется и совпадает с моделированным последним известным временем сервера.
      </content>
      <example>
  if(TimeLocal()-OrderOpenTime()&lt;360) return(0);
      </example>
    </function>

    <function>
      tag=dateandtime_TimeMinute
      caption=TimeMinute()
      type=int
      <content>
      Возвращает минуты для указанного времени.
      </content>
      <example>
  int m=TimeMinute(TimeCurrent());
      </example>
      <parameter>
        type=datetime
        name=time
        description=Дата, представленная в виде количества секунд, прошедших после 00:00 1 января 1970 года.
      </parameter>
    </function>

    <function>
      tag=dateandtime_TimeMonth
      caption=TimeMonth()
      type=int
      <content>
      Возвращает номер месяца для указанного времени (1-Январь,2,3,4,5,6,7,8,9,10,11,12).
      </content>
      <example>
  int m=TimeMonth(TimeCurrent());
      </example>
      <parameter>
        type=datetime
        name=time
        description=Дата, представленная в виде количества секунд, прошедших после 00:00 1 января 1970 года.
      </parameter>
    </function>

    <function>
      tag=dateandtime_TimeSeconds
      caption=TimeSeconds()
      type=int
      <content>
      Возвращает количество секунд, прошедших с начала минуты для указанного времени.
      </content>
      <example>
  int m=TimeSeconds(TimeCurrent());
      </example>
      <parameter>
        type=datetime
        name=time
        description=Дата, представленная в виде количества секунд, прошедших после 00:00 1 января 1970 года.
      </parameter>
    </function>

    <function>
      tag=dateandtime_TimeYear
      caption=TimeYear()
      type=int
      <content>
      Возвращает год для указанной даты. Возвращаемая величина может быть в диапазоне 1970-2037.
      </content>
      <example>
  int y=TimeYear(TimeCurrent());
      </example>
      <parameter>
        type=datetime
        name=time
        description=Дата, представленная в виде количества секунд, прошедших после 00:00 1 января 1970 года.
      </parameter>
    </function>

    <function>
      tag=dateandtime_Year
      caption=Year()
      type=int
      <content>
      Возвращает текущий год, т.е. год последнего известного времени сервера.<br/>
      Замечание: при тестировании последнее известное время сервера моделируется.
      </content>
      <example>
  // возврат, если дата находится в диапазоне от 1 января до 30 апреля 2006 года.
  if(Year()==2006 &amp;&amp; Month()&lt;5)
    return(0);
      </example>
    </function>
  </group>


  <group>
    tag=files
    caption=Файловые операции
    <content>
    Группа функций для работы с файлами.<br/><br/>
    Существует три каталога (с подкаталогами), в которых могут располагаться рабочие файлы:
    <ul>
      <li>/HISTORY/&lt;текущий брокер&gt; - специально для функции FileOpenHistory;</li>
      <li>/EXPERTS/FILES - общий случай;</li>
      <li>/TESTER/FILES - специально для тестирования.</li>
    </ul>
    Работа с файлами из других каталогов пресекается.
    </content>

    <function>
      tag=files_FileClose
      caption=FileClose()
      type=void
      <content>
      Закрытие файла, ранее открытого функцией <a href="help://files_FileOpen">FileOpen()</a>.
      </content>
      <example>
  int handle=FileOpen("имя файла", FILE_CSV|FILE_READ);
  if(handle&gt;0)
    {
     // работает с файлом ...
     FileClose(handle);
    }
      </example>
      <parameter>
        type=int
        name=handle
        description=Файловый описатель, возвращаемый функцией FileOpen().
      </parameter>
    </function>

    <function>
      tag=files_FileDelete
      caption=FileDelete()
      type=void
      <content>
Удаление указанного файла.
Чтобы получить информацию об ошибке, необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.<br/>
Файлы могут быть удалены только в том случае, если они расположены в папке <em>каталог_терминала\experts\files</em>
(<em>каталог_терминала\tester\files</em> в случае тестирования эксперта) или ее подпапках.
      </content>
      <example>
  // файл my_table.csv будет удален из папки terminal_dir\experts\files
  int lastError;
  FileDelete("my_table.csv");
  lastError=GetLastError();
  if(lastError!=ERR_NOERROR)
    {
     Print(&quot;ошибка (&quot;,lastError,&quot;) при удалении файла my_table.csv&quot;);
     return(0);
    }
      </example>
      <parameter>
        type=string
        name=filename
        description=Имя файла.
      </parameter>
    </function>

    <function>
      tag=files_FileFlush
      caption=FileFlush()
      type=void
      <content>
Сброс на диск всех данных, оставшихся в файловом буфере ввода-вывода.<br/>
Замечания: функцию FileFlush() необходимо вызывать между операциями чтения из файла и записи в файл.<br/>
При закрытии файла данные сбрасываются на диск автоматически, поэтому нет необходимости вызывать функцию FileFlush() перед вызовом
функции <a href="help://files_FileClose">FileClose()</a>.
      </content>
      <example>
  int bars_count=Bars;
  int handle=FileOpen(&quot;mydat.csv&quot;,FILE_CSV|FILE_WRITE);
  if(handle&gt;0)
    {
     FileWrite(handle, &quot;#&quot;,&quot;OPEN&quot;,&quot;CLOSE&quot;,&quot;HIGH&quot;,&quot;LOW&quot;);
     for(int i=0;i&lt;bars_count;i++)
       FileWrite(handle, i+1,Open[i],Close[i],High[i], Low[i]);
     FileFlush(handle);
     ...
     for(int i=0;i&lt;bars_count;i++)
       FileWrite(handle, i+1,Open[i],Close[i],High[i], Low[i]);
     FileClose(handle);
    }
      </example>
      <parameter>
        type=int
        name=handle
        description=Файловый описатель, возвращаемый функцией FileOpen().
      </parameter>
    </function>

    <function>
      tag=files_FileIsEnding
      caption=FileIsEnding()
      type=bool
      <content>
Возвращает TRUE, если файловый указатель находится в конце файла, иначе возвращает FALSE.<br/>
Чтобы получить информацию об ошибке, необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.
В случае достижения конца файла в процессе чтения функция <a href="help://check_GetLastError">GetLastError()</a>
вернет <a href="help://constants_errors">ошибку</a> ERR_END_OF_FILE (4099).
      </content>
      <example>
  if(FileIsEnding(h1))
    {
     FileClose(h1);
     return(false);
    }
      </example>
      <parameter>
        type=int
        name=handle
        description=Файловый описатель, возвращаемый функцией FileOpen().
      </parameter>
    </function>

    <function>
      tag=files_FileIsLineEnding
      caption=FileIsLineEnding()
      type=bool
      <content>
Возвращает TRUE, если файловый указатель находится в конце строки файла формата CSV, иначе возвращает FALSE.
Чтобы получить информацию об ошибке, необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.
      </content>
      <example>
  if(FileIsLineEnding(h1))
    {
     FileClose(h1);
     return(false);
    }
      </example>
      <parameter>
        type=int
        name=handle
        description=Файловый описатель, возвращаемый функцией FileOpen().
      </parameter>
    </function>

    <function>
      tag=files_FileOpen
      caption=FileOpen()
      type=int
      keywords=;FILE_BIN;FILE_CSV;FILE_READ;FILE_WRITE;
      <content>
Открывает Файл для ввода и/или вывода. Возвращает файловый описатель открытого файла или -1 в случае неудачи.
Чтобы получить дополнительную информацию об ошибке, необходимо вызвать функцию <a href="help://check_GetLastError"> GetLastError()</a>.<br/>
Замечания: файлы могут открываться только в папке <em>каталог_терминала\experts\files</em> (<em>каталог_терминала\tester\files</em> в случае тестирования эксперта) или ее подпапках.<br/>
Нельзя одновременно использовать режимы FILE_BIN и FILE_CSV.<br/>
Если FILE_WRITE не комбинируется с FILE_READ, то будет открыт файл нулевой длины. Даже если до открытия в файле были данные, то они будут уничтожены.
Если необходимо дописывать данные в существующий файл, то его нужно открывать, используя комбинацию FILE_READ | FILE_WRITE.<br/>
Если FILE_READ не комбинируется с FILE_WRITE, то файл будет открыт только в том случае, если он уже существует. Если файл не существует, то создать его
можно, используя режим FILE_WRITE.<br/>
Одновременно может быть открыто не более 32 файлов в пределах одного исполняемого модуля. Описатели файлов, открытых в одном модуле, нельзя передавать в
другие модули (библиотеки).
      </content>
      <example>
  int handle;
  handle=FileOpen(&quot;my_data.csv&quot;,FILE_CSV|FILE_READ,';');
  if(handle&lt;1)
    {
     Print(&quot;Файл my_data.dat не обнаружен, последняя ошибка &quot;, GetLastError());
     return(false);
    }
      </example>
      <parameter>
        type=string
        name=filename
        description=Имя файла.
      </parameter>
      <parameter>
        type=int
        name=mode
        description=Способ открытия. Это может быть одна величина или их комбинация: FILE_BIN, FILE_CSV, FILE_READ, FILE_WRITE.
      </parameter>
      <parameter>
        type=int
        name=delimiter
        def_value=';'
        description=Знак разделителя для csv-файлов. По умолчанию применяется символ ';'.
      </parameter>
    </function>

    <function>
      tag=files_FileOpenHistory
      caption=FileOpenHistory()
      type=int
      <content>
Открывает файл в текущей папке истории (<em>каталог_терминала\history\server_name</em>) или ее подпапках. Возвращает описатель файла или -1 в случае неудачи.
Для получения дополнительной информации об ошибке необходимо вызвать функцию <a href="help://check_GetLastError"> GetLastError()</a>.<br/>
Замечания: клиентский терминал может подключаться к серверам разных брокерских компаний. Исторические данные (файлы HST) каждой брокерской компании хранятся
в соответствующей подпапке папки истории <em>каталог_терминала\history</em>.<br/>
Функция может быть полезна для формирования собственных исторических данных нестандартного символа и/или периода. Файл, сформированный в папке
истории может быть открыт автономно, для его графика не требуется подкачка данных.
      </content>
      <example>
  int handle=FileOpenHistory(&quot;USDX240.HST&quot;,FILE_BIN|FILE_WRITE);
  if(handle&lt;1)
    {
     Print(&quot;Не может создать файл USDX240.HST&quot;);
     return(false);
    }
  // работа с файлом
  // ...
  FileClose(handle);
      </example>
      <parameter>
        type=string
        name=filename
        description=Имя файла.
      </parameter>
      <parameter>
        type=int
        name=mode
        description=Режим открытия. Это может быть одна величина или их комбинация: FILE_BIN, FILE_CSV, FILE_READ, FILE_WRITE.
      </parameter>
      <parameter>
        type=int
        name=delimiter
        def_value=';'
        description=Знак разделителя для csv-файлов. По умолчанию применяется символ ';'.
      </parameter>
    </function>

    <function>
      tag=files_FileReadArray
      caption=FileReadArray()
      type=int
      <content>
Функция читает указанное число элементов из двоичного файла в массив. Перед чтением данных массив должен быть достаточного размера.
Функция возвращает количество фактически прочитанных элементов.<br/>
Для того чтобы получить информацию об ошибке, необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.<br/>
      </content>
      <example>
  int handle;
  double varray[10];
  handle=FileOpen(&quot;filename.dat&quot;, FILE_BIN|FILE_READ);
  if(handle&gt;0)
    {
     FileReadArray(handle, varray, 0, 10);
     FileClose(handle);
    }
      </example>
      <parameter>
        type=int
        name=handle
        description=Файловый описатель, возвращаемый функцией FileOpen().
      </parameter>
      <parameter>
        type=object&amp;
        name=<nobr>array[]</nobr>
        description=Массив, куда данные будут загружены.
      </parameter>
      <parameter>
        type=int
        name=start
        description=Стартовая позиция для записи в массив.
      </parameter>
      <parameter>
        type=int
        name=count
        description=Количество элементов для чтения.
      </parameter>
    </function>

    <function>
      tag=files_FileReadDouble
      caption=FileReadDouble()
      type=double
      keywords=;DOUBLE_VALUE;FLOAT_VALUE;
      <content>
Функция читает число двойной точности с плавающей точкой (double) из текущей позиции бинарного файла.
Размер числа может быть 8 байтов (double) или 4 байта (float).<br/>
Чтобы получить информацию об ошибке, необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.
      </content>
      <example>
  int handle;
  double value;
  handle=FileOpen(&quot;mydata.dat&quot;,FILE_BIN);
  if(handle&gt;0)
    {
     value=FileReadDouble(handle,DOUBLE_VALUE);
     FileClose(handle);
    }
      </example>
      <parameter>
        type=int
        name=handle
        description=Файловый описатель, возвращаемый функцией FileOpen().
      </parameter>
      <parameter>
        type=int
        name=size
        def_value=DOUBLE_VALUE
        description=Формат числа. Может быть DOUBLE_VALUE (8 байтов) или FLOAT_VALUE (4 байта).
      </parameter>
    </function>

    <function>
      tag=files_FileReadInteger
      caption=FileReadInteger()
      type=int
      <content>
Функция читает целое число из текущей позиции бинарного файла.
Размер целого числа может быть 1, 2 или 4 байта.
Если размер числа не указан, система пытается прочитать как 4-байтовое целое число.<br/>
Чтобы получить информацию об ошибке, необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.
      </content>
      keywords=;CHAR_VALUE;SHORT_VALUE;LONG_VALUE;
      <example>
  int handle;
  int value;
  handle=FileOpen(&quot;mydata.dat&quot;, FILE_BIN|FILE_READ);
  if(handle&gt;0)
    {
     value=FileReadInteger(h1,2);
     FileClose(handle);
    }
      </example>
      <parameter>
        type=int
        name=handle
        description=Файловый описатель, возвращаемый функцией FileOpen().
      </parameter>
      <parameter>
        type=int
        name=size
        def_value=LONG_VALUE
        description=Формата числа. Может быть CHAR_VALUE(1 байт), SHORT_VALUE(2 байта) или LONG_VALUE(4 байта).
      </parameter>
    </function>

    <function>
      tag=files_FileReadNumber
      caption=FileReadNumber()
      type=double
      <content>
Чтение числа с текущей позиции файла CSV до разделителя. Применяется только для файлов CSV.<br/>
Для того чтобы получить информацию об ошибке, необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.
      </content>
      <example>
  int handle;
  int value;
  handle=FileOpen(&quot;filename.csv&quot;, FILE_CSV, '\t');
  if(handle&gt;0)
    {
     value=FileReadNumber(handle);
     FileClose(handle);
    }
      </example>
      <parameter>
        type=int
        name=handle
        description=Файловый описатель, возвращаемый функцией FileOpen().
      </parameter>
    </function>

    <function>
      tag=files_FileReadString
      caption=FileReadString()
      type=string
      <content>
Функция читает строку с текущей позиции файла. Применяется как к CSV, так и к двоичным файлам.
Для текстовых файлов строка будет прочитана до разделителя.
Для бинарных файлов в строку будет прочитано указанное количество символов.<br/>
Чтобы получить информацию об ошибке, необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.
      </content>
      <example>
  int handle;
  string str;
  handle=FileOpen(&quot;filename.csv&quot;, FILE_CSV|FILE_READ);
  if(handle&gt;0)
    {
     str=FileReadString(handle);
     FileClose(handle);
    }
      </example>
      <parameter>
        type=int
        name=handle
        description=Файловый описатель, возвращаемый функцией FileOpen().
      </parameter>
      <parameter>
        type=int
        name=length
        def_value=0
        description=Количество символов для чтения.
      </parameter>
    </function>

    <function>
      tag=files_FileSeek
      caption=FileSeek()
      type=bool
      keywords=;SEEK_CUR;SEEK_SET;SEEK_END;
      <content>
Функция перемещает файловый указатель на новую позицию, которая является смещением в байтах
от начала, конца или текущей позиции файла. Следующее чтение или запись происходят с новой позиции.<br/>
Если перемещение файлового указателя прошло успешно, функция возвращает TRUE, иначе возвращает FALSE.
Чтобы получить информацию об ошибке, необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.
      </content>
      <example>
  int handle=FileOpen(&quot;filename.csv&quot;, FILE_CSV|FILE_READ|FILE_WRITE, ';');
  if(handle&gt;0)
    {
     FileSeek(handle, 0, SEEK_END);
     //---- add data to the end of file
     FileWrite(handle, data1, data2);
     FileClose(handle);
     handle=0;
    }
      </example>
      <parameter>
        type=int
        name=handle
        description=Файловый описатель, возвращаемый функцией FileOpen().
      </parameter>
      <parameter>
        type=int
        name=offset
        description=Смещение в байтах.
      </parameter>
      <parameter>
        type=int
        name=origin
        <description>
Начальное положение. Величина может быть одной из этих констант:<br/>
SEEK_CUR - от текущего положения,<br/>
SEEK_SET - от начала,<br/>
SEEK_END - от конца файла.
        </description>
      </parameter>
    </function>

    <function>
      tag=files_FileSize
      caption=FileSize()
      type=int
      <content>
Функция возвращает размер файла в байтах.<br/>
Чтобы получить информацию об ошибке, необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.
      </content>
      <example>
  int handle;
  int size;
  handle=FileOpen(&quot;my_table.dat&quot;, FILE_BIN|FILE_READ);
  if(handle&gt;0)
    {
     size=FileSize(handle);
     Print(&quot;my_table.dat размер &quot;, size, &quot; bytes&quot;);
     FileClose(handle);
    }
      </example>
      <parameter>
        type=int
        name=handle
        description=Файловый описатель, возвращаемый функцией FileOpen().
      </parameter>
    </function>

    <function>
      tag=files_FileTell
      caption=FileTell()
      type=int
      <content>
Функция возвращает смещение текущей позицию файлового указателя от начала файла.<br/>
Чтобы получить информацию об ошибке, необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.
      </content>
      <example>
  int handle;
  int pos;
  handle=FileOpen(&quot;my_table.dat&quot;, FILE_BIN|FILE_READ);
  // чтение некоторых данных
  pos=FileTell(handle);
  Print(&quot;current position is &quot;, pos);
      </example>
      <parameter>
        type=int
        name=handle
        description=Файловый описатель, возвращаемый функцией FileOpen().
      </parameter>
    </function>

    <function>
      tag=files_FileWrite
      caption=FileWrite()
      type=int
      <content>
Функция предназначена для записи данных в файл CSV, разделитель между данными включается автоматически. После записи в файл добавляется
признак конца строки &quot;\r\n&quot;. При выводе числовые данные преобразуются в текстовый формат (см. функцию <a href="help://common_Print">Print()</a>).<br/>
Возвращает количество записанных символов или отрицательное значение, если происходит ошибка .<br/>
Чтобы получить информацию об ошибке, необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.
      </content>
      <example>
  int handle;
  datetime orderOpen=OrderOpenTime();
  handle=FileOpen(&quot;filename&quot;, FILE_CSV|FILE_WRITE, '\t');
  if(handle&gt;0)
    {
     FileWrite(handle, Close[0], Open[0], High[0], Low[0], TimeToStr(orderOpen));
     FileClose(handle);
    }
      </example>
      <parameter>
        type=int
        name=handle
        description=Файловый описатель, возвращаемый функцией FileOpen().
      </parameter>
      <parameter>
        type=...
        name=
        <description>
Данные, разделенные запятыми. Может быть не больше 63 параметров.<br/>
Данные типов double, int автоматически преобразовываются в строку, данные типов color, datetime и bool воспринимаются как целые
числа (тип int), данные типа string выводятся как есть, без преобразования.<br/>
В качестве параметра нельзя передать массивы, массивы могут быть выведены поэлементно.
        </description>
      </parameter>
    </function>

    <function>
      tag=files_FileWriteArray
      caption=FileWriteArray()
      type=int
      <content>
Функция записывает массив в бинарный файл. Массивы типа int, bool, datetime и color записываются поэлементно как 4-байтовые целые числа.
Массивы типа double записываются поэлементно как 8-байтовые числа c плавающей запятой.
Массивы типа string записываются построчно, после каждой строки автоматически добавляется признак конца строки &quot;\r\n&quot;.<br/>
Возвращает число записанных элементов или отрицательное значение в случае ошибки.<br/>
Чтобы получить информацию об ошибке, необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.
      </content>
      <example>
  int handle;
  double BarOpenValues[10];
  // скопирует первые десять баров в массив
  for(int i=0;i&lt;10; i++)
    BarOpenValues[i]=Open[i];
  // запись массива в файл
  handle=FileOpen(&quot;mydata.dat&quot;, FILE_BIN|FILE_WRITE);
  if(handle&gt;0)
    {
     FileWriteArray(handle, BarOpenValues, 3, 7); // запись последних 7 элементов
     FileClose(handle);
    }
      </example>
      <parameter>
        type=int
        name=handle
        description=Файловый описатель, возвращаемый функцией FileOpen().
      </parameter>
      <parameter>
        type=object
        name=<nobr>array[]</nobr>
        description=Массив для записи.
      </parameter>
      <parameter>
        type=int
        name=start
        description=Начальный индекс в массиве (номер первого записываемого элемента).
      </parameter>
      <parameter>
        type=int
        name=count
        description=Количество записываемых элементов.
      </parameter>
    </function>

    <function>
      tag=files_FileWriteDouble
      caption=FileWriteDouble()
      type=int
      <content>
Функция записывает число с плавающей запятой в двоичный файл.
Если формат задан FLOAT_VALUE, то значение будет записано как 4-байтовое число с плавающей запятой (тип float),
иначе будет записан в 8-байтовом формате с плавающей запятой (тип double).<br/>
Возвращает фактически записанное число байт или отрицательное значение в случае ошибки.<br/>
Для того чтобы получить информацию об ошибке, необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.
      </content>
      <example>
  int handle;
  double var1=0.345;
  handle=FileOpen(&quot;mydata.dat&quot;, FILE_BIN|FILE_WRITE);
  if(handle&lt;1)
    {
     Print(&quot;can't open file error-&quot;,GetLastError());
     return(0);
    }
  FileWriteDouble(h1, var1, DOUBLE_VALUE);
  //...
  FileClose(handle);
      </example>
      <parameter>
        type=int
        name=handle
        description=Файловый описатель, возвращаемый функцией FileOpen().
      </parameter>
      <parameter>
        type=double
        name=value
        description=Значение двойной точности.
      </parameter>
      <parameter>
        type=int
        name=size
        def_value=DOUBLE_VALUE
        <description>
Дополнительный флаг формата. Может быть любой из следующих величин:<br/>
DOUBLE_VALUE (8 байтов, по умолчанию)<br/>
FLOAT_VALUE (4 байта).
        </description>
      </parameter>
    </function>

    <function>
      tag=files_FileWriteInteger
      caption=FileWriteInteger()
      type=int
      <content>
Функция записывает значение целого числа в двоичный файл.
Если размер - SHORT_VALUE, значение будет записано как 2-байтовое целое число (тип short),
если размер - CHAR_VALUE, значение будет записано как 1-байтовое целое число (тип char),
если размер - LONG_VALUE, значение будет записано как 4-байтовое целое число (тип long int).<br/>
Возвращает число фактически записанных байтов или отрицательное значение в случае ошибки.<br/>
Чтобы получить информацию об ошибке, необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.
      </content>
      <example>
  int handle;
  int value=10;
  handle=FileOpen(&quot;filename.dat&quot;, FILE_BIN|FILE_WRITE);
  if(handle&lt;1)
    {
     Print(&quot;can't open file error-&quot;,GetLastError());
     return(0);
    }
  FileWriteInteger(handle, value, SHORT_VALUE);
  //...
  FileClose(handle);
      </example>
      <parameter>
        type=int
        name=handle
        description=Файловый описатель, возвращаемый функцией FileOpen().
      </parameter>
      <parameter>
        type=int
        name=value
        description=Значение для записи.
      </parameter>
      <parameter>
        type=int
        name=size
        def_value=LONG_VALUE
        <description>
Дополнительный флаг формата. Может быть любой из следующих величин:<br/>
CHAR_VALUE (1 байт),<br/>
SHORT_VALUE (2 байта),<br/>
LONG_VALUE (4 байта, по умолчанию).
        </description>
      </parameter>
    </function>

    <function>
      tag=files_FileWriteString
      caption=FileWriteString()
      type=int
      <content>
Функция записывает строку в двоичный файл с текущей позиции.<br/>
Возвращает число фактически записанных байтов или отрицательное значение в случае ошибки.<br/>
Чтобы получить информацию об ошибке, необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.
      </content>
      <example>
  int handle;
  string str=&quot;some string&quot;;
  handle=FileOpen(&quot;filename.bin&quot;, FILE_BIN|FILE_WRITE);
    if(handle&lt;1)
    {
     Print(&quot;can't open file error-&quot;,GetLastError());
     return(0);
    }
  FileWriteString(handle, str, 8);
  FileClose(handle);
      </example>
      <parameter>
        type=int
        name=handle
        description=Файловый описатель, возвращаемый функцией FileOpen().
      </parameter>
      <parameter>
        type=string
        name=value
        description=Записываемая строка.
      </parameter>
      <parameter>
        type=int
        name=size
        description=Длина записываемой строки. Если строка длиннее, чем указанное значение, то она будет усечена. Если строка короче, то она будет добавлена двоичными 0 до указанной длины.
      </parameter>
    </function>
  </group>


  <group>
    tag=globals
    caption=Глобальные переменные
    <content>
    Группа функций, предназначенных для работы с глобальными переменными.<br/><br/>
    Не следует путать глобальные переменные клиентского терминала с <a href="help://basis_variables_global">переменными</a>, объявленными на глобальном
    уровне MQL4-программы.<br/><br/>
    Глобальные переменные существуют в клиентском терминале 4 недели с момента последнего обращения, после этого автоматически уничтожаются.
    Обращением к глобальной переменной считается не только <a href="help://globals_GlobalVariableSet">установка нового значения</a>, но и
    <a href="help://globals_GlobalVariableGet">чтение значения глобальной переменной</a>.<br/><br/>
    Глобальные переменные клиентского терминала доступны одновременно из всех MQL4-программ, запущенных на клиентском терминале.
    </content>

    <function>
      tag=globals_GlobalVariableCheck
      caption=GlobalVariableCheck()
      type=bool
      <content>
Возвращает значение TRUE, если глобальная переменная существует, иначе возвращает FALSE.<br/>
Чтобы получить информацию об ошибке, необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.
      </content>
      <example>
  // контроль переменной перед использованием
  if(!GlobalVariableCheck(&quot;g1&quot;))
    GlobalVariableSet(&quot;g1&quot;,1);
      </example>
      <parameter>
        type=string
        name=name
        description=Имя глобальной переменной.
      </parameter>
    </function>

    <function>
      tag=globals_GlobalVariableDel
      caption=GlobalVariableDel()
      type=bool
      <content>
Удаляет глобальную переменную.
При успешном удалении функция возвращает TRUE, иначе FALSE.
Чтобы получить информацию об ошибке, необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.
      </content>
      <example>
  // удаление глобальной переменной с именем &quot;gvar_1&quot;
  GlobalVariableDel(&quot;gvar_1&quot;);
      </example>
      <parameter>
        type=string
        name=name
        description=Имя глобальной переменной.
      </parameter>
    </function>

    <function>
      tag=globals_GlobalVariableGet
      caption=GlobalVariableGet()
      type=double
      <content>
Возвращает значение существующей глобальной переменной или 0 в случае ошибки.
Чтобы получить информацию об ошибке, необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.
      </content>
      <example>
  double v1=GlobalVariableGet(&quot;g1&quot;);
  //---- проверьте результат запроса функции
  if(GetLastError()!=0) return(false);
  //---- продолжение обработки
      </example>
      <parameter>
        type=string
        name=name
        description=Имя глобальной переменной.
      </parameter>
    </function>

    <function>
      tag=globals_GlobalVariableName
      caption=GlobalVariableName()
      type=string
      <content>
Функция возвращает имя глобальной переменной по порядковому номеру в списке глобальных переменных.
Чтобы получить информацию об ошибке необходимо вызвать функцию функцию <a href="help://check_GetLastError">GetLastError()</a>.
     </content>
      <example>
  int    var_total=GlobalVariablesTotal();
  string name;
  for(int i=0;i&lt;var_total;i++)
    {
     name=GlobalVariableName(i);
     Print(i,&quot;: Имя глобальной переменной - &quot;,name);
    }
      </example>
      <parameter>
        type=int
        name=index
        description=Порядковый номер в списке глобальных переменных. Должен быть большим или равным 0 и меньшим, чем <a href="help://globals_GlobalVariablesTotal">GlobalVariablesTotal()</a>.
      </parameter>
    </function>

    <function>
      tag=globals_GlobalVariableSet
      caption=GlobalVariableSet()
      type=datetime
      <content>
Устанавливает новое значение глобальной переменной. Если переменная не существует, то система создает новую глобальную переменную.
При успешном выполнении функция возвращает время последнего доступа, иначе 0.
Чтобы получить информацию об ошибке, необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.
      </content>
      <example>
  //---- попытка устанавливать новое значение
  if(GlobalVariableSet(&quot;BarsTotal&quot;,Bars)==0)
    return(false);
  //---- продолжение обработки
      </example>
      <parameter>
        type=string
        name=name
        description=Имя глобальной переменной.
      </parameter>
      <parameter>
        type=double
        name=value
        description=Новое числовое значение.
      </parameter>
    </function>

    <function>
      tag=globals_GlobalVariableSetOnCondition
      caption=GlobalVariableSetOnCondition()
      type=bool
      <content>
Устанавливает новое значение существующей глобальной переменной, если текущее значение переменной
равно значению третьего параметра <i>check_value</i>. Если переменной не существует, функция сгенерирует <a href="help://constants_errors">ошибку</a> ERR_GLOBAL_VARIABLE_NOT_FOUND (4058) и вернет FALSE.
При успешном выполнении функция возвращает TRUE, иначе FALSE. Для того, чтобы получить информацию об ошибке, необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.
Если текущее значение глобальной переменной отличается от <i>check_value</i>, функция вернет FALSE.<br/>
Функция обеспечивает атомарный доступ к глобальной переменной, поэтому она может быть использована
для организации семафора при взаимодействии нескольких одновременно работающих экспертов в пределах одного клиентского терминала.
      </content>
      <example>
  int init()
    {
     //---- создание глобальной переменной
     GlobalVariableSet(&quot;DATAFILE_SEM&quot;,0);
     //...
    }
  
  int start()
    {
     //---- перед использованием ресурса пытаемся его заблокировать
     while(!IsStopped())
       {
        //---- блокируем
        if(GlobalVariableSetOnCondition(&quot;DATAFILE_SEM&quot;,1,0)==true)  break;
        //---- переменная удалена?
        if(GetLastError()==ERR_GLOBAL_VARIABLE_NOT_FOUND) return(0);
        //---- задержка исполнения в полсекунды
        Sleep(500);
       }
     //---- ресурс заблокирован
     // ... работа с файлом
     //---- разблокируем ресурс 
     GlobalVariableSet(&quot;file_semaphore&quot;,0);
    }
      </example>
      <parameter>
        type=string
        name=name
        description=Имя глобальной переменной.
      </parameter>
      <parameter>
        type=double
        name=value
        description=Новое значение.
      </parameter>
      <parameter>
        type=double
        name=check_value
        description=Значение для проверки текущего значения глобальной переменной.
      </parameter>
    </function>

    <function>
      tag=globals_GlobalVariablesDeleteAll
      caption=GlobalVariablesDeleteAll()
      type=int
      <content>
      Удаляет глобальные переменные. Если префикс для имени не задан, то удаляются все глобальные переменные.
      В противном случае удаляются только те переменные, имена которых начинаются на указанный префикс.
      Функция возвращает количество удаленных переменных.
      </content>
      example=Print(&quot;Удалено &quot;,GlobalVariablesDeleteAll("test_"),&quot; глобальных переменных после тестирования&quot;);
      <parameter>
        type=string
        name=prefix_name
        def_value=NULL
        description=Префикс имени удаляемых глобальных переменных.
      </parameter>
    </function>

    <function>
      tag=globals_GlobalVariablesTotal
      caption=GlobalVariablesTotal()
      type=int
      <content>
      Функция возвращает общее количество глобальных переменных.
      </content>
      example=Print(&quot;В клиентском терминале &quot;,GlobalVariablesTotal(),&quot; глобальных переменных&quot;);
    </function>
  </group>


  <group>
    tag=math
    caption=Математические функции
    <content>
    Набор математических и тригонометрических функций.
    </content>

    <function>
      tag=math_MathAbs
      caption=MathAbs()
      type=double
      <content>
      Функция возвращает абсолютное значение (значение по модулю) переданного ей числа
      </content>
      <example>
  double dx=-3.141593, dy;
  // вычисляет MathAbs
  dy=MathAbs(dx);
  Print("Абсолютная величина ",dx," есть ",dy);
  // Вывод: абсолютная величина -3.141593 есть 3.141593
      </example>
      <parameter>
        type=double
        name=value
        description=Числовая величина.
      </parameter>
    </function>

    <function>
      tag=math_MathArccos
      caption=MathArccos()
      type=double
      <content>
Функция возвращает значение арккосинуса <i>x</i> в диапазоне 0 к &#x3C0; в радианах.
Если <i>x</i> меньше -1 или больше 1, функция возвращает NaN (неопределенное значение).
      </content>
      <example>
  double x=0.32696, y;
  y=asin(x);
  Print("арксинус от ",x," = ",y);
  y=acos(x);
  Print("арккосинус от ",x," = ",y);
  // Вывод: арксинус   от 0.326960=0.333085
  // Вывод: арккосинус от 0.326960=1.237711
      </example>
      <parameter>
        type=double
        name=x
        description=Значение между -1 и 1, арккосинус которого должен быть вычислен.
      </parameter>
    </function>

    <function>
      tag=math_MathArcsin
      caption=MathArcsin()
      type=double
      <content>
Функция возвращает арксинус <i>x</i> в диапазоне от -&#x3C0;/2 до &#x3C0;/2 радианов.
Если <i>x</i>-, меньше -1 или больше 1, функция возвращает NaN (неопределенное значение).
      </content>
      <example>
  double x=0.32696, y;
  y=asin(x);
  Print("арксинус от ",x," = ",y);
  y=acos(x);
  Print("арккосинус от ",x," = ",y);
  // Вывод: арксинус   от 0.326960=0.333085
  // Вывод: арккосинус от 0.326960=1.237711
      </example>
      <parameter>
        type=double
        name=x
        description=Значение, для которого должен быть вычислен арксинус.
      </parameter>
    </function>

    <function>
      tag=math_MathArctan
      caption=MathArctan()
      type=double
      <content>
Функция возвращает арктангенс <i>x</i>. Если <i>x</i> равен 0, функция возвращает 0.
MathArctan возвращает значение в диапазоне от -&#x3C0;/2 до &#x3C0;/2 радианов.
      </content>
      <example>
  double x=-862.42, y;
  y=MathArctan(x);
  Print("Арктангенс от ",x," есть ",y);
  // Вывод: Арктангенс от -862.42 есть -1.5696
      </example>
      <parameter>
        type=double
        name=x
        description=Число, представляющее тангенс.
      </parameter>
    </function>

    <function>
      tag=math_MathCeil
      caption=MathCeil()
      type=double
      <content>
Функция возвращает числовое значение, представляющую наименьшее целое число,
которое больше или равно <i>x</i>.
      </content>
      <example>
  double y;
  y=MathCeil(2.8);
  Print("наименьшее целое число для 2.8 есть ",y);
  y=MathCeil(-2.8);
  Print("наименьшее целое число для -2.8 есть ",y);
  /*Вывод:
    наименьшее целое число для 2.8 есть 3
    наименьшее целое число для -2.8 есть -2*/
      </example>
      <parameter>
        type=double
        name=x
        description=Числовая величина.
      </parameter>
    </function>

    <function>
      tag=math_MathCos
      caption=MathCos()
      type=double
      <content>
      Функция возвращает косинус угла.
      </content>
      <example>
  double pi=3.1415926535;
  double x, y;

  x=pi/2;
  y=MathSin(x);
  Print("MathSin(",x,") = ",y);
  y=MathCos(x);
  Print("MathCos(",x,") = ",y);
  // Вывод: MathSin(1.5708)=1
  //        MathCos(1.5708)=0
      </example>
      <parameter>
        type=double
        name=value
        description=Угол в радианах.
      </parameter>
    </function>

    <function>
      tag=math_MathExp
      caption=MathExp()
      type=double
      <content>
Функция возвращает значение числа <b>e</b> в степени <i>d</i>.
При переполнении функция возвращает INF (бесконечность), в случае потери порядка MathExp возвращает 0.
      </content>
      <example>
  double x=2.302585093,y;
  y=MathExp(x);
  Print("MathExp(",x,") = ",y);
  // Вывод: MathExp(2.3026)=10
      </example>
      <parameter>
        type=double
        name=d
        description=Число, определяющее степень.
      </parameter>
    </function>

    <function>
      tag=math_MathFloor
      caption=MathFloor()
      type=double
      <content>
Функция возвращает числовое значение, представляющее наибольшее целое число, которое меньше или равно <i>x</i>.
      </content>
      <example>
  double y;
  y=MathFloor(2.8);
  Print("Наименьшее целое от 2.8 есть ",y);
  y=MathFloor(-2.8);
  Print("Наименьшее целое от -2.8 есть ",y);
  /*Вывод:
    Наименьшее целое от 2.8 есть 2
    Наименьшее целое от -2.8 есть -3*/
      </example>
      <parameter>
        type=double
        name=x
        description=Числовое значение.
      </parameter>
    </function>

    <function>
      tag=math_MathLog
      caption=MathLog()
      type=double
      <content>
Функции возвращают натуральный логарифм <i>x</i> в случае успеха.
Если <i>x</i> отрицателен, функция возвращает NaN (неопределенное значение).
Если <i>x</i> равен 0, функция возвращает INF (бесконечность) .
      </content>
      <example>
  double x=9000.0,y;
  y=MathLog(x);
  Print("MathLog(",x,") = ", y);
  // Вывод: MathLog(9000)=9.10498
      </example>
      <parameter>
        type=double
        name=x
        description=Значение, логарифм которого должен быть вычислен.
      </parameter>
    </function>

    <function>
      tag=math_MathMax
      caption=MathMax()
      type=double
      <content>
      Функция возвращает максимальное из двух числовых значений.
      </content>
      <example>
  double result=MathMax(1.08,Bid);
      </example>
      <parameter>
        type=double
        name=value1
        description=Первое числовое значение.
      </parameter>
      <parameter>
        type=double
        name=value2
        description=Второе числовое значение.
      </parameter>
    </function>

    <function>
      tag=math_MathMin
      caption=MathMin()
      type=double
      <content>
      Функция возвращает минимальное из двух числовых значений.
      </content>
      <example>
  double result=MathMin(1.08,Ask);
      </example>
      <parameter>
        type=double
        name=value1
        description=Первое числовое значение.
      </parameter>
      <parameter>
        type=double
        name=value2
        description=Второе числовое значение.
      </parameter>
    </function>

    <function>
      tag=math_MathMod
      caption=MathMod()
      type=double
      <content>
      Функция возвращает вещественный остаток от деления двух чисел.<br/><br/>
      Функция MathMod рассчитывает вещественный остаток <i>f&nbsp;</i> от <i>x&nbsp;/&nbsp;y&nbsp;</i> таким образом, что <i>x&nbsp;=&nbsp;i&nbsp;*&nbsp;y&nbsp;+&nbsp;f&nbsp;</i>,
      где <i>i&nbsp;</i> является целым числом, <i>f&nbsp;</i> имеет тот же знак, что и <i>x</i>, и абсолютное значение <i>f&nbsp;</i> меньше,
      чем абсолютное значение <i>y</i>.
      </content>
      <example>
  double x=-10.0,y=3.0,z;
  z=MathMod(x,y);
  Print("Остаток от ",x," / ",y," есть ",z);
  // Вывод: Остаток от -10 / 3 есть -1
      </example>
      <parameter>
        type=double
        name=value
        description=Значение делимого.
      </parameter>
      <parameter>
        type=double
        name=value2
        description=Значение делителя.
      </parameter>
    </function>

    <function>
      tag=math_MathPow
      caption=MathPow()
      type=double
      <content>
      Функция возвращает значение основания, возведенного в указанную степень.
      </content>
      <example>
  double x=2.0,y=3.0,z;
  z=MathPow(x,y);
  Printf(x," в степени ",y," есть ", z);
  // Вывод: 2 в степени 3 есть 8
      </example>
      <parameter>
        type=double
        name=base
        description=Основание.
      </parameter>
      <parameter>
        type=double
        name=exponent
        description=Значение степени.
      </parameter>
    </function>

    <function>
      tag=math_MathRand
      caption=MathRand()
      type=int
      <content>
Функция возвращает псевдослучайное целое число в дипазоне от 0 до 32767.
Перед первым вызовом функции необходимо использовать функцию <a href="help://math_MathSrand">MathSrand</a>, чтобы перевести генератор псевдослучайных чисел в начальное состояние.
      </content>
      <example>
  MathSrand(TimeLocal());
  // Отображает 10 чисел.
  for(int i=0;i&lt;10;i++ )
    Print("произвольная величина ", MathRand());
      </example>  
    </function>

    <function>
      tag=math_MathRound
      caption=MathRound()
      type=double
      <content>
      Функция возвращает значение, округленное до ближайшего целого числа указанного числового значения.
      </content>
      <example>
  double y=MathRound(2.8);
  Print("Округление 2.8 до ",y);
  y=MathRound(2.4);
  Print("Округление -2.4 до ",y);
  // Вывод: Округление 2.8 до 3
  //        Округление -2.4 до -2
      </example>
      <parameter>
        type=double
        name=value
        description=Числовая величина для округления.
      </parameter>
    </function>

    <function>
      tag=math_MathSin
      caption=MathSin()
      type=double
      <content>
      Функция возвращает синус указанного угла.
      </content>
      <example>
  double pi=3.1415926535;
  double x, y;

  x=pi/2;
  y=MathSin(x);
  Print("MathSin(",x,") = ",y);
  y=MathCos(x);
  Print("MathCos(",x,") = ",y);
  // Вывод: MathSin(1.5708)=1
  //        MathCos(1.5708)=0
      </example>
      <parameter>
        type=double
        name=value
        description=Угол в радианах.
      </parameter>
    </function>

    <function>
      tag=math_MathSqrt
      caption=MathSqrt()
      type=double
      <content>
Функция возвращает квадратный корень <i>x</i>.
Если <i>x</i> отрицателен, MathSqrt возвращает NaN (неопределенное значение).
      </content>
      <example>
  double question=45.35, answer;
  answer=MathSqrt(question);
  if(question&lt;0)
    Print(&quot;Ошибка: MathSqrt возвратил &quot;,answer,&quot; ответ&quot;);
  else
    Print(&quot;Квадратный корень из &quot;,question,&quot; есть &quot;, answer);
  //Ответ: Квадратный корень из 45.35 есть 6.73
      </example>
      <parameter>
        type=double
        name=x
        description=Положительная числовая величина.
      </parameter>
    </function>

    <function>
      tag=math_MathSrand
      caption=MathSrand()
      type=void
      <content>
Функция устанавливает начальное состояние для генерации ряда псевдослучайных целых чисел.
Чтобы переинициализировать генератор (т.е. установить генератор в предыдущее начальное состояние), необходимо использовать значение 1 в качестве инициализирующего параметра.
Любое другое значение для начального числа устанавливает генератор в случайную отправную точку.
<a href="help://math_MathRand">MathRand</a> возвращает подряд сгенерированные псевдослучайные числа.
Вызов MathRand перед любым вызовом MathSrand генерирует ту же самую последовательность, что и запрос MathSrand с параметром 1.
      </content>
      <example>
  MathSrand(TimeLocal());
  // Отображает 10 чисел.
  for(int i=0;i&lt;10;i++ )
    Print("произвольная величина ", MathRand());
      </example>  
      <parameter>
        type=int
        name=seed
        description=Начальное число для ряда случайных чисел.
      </parameter>
    </function>

    <function>
      tag=math_MathTan
      caption=MathTan()
      type=double
      <content>
Функция возвращает тангенс <i>x</i>. Если <i>x</i> больше или равен 263 или меньше или равен -263,
то происходит потеря значения и функция возвращает неопределенное число.
      </content>
      <example>
  double pi=3.1415926535;
  double x,y;
  x=MathTan(pi/4);
  Print("MathTan(",pi/4," = ",x);
  // Вывод: MathTan(0.7856)=1
      </example>
      <parameter>
        type=double
        name=x
        description=Угол в радианах.
      </parameter>
    </function>
  </group>


  <group>
    tag=objects
    caption=Графические объекты
    <content>
    Группа функций, предназначенных для работы с графическими объектами, относящимися к текущему графику.
    </content>

    <function>
      tag=objects_ObjectCreate
      caption=ObjectCreate()
      type=bool
      <content>
Создание объекта с указанным именем, тип и начальные координаты в указанном подокне графика.
Число координат, связываемых с объектом, может быть от 1 до 3 в зависимости от типа.
При успешном создании объекта функция возвращает TRUE, иначе FALSE.
Чтобы получить дополнительную информацию об ошибке, необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.<br/>
Объекты с типом OBJ_LABEL игнорируют координаты. Используйте функцию
<a href="help://objects_ObjectSet">ObjectSet()</a> для установки свойств <a href="help://constants_objects_properties">OBJPROP_XDISTANCE</a> и 
<a href="help://constants_objects_properties">OBJPROP_YDISTANCE</a>.<br/>
Замечания: нумерация подокон графика (если на графике есть подокна с индикаторами) начинается с 1. Главное окно графика есть всегда и имеет индекс 0.<br/>
Координаты должны передаваться парами - время и цена.
Для примера, объекту OBJ_VLINE требуется только время, но также нужно передать и цену (любое значение).
      </content>
      <example>
  // новый объект Text
    if(!ObjectCreate(&quot;text_object&quot;, OBJ_TEXT, 0, D'2004.02.20 12:30', 1.0045))
    {
     Print(&quot;error: can't create text_object! code #&quot;,GetLastError());
     return(0);
    }
  // новый объект TextLabel
    if(!ObjectCreate(&quot;label_object&quot;, OBJ_LABEL, 0, 0, 0))
    {
     Print(&quot;error: can't create label_object! code #&quot;,GetLastError());
     return(0);
    }
  ObjectSet(&quot;label_object&quot;, OBJPROP_XDISTANCE, 200);
  ObjectSet(&quot;label_object&quot;, OBJPROP_YDISTANCE, 100);
      </example>
      <parameter>
        type=string
        name=name
        description=Уникальное имя объекта.
      </parameter>
      <parameter>
        type=int
        name=type
        description=Тип объекта. Может быть любым из <a href="help://constants_objects">типов объектов</a>.
      </parameter>
      <parameter>
        type=int
        name=window
        description=Индекс окна, в которое будет добавлен объект. Индекс окна должен быть большим или равным 0 и меньшим, чем <a href="help://windows_WindowsTotal">WindowsTotal()</a>.
      </parameter>
      <parameter>
        type=datetime
        name=time1
        description=Время первой координаты.
      </parameter>
      <parameter>
        type=double
        name=price1
        description=Цена первой координаты.
      </parameter>
      <parameter>
        type=datetime
        name=time2
        def_value=0
        description=Время второй координаты.
      </parameter>
      <parameter>
        type=double
        name=price2
        def_value=0
        description=Цена второй координаты.
      </parameter>
      <parameter>
        type=datetime
        name=time3
        def_value=0
        description=Время третьей координаты.
      </parameter>
      <parameter>
        type=double
        name=price3
        def_value=0
        description=Цена третьей координаты.
      </parameter>
    </function>

    <function>
      tag=objects_ObjectDelete
      caption=ObjectDelete()
      type=bool
      <content>
Удаление объекта с указанным именем.
При успешном удалении функция возвращает TRUE, иначе FALSE.<br/>
Чтобы получить дополнительную информацию об ошибке, необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.
      </content>
      example=ObjectDelete(&quot;text_object&quot;);
      <parameter>
        type=string
        name=name
        description=Имя удаляемого объекта.
      </parameter>
    </function>

    <function>
      tag=objects_ObjectDescription
      caption=ObjectDescription()
      type=string
      <content>
Функция возвращает описание объекта. Для объектов типа OBJ_TEXT и OBJ_LABEL возвращается текст, отображаемый этими объектами.<br/>
Чтобы получить информацию об ошибке, необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.
<br/><b>См. также</b> <a href="help://objects_ObjectSetText">ObjectSetText()</a>.
      </content>
      <example>
  // сохранение списка объектов графика в файл
  int    handle, total;
  string obj_name,fname;
  // имя файла
  fname="objlist_"+Symbol();
  handle=FileOpen(fname,FILE_CSV|FILE_WRITE);
  if(handle&gt;0)
    {
     total=ObjectsTotal();
     for(int i=-;i&lt;total;i++)
       {
        obj_name=ObjectName(i);
        FileWrite(handle,"Object "+obj_name+" описание= "+ObjectDescription(obj_name));
       }
     FileClose(handle);
    }
      </example>
      <parameter>
        type=string
        name=name
        description=Имя объекта.
      </parameter>
    </function>

    <function>
      tag=objects_ObjectFind
      caption=ObjectFind()
      type=int
      <content>
Поиск объекта с указанным именем. Функция возвращает индекс окна, которому принадлежит искомый объект. В случае неудачи функция вернет -1.
Для получения дополнительной информации об ошибке необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.
Нумерация подокон графика (если на графике есть подокна с индикаторами) начинается с 1. Главное окно графика есть всегда и имеет индекс 0.
      </content>
      example=if(ObjectFind(&quot;line_object2&quot;)!=win_idx) return(0);
      <parameter>
        type=string
        name=name
        description=Имя искомого объекта.
      </parameter>
    </function>

    <function>
      tag=objects_ObjectGet
      caption=ObjectGet()
      type=double
      <content>
Функция возвращает значение указанного свойства объекта.
Для получения информации об ошибке необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.
<br/><b>См. также</b> <a href="help://objects_ObjectSet">ObjectSet()</a>.
      </content>
      example=color oldColor=ObjectGet(&quot;hline12&quot;, OBJPROP_COLOR);
      <parameter>
        type=string
        name=name
        description=Имя объекта.
      </parameter>
      <parameter>
        type=int
        name=prop_id
        description=Идентификатор свойства объекта. Может быть любым из значений <a href="help://constants_objects_properties">списка свойств объекта</a>.
      </parameter>
    </function>

    <function>
      tag=objects_ObjectGetFiboDescription
      caption=ObjectGetFiboDescription()
      type=string
      <content>
Функция возвращает описание уровня объекта Фибоначчи.
Количество уровней зависит от типа <a href="help://constants_objects">объекта</a>, принадлежащего к группе объектов Фибоначчи. Максимальное количество уровней - 32.<br/>
Для получения информации об ошибке необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.
<br/><b>См. также</b> <a href="help://objects_ObjectSetFiboDescription">ObjectSetFiboDescription()</a>.
      </content>
      <example>
#include &lt;stdlib.mqh&gt;
  ...
  string text;
  for(int i=0;i&lt;32;i++)
    {
     text=ObjectGetFiboDescription(MyObjectName,i);
     //---- проверим, возможно уровней у объекта меньше, чем 32
     if(GetLastError()!=ERR_NO_ERROR) break;
     Print(MyObjectName,&quot;номер уровня: &quot;,i,&quot; описание: &quot;,text);
    }
      </example>
      <parameter>
        type=string
        name=name
        description=Имя объекта Фибоначчи.
      </parameter>
      <parameter>
        type=int
        name=index
        description=Индекс уровня Фибоначчи (0-31).
      </parameter>
    </function>

    <function>
      tag=objects_ObjectGetShiftByValue
      caption=ObjectGetShiftByValue()
      type=int
      <content>
Функция вычисляет и возвращает номер бара (смещение относительно текущего бара) для указанной цены.
Номер бара вычисляется при помощи линейного уравнения по первой и второй координатам. Применяется для трендовых линий и аналогичных объектов.
Для получения информации об ошибке необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.
<br/><b>См. также</b> <a href="help://objects_ObjectGetValueByShift">ObjectGetValueByShift()</a>.
      </content>
      <example>
  int shift=ObjectGetShiftByValue(&quot;MyTrendLine#123&quot;, 1.34);
      </example>
      <parameter>
        type=string
        name=name
        description=Имя объекта.
      </parameter>
      <parameter>
        type=double
        name=value
        description=Значение цены.
      </parameter>
    </function>

    <function>
      tag=objects_ObjectGetValueByShift
      caption=ObjectGetValueByShift()
      type=double
      <content>
Функция вычисляет и возвращает значение цены для указанного бара (смещение относительно текущего бара).
Значение цены вычисляется при помощи линейного уравнения по первой и второй координатам. Применяется для трендовых линий и аналогичных объектов.
Для получения информации об ошибке необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.
<br/><b>См. также</b> <a href="help://objects_ObjectGetShiftByValue">ObjectGetShiftByValue()</a>.
      </content>
      <example>
  double price=ObjectGetValueByShift(&quot;MyTrendLine#123&quot;, 11);
      </example>
      <parameter>
        type=string
        name=name
        description=Имя объекта.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Номер бара.
      </parameter>
    </function>

    <function>
      tag=objects_ObjectMove
      caption=ObjectMove()
      type=bool
      <content>
Изменение одной из координат объекта на графике. Объекты могут иметь от одной до трех точек привязки в зависимости от
<a href="help://constants_objects">типа объекта</a>.
Функция возвращает TRUE в случае успеха, иначе FALSE.
Для получения дополнительной информации об ошибке необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.<br/>
Нумерация координат объекта начинается с 0.
     </content>
      example=ObjectMove(&quot;MyTrend&quot;, 1, D'2005.02.25 12:30', 1.2345);
      <parameter>
        type=string
        name=name
        description=Имя объекта.
      </parameter>
      <parameter>
        type=int
        name=point
        description=Индекс координаты (0-2).
      </parameter>
      <parameter>
        type=datetime
        name=time1
        description=Новое значение времени.
      </parameter>
      <parameter>
        type=double
        name=price1
        description=Новое значение цены.
      </parameter>
    </function>

    <function>
      tag=objects_ObjectName
      caption=ObjectName()
      type=string
      <content>
Функция возвращает имя объекта по порядковому номеру в списке объектов.
Для получения дополнительной информации об ошибке необходимо вызвать функцию функцию <a href="help://check_GetLastError">GetLastError()</a>.
     </content>
      <example>
  int    obj_total=ObjectsTotal();
  string name;
  for(int i=0;i&lt;obj_total;i++)
    {
     name=ObjectName(i);
     Print(i,&quot;: Имя объекта - &quot;,name);
    }
      </example>
      <parameter>
        type=int
        name=index
        description=Порядковый номер в списке объектов. Должен быть большим или равным 0 и меньшим, чем <a href="help://objects_ObjectsTotal">ObjectsTotal()</a>.
      </parameter>
    </function>

    <function>
      tag=objects_ObjectsDeleteAll
      caption=ObjectsDeleteAll()
      type=int
      <content>
Удаление всех объектов с указанным типом и в указанном подокне графика. Функция возвращает число удаленных объектов.
Для получения дополнительной информации об ошибке необходимо вызвать функцию функцию <a href="help://check_GetLastError">GetLastError()</a>.<br/>
Замечания: нумерация подокон графика (если на графике есть подокна с индикаторами) начинается с 1. Главное окно графика есть всегда и имеет индекс 0.
Если индекс окна отсутствует или имеет значение -1, то объекты удаляются со всего графика.<br/>
Если значение параметра <i>type</i> равно -1 или этот параметр отсутствует, то удаляются все объекты из указанного подокна.
     </content>
      <example>
  ObjectsDeleteAll(2, OBJ_HLINE); // удаляются все горизонтальные линии из 2-го подокна.
  ObjectsDeleteAll(2);            // удаляются все объекты из 2-го подокна.
  ObjectsDeleteAll();             // удаляются все объекты с графика.
      </example>
      <parameter>
        type=int
        name=window
        def_value=EMPTY
        <description>
Необязательный параметр. Индекс окна, на котором будут удалены объекты. Должен быть большим или равным -1 (EMPTY, значение по умолчанию) и меньшим, чем <a href="help://windows_WindowsTotal">WindowsTotal()</a>.
        </description>
      </parameter>
      <parameter>
        type=int
        name=type
        def_value=EMPTY
        <description>
Необязательный параметр. Тип объекта для удаления.
 Это может быть любое из значений <a href="help://constants_objects">списка идентификаторов типов объектов</a> или EMPTY (-1) для удаления всех объектов.
        </description>
      </parameter>
    </function>

    <function>
      tag=objects_ObjectSet
      caption=ObjectSet()
      type=bool
      <content>
Изменение значения указанного свойства объекта. В случае успеха функция возвращает TRUE, иначе FALSE.
 Для получения информации об ошибке необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.
<br/><b>См. также</b> <a href="help://objects_ObjectGet">ObjectGet()</a>.
      </content>
      <example>
  // перемещение первой координаты в конец графика
  ObjectSet(&quot;MyTrend&quot;, OBJPROP_TIME1, Time[0]);
  // изменение значения второго уровеня объекта fibo
  ObjectSet(&quot;MyFibo&quot;, OBJPROP_FIRSTLEVEL+1, 1.234);
  // установка флага видимости объекта. Объект будет отрисован только на 15-минутном и 1-часовом периодах графика
  ObjectSet(&quot;MyObject&quot;, OBJPROP_TIMEFRAMES, OBJ_PERIOD_M15 | OBJ_PERIOD_H1);
      </example>
      <parameter>
        type=string
        name=name
        description=Имя объекта.
      </parameter>
      <parameter>
        type=int
        name=prop_id
        description=Идентификатор свойства объекта. Может быть любым из <a href="help://constants_objects_properties">списка свойств объекта</a>.
      </parameter>
      <parameter>
        type=double
        name=value
        description=Новое значение указанного свойства.
      </parameter>
    </function>

    <function>
      tag=objects_ObjectSetFiboDescription
      caption=ObjectSetFiboDescription()
      type=bool
      <content>
Функция присваивает новое описание уровню объекта Фибоначчи. Количество уровней зависит от <a href="help://constants_objects">типа объекта</a> Фибоначчи.
Максимальное количество уровней - 32.<br/>
Для получения информации об ошибке необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.
      </content>
      example=ObjectSetFiboDescription(&quot;MyFiboObject&quot;,2,&quot;Second line&quot;);
      <parameter>
        type=string
        name=name
        description=Имя объекта.
      </parameter>
      <parameter>
        type=int
        name=index
        description=Порядковый номер уровня объекта Фибоначчи (0-31).
      </parameter>
      <parameter>
        type=string
        name=text
        description=Новое описание уровня.
      </parameter>
    </function>

    <function>
      tag=objects_ObjectSetText
      caption=ObjectSetText()
      type=bool
      <content>
Изменение описания объекта. Для объектов OBJ_TEXT и OBJ_LABEL это описание отображается на графике в виде текстовой строки.
В случае успеха функция возвращает значение TRUE, иначе FALSE.
Для получения дополнительной информации об ошибке необходимо вызвать функцию функцию <a href="help://check_GetLastError">GetLastError()</a>.<br/>
Параметры <i>font_size</i>, <i>font_name</i> и <i>text_color</i> используются только для объектов OBJ_TEXT и OBJ_LABEL.
Для объектов <a href="help://constants_objects">других типов</a> эти параметры игнорируются.
<br/><b>См. также</b> <a href="help://objects_ObjectDescription">ObjectDescription()</a>.
      </content>
      example=ObjectSetText(&quot;text_object&quot;, &quot;Hello world!&quot;, 10, &quot;Times New Roman&quot;, Green);
      <parameter>
        type=string
        name=name
        description=Имя объекта.
      </parameter>
      <parameter>
        type=string
        name=text
        description=Текст описания обьекта.
      </parameter>
      <parameter>
        type=int
        name=font_size
        description=Размер шрифта в пунктах.
      </parameter>
      <parameter>
        type=string
        name=font_name
        def_value=NULL
        description=Наименование шрифта.
      </parameter>
      <parameter>
        type=color
        name=text_color
        def_value=CLR_NONE
        description=Цвет текста.
      </parameter>
    </function>

    <function>
      tag=objects_ObjectsTotal
      caption=ObjectsTotal()
      type=int
      <content>
      Возвращает общее число объектов указанного типа на графике.
      </content>
      <example>
  int    obj_total=ObjectsTotal();
  string name;
  for(int i=0;i&lt;obj_total;i++)
    {
     name = ObjectName(i);
     Print(i,&quot; - объект &quot;,name);
    }
      </example>
      <parameter>
        type=int
        name=type
        def_value=EMPTY
        <description>
Необязательный параметр. Тип объекта для подсчета количества объектов данного типа.
 Это может быть любое из значений <a href="help://constants_objects">списка идентификаторов типов объектов</a> или EMPTY (-1) для подсчета всех объектов.
        </description>
      </parameter>
    </function>

    <function>
      tag=objects_ObjectType
      caption=ObjectType()
      type=int
      <content>
Функция возвращает <a href="help://constants_objects">тип</a> указанного объекта.
Для получения информации об ошибке необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.
      </content>
      example=if(ObjectType(&quot;line_object2&quot;)!=OBJ_HLINE) return(0);
      <parameter>
        type=string
        name=name
        description=Имя объекта.
      </parameter>
    </function>
  </group>


  <group>
    tag=strings
    caption=Строковые функции
    <content>
    Группа функций, предназначенных для работы с данными типа string.
    </content>

    <function>
      tag=strings_StringConcatenate
      caption=StringConcatenate()
      type=string
      <content>
Формирует строку из переданных параметров и возвращает её. Параметры могут иметь любой тип. Количество параметров не может превышать 64.<br/><br/>
Параметры преобразуются в строки по тем же правилам, что и в функциях <a href="help://common_Print">Print()</a>, <a href="help://common_Alert">Alert()</a> и <a href="help://common_Comment">Comment()</a>.
Возвращаемая строка получается в результате конкатенации строк, преобразованных из параметров функции.<br/><br/>
Функция StringConcatenate() работает быстрее и экономнее по памяти, чем связывание строк при помощи операций сложения (+).
      </content>
      <example>
  string text;
  text=StringConcatenate(&quot;Account free margin is &quot;, AccountFreeMargin(), &quot; Current time is &quot;, TimeToStr(TimeCurrent()));
  // text=&quot;Account free margin is &quot; + AccountFreeMargin() + &quot;  Current time is &quot; + TimeToStr(TimeCurrent())
  Print(text);
      </example>
      <parameter>
        type=...
        name=
        description=Любые значения, разделенные запятыми.
      </parameter>
    </function>

    <function>
      tag=strings_StringFind
      caption=StringFind()
      type=int
      <content>
      Поиск подстроки. Возвращает номер позиции в строке, с которой начинается искомая подстрока, либо -1, если подстрока не найдена.
      </content>
      <example>
  string text = &quot;Быстрая коричневая собака перепрыгивает ленивую лисицу&quot;;
  int index=StringFind(text, &quot;собака перепрыгивает&quot;, 0);
  if(index!=20)
    Print(&quot;oops!&quot;);
      </example>
      <parameter>
        type=string
        name=text
        description=Строка, в которой производится поиск.
      </parameter>
      <parameter>
        type=string
        name=matched_text
        description=Искомая подстрока.
      </parameter>
      <parameter>
        type=int
        name=start
        def_value=0
        description=Позиция в строке, с которой должен быть начат поиск.
      </parameter>
    </function>

    <function>
      tag=strings_StringGetChar
      caption=StringGetChar()
      type=int
      <content>
      Возвращает значение символа, расположенного в указанной позиции строки.
      </content>
      <example>
  int char_code=StringGetChar(&quot;abcdefgh&quot;, 3);
  // символьный код 'c' = 99
      </example>
      <parameter>
        type=string
        name=text
        description=Строка.
      </parameter>
      <parameter>
        type=int
        name=pos
        description=Позиция символа в строке. Может быть от 0 до <a href="help://strings_StringLen">StringLen(text)</a>-1.
      </parameter>
    </function>

    <function>
      tag=strings_StringLen
      caption=StringLen()
      type=int
      <content>
      Возвращает число символов в строке.
      </content>
      <example>
  string str=&quot;some text&quot;;
  if(StringLen(str)&lt;5) return(0);
      </example>
      <parameter>
        type=string
        name=text
        description=Строка для вычисления длины.
      </parameter>
    </function>

    <function>
      tag=strings_StringSetChar
      caption=StringSetChar()
      type=string
      <content>
      Возвращает копию строки с измененным значением символа в указанной позиции.
      </content>
      <example>
  string str=&quot;abcdefgh&quot;;
  string str1=StringSetChar(str, 3, 'D');
  // str1 = &quot;abcDefgh&quot;
      </example>
      <parameter>
        type=string
        name=text
        description=Строка для изменения.
      </parameter>
      <parameter>
        type=int
        name=pos
        description=Позиция символа в строке. Может быть от 0 до <a href="help://strings_StringLen">StringLen(text)</a>.
      </parameter>
      <parameter>
        type=int
        name=value
        description=Символьный код ASCII.
      </parameter>
    </function>

    <function>
      tag=strings_StringSubstr
      caption=StringSubstr()
      type=string
      <content>
Извлекает подстроку из текстовой строки, начинающейся c указанной позиции.<br/>
Функция возвращает копию извлеченной подстроки, если возможно, иначе возвращается пустая строка.
      </content>
      <example>
  string text = &quot;Быстрая коричневая собака перепрыгивает ленивую лисицу&quot;;
  string substr = StringSubstr(text, 8, 10);
  // извлеченная строка &quot;коричневая&quot;
      </example>
      <parameter>
        type=string
        name=text
        description=Строка, из которой должна быть извлечена подстрока.
      </parameter>
      <parameter>
        type=int
        name=start
        description=Начальная позиция подстроки. Может быть от 0 до <a href="help://strings_StringLen">StringLen(text)</a>-1.
      </parameter>
      <parameter>
        type=int
        name=length
        def_value=0
        description=Длина извлекаемой подстроки. Если значение параметра меньше или равно 0 либо параметр не задан, то будет извлекаться подстрока, начиная с указанной позиции и до конца строки.
      </parameter>
    </function>

    <function>
      tag=strings_StringTrimLeft
      caption=StringTrimLeft()
      type=string
      <content>
Функция урезает символы перевода каретки, пробелы
и символы табуляции в левой части строки.
Функция возвращает копию преобразованной строки, если это возможно,
в противном случае возвращается пустая строка.
      </content>
      <example>
  string str1=&quot;  Hello world   &quot;;
  string str2=StringTrimLeft(str);
  // после срезания str2, у переменной будет значение - &quot;Hello World   &quot;
      </example>
      <parameter>
        type=string
        name=text
        description=Строка, которая будет срезана слева.
      </parameter>
    </function>

    <function>
      tag=strings_StringTrimRight
      caption=StringTrimRight()
      type=string
      <content>
Функция урезает символы перевода каретки, пробелы и символы табуляции в правой части строки.
Функция возвращает копию преобразованной строки, если это возможно,
в противном случае возвращается пустая строка.
      </content>
      <example>
  string str1 = &quot;  Hello world   &quot;;
  string str2=StringTrimRight(str);
  // после срезания str2, у переменной будет значение - &quot;  Hello World&quot;
      </example>
      <parameter>
        type=string
        name=text
        description=Строка, которая будет срезана справа.
      </parameter>
    </function>
  </group>


  <group>
    tag=indicators
    caption=Технические индикаторы
    <content>
    Группа функций, предназначенных для расчета стандартных и пользовательских индикаторов.<br/><br/>
    Для того, чтобы эксперт (или любая MQL4-программа) мог получить значение какого-либо индикатора, присутствие данного индикатора на текущем графике необязательно.
    Запрошенный индикатор будет загружен и рассчитан в потоке вызвавшего его модуля.<br/><br/>
    Любой индикатор может быть рассчитан на данных не только текущего графика, но и на данных любого доступного символа/периода.
    Если запрашивается информация с другого графика (название <a href="help://windows_Symbol">инструмента</a> и/или <a href="help://windows_Period">значение таймфрейма</a>
    отличаются от текущих), то возможна ситуация, что в клиентском терминале не открыт соответствующий график и необходимые данные должны быть запрошены у сервера.
    В этом случае в переменную <a href="help://runtime_errors">last_error</a> будет помещена <a href="help://constants_errors">ошибка</a> ERR_HISTORY_WILL_UPDATED
    (4066 - запрошенные исторические данные в состоянии обновления) и необходимо через некоторое время повторить попытку запроса
    (см. пример <a href="help://array_ArrayCopySeries">ArrayCopySeries()</a>).
    </content>

    <function>
      tag=indicators_iAC
      caption=iAC() - Accelerator Oscillator (Ускорение/Замедление)
      type=double
      <content>
      Расчет осциллятора Accelerator/Decelerator.
      </content>
      <example>
  double result=iAC(NULL, 0, 1);
      </example>
      <parameter>
        type=string
        name=symbol
        description=Символьное имя инструмента, на данных которого будет вычисляться индикатор. NULL означает текущий символ.
      </parameter>
      <parameter>
        type=int
        name=timeframe
        description=Период. Может быть одним из <a href="help://constants_timeframes">периодов графика</a>. 0 означает период текущего графика.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из индикаторного буфера (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>

    <function>
      tag=indicators_iAD
      caption=iAD() - Accumulation/Distribution (Накопление/Распределение)
      type=double
      <content>
      Расчет индикатора Accumulation/Distribution.
      </content>
      <example>
  double result=iAD(NULL, 0, 1);
      </example>
      <parameter>
        type=string
        name=symbol
        description=Символьное имя инструмента, на данных которого будет вычисляться индикатор. NULL означает текущий символ.
      </parameter>
      <parameter>
        type=int
        name=timeframe
        description=Период. Может быть одним из <a href="help://constants_timeframes">периодов графика</a>. 0 означает период текущего графика.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из индикаторного буфера (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>

    <function>
      tag=indicators_iAlligator
      caption=iAlligator() - Alligator (Аллигатор)
      type=double
      keywords=;MODE_GATORJAW;MODE_GATORTEETH;MODE_GATORLIPS;
      <content>
      Расчет индикатора Alligator.
      </content>
      <example>
  double jaw_val=iAlligator(NULL, 0, 13, 8, 8, 5, 5, 3, MODE_SMMA, PRICE_MEDIAN, MODE_GATORJAW, 1);
      </example>
      <parameter>
        type=string
        name=symbol
        description=Символьное имя инструмента, на данных которого будет вычисляться индикатор. NULL означает текущий символ.
      </parameter>
      <parameter>
        type=int
        name=timeframe
        description= Период. Может быть одним из <a href="help://constants_timeframes">периодов графика</a>. 0 означает период текущего графика.
      </parameter>
      <parameter>
        type=int
        name=jaw_period
        description=Период усреднения синей линии (челюсти аллигатора).
      </parameter>
      <parameter>
        type=int
        name=jaw_shift
        description=Смещение синей линии относительно графика цены.
      </parameter>
      <parameter>
        type=int
        name=teeth_period
        description=Период усреднения красной линии (зубов аллигатора).
      </parameter>
      <parameter>
        type=int
        name=teeth_shift
        description=Смещение красной линии относительно графика цены.
      </parameter>
      <parameter>
        type=int
        name=lips_period
        description=Период усреднения зеленой линии (губ аллигатора).
      </parameter>
      <parameter>
        type=int
        name=lips_shift
        description=Смещение зеленой линии относительно графика цены.
      </parameter>
      <parameter>
        type=int
        name=ma_method
        description=Метод усреднения. Может быть любым из значений <a href="help://constants_movings">методов скользящего среднего (Moving Average)</a>.
      </parameter>
      <parameter>
        type=int
        name=applied_price
        description=Используемая цена. Может быть любой из <a href="help://constants_prices">ценовых констант</a>.
      </parameter>
      <parameter>
        type=int
        name=mode
        <description>
Источник данных, идентификатор одной из линий индикатора. Mожет быть любой из следующих величин:<br/>
MODE_GATORJAW - синяя линия (линия челюсти аллигатора),<br/>
MODE_GATORTEETH - красная линия (линия зубов аллигатора),<br/>
MODE_GATORLIPS - зеленая линия (линия губ аллигатора).
        </description>
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из индикаторного буфера (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>

    <function>
      tag=indicators_iADX
      caption=iADX() - Average Directional Movement Index (Усредненный Индекс Направленнного Движения)
      type=double
      <content>
      Расчет Average Directional Movement Index.
      </content>
      example=if(iADX(NULL,0,14,PRICE_HIGH,MODE_MAIN,0)&gt;iADX(NULL,0,14,PRICE_HIGH,MODE_PLUSDI,0)) return(0);
      <parameter>
        type=string
        name=symbol
        description=Символьное имя инструмента, на данных которого будет вычисляться индикатор. NULL означает текущий символ.
      </parameter>
      <parameter>
        type=int
        name=timeframe
        description=Период. Может быть одним из <a href="help://constants_timeframes">периодов графика</a>. 0 означает период текущего графика.
      </parameter>
      <parameter>
        type=int
        name=period
        description=Период усреднения для вычисления индекса.
      </parameter>
      <parameter>
        type=int
        name=applied_price
        description=Используемая цена. Может быть любой из <a href="help://constants_prices">ценовых констант</a>.
      </parameter>
      <parameter>
        type=int
        name=mode
        description=Индекс линии индикатора. Может быть любым из перечисленных <a href="help://constants_lines">идентификаторов линии индикаторов</a>.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из индикаторного буфера (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>

    <function>
      tag=indicators_iATR
      caption=iATR() - Average True Range (Средний Истинный Диапазон)
      type=double
      <content>
      Расчет индикатора Average True Range.
      </content>
      <example>
  if(iATR(NULL,0,12,0)&gt;iATR(NULL,0,20,0)) return(0);
      </example>
      <parameter>
        type=string
        name=symbol
        description=Символьное имя инструмента, на данных которого будет вычисляться индикатор. NULL означает текущий символ.
      </parameter>
      <parameter>
        type=int
        name=timeframe
        description=Период. Может быть одним из <a href="help://constants_timeframes">периодов графика</a>. 0 означает период текущего графика.
      </parameter>
      <parameter>
        type=int
        name=period
        description=Период усреднения для вычисления индикатора.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из индикаторного буфера (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>

    <function>
      tag=indicators_iAO
      caption=iAO() - Awesome Oscillator ('Удивительный' осциллятор Билла Вильямса)
      type=double
      <content>
      Расчет Awesome oscillator.
      </content>
      <example>
  double val=iAO(NULL, 0, 2);
      </example>
      <parameter>
        type=string
        name=symbol
        description=Символьное имя инструмента, на данных которого будет вычисляться индикатор. NULL означает текущий символ.
      </parameter>
      <parameter>
        type=int
        name=timeframe
        description=Период. Может быть одним из <a href="help://constants_timeframes">периодов графика</a>. 0 означает период текущего графика.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из индикаторного буфера (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>

    <function>
      tag=indicators_iBearsPower
      caption=iBearsPower() - Bears Power (Сила Медведей)
      type=double
      <content>
      Расчет индикатора Bears Power.
      </content>
      <example>
  double val=iBearsPower(NULL, 0, 13,PRICE_CLOSE,0);
      </example>
      <parameter>
        type=string
        name=symbol
        description=Символьное имя инструмента, на данных которого будет вычисляться индикатор. NULL означает текущий символ.
      </parameter>
      <parameter>
        type=int
        name=timeframe
        description=Период. Может быть одним из <a href="help://constants_timeframes">периодов графика</a>. 0 означает период текущего графика.
      </parameter>
      <parameter>
        type=int
        name=period
        description=Период усреднения для вычисления индикатора.
      </parameter>
      <parameter>
        type=int
        name=applied_price
        description=Используемая цена. Может быть любой из <a href="help://constants_prices">ценовых констант</a>.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из индикаторного буфера (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>

    <function>
      tag=indicators_iBands
      caption=iBands() - Bollinger Bands® (Полосы Боллинджера)
      type=double
      <content>
      Расчет индикатора Bollinger Bands®.
      </content>
      example=if(iBands(NULL,0,20,2,0,PRICE_LOW,MODE_LOWER,0)&gt;Low[0]) return(0);
      <parameter>
        type=string
        name=symbol
        description=Символьное имя инструмента, на данных которого будет вычисляться индикатор. NULL означает текущий символ.
      </parameter>
      <parameter>
        type=int
        name=timeframe
        description=Период. Может быть одним из <a href="help://constants_timeframes">периодов графика</a>. 0 означает период текущего графика.
      </parameter>
      <parameter>
        type=int
        name=period
        description=Период усреднения основной линии индикатора.
      </parameter>
      <parameter>
        type=int
        name=deviation
        description=Отклонение от основной линии.
      </parameter>
      <parameter>
        type=int
        name=bands_shift
        description=Сдвиг индикатора относительно ценового графика.
      </parameter>
      <parameter>
        type=int
        name=applied_price
        description=Используемая цена. Может быть любой из <a href="help://constants_prices">ценовых констант</a>.
      </parameter>
      <parameter>
        type=int
        name=mode
        description=Индекс линии индикатора. Может быть любым из <a href="help://constants_lines">идентификаторов линий индикаторов</a>.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из индикаторного буфера (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>

    <function>
      tag=indicators_iBandsOnArray
      caption=iBandsOnArray() - Bollinger Bands® on buffer (Полосы Боллинджера)
      type=double
      <content>
        Расчет индикатора Bollinger Bands® на данных, хранящихся в массиве.
        В отличие от iBands(...) функция iBandsOnArray не выбирает данные на основе названия инструмента,
        таймфрейма и используемой цены - ценовые данные должны быть подготовлены заранее.
        Расчет производится слева направо. Для организации доступа к элементам массива, как к таймсерии
        (то есть справа налево), необходимо использовать функцию <a href="help://array_ArraySetAsSeries">ArraySetAsSeries</a>.
      </content>
      example=if(iBandsOnArray(ExtBuffer,total,2,0,0,MODE_LOWER,0)&gt;Low[0]) return(0);
      <parameter>
        type=double
        name=<nobr>array[]</nobr>
        description=Массив с данными.
      </parameter>
      <parameter>
        type=int
        name=total
        description=Количество элементов для вычисления. 0 означает все элементы массива.
      </parameter>
      <parameter>
        type=int
        name=period
        description=Период усреднения основной линии индикатора.
      </parameter>
      <parameter>
        type=int
        name=deviation
        description=Отклонение от основной линии.
      </parameter>
      <parameter>
        type=int
        name=bands_shift
        description=Сдвиг индикатора относительно ценового графика.
      </parameter>
      <parameter>
        type=int
        name=mode
        description=Индекс линии индикатора. Может быть любым из <a href="help://constants_lines">идентификаторов линий индикаторов</a>.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из индикаторного буфера (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>

    <function>
      tag=indicators_iBullsPower
      caption=iBullsPower() - Bulls Power (Сила Быков)
      type=double
      <content>
      Расчет индикатора Bulls Power.
      </content>
      <example>
  double val=iBullsPower(NULL, 0, 13,PRICE_CLOSE,0);
      </example>
      <parameter>
        type=string
        name=symbol
        description=Символьное имя инструмента, на данных которого будет вычисляться индикатор. NULL означает текущий символ.
      </parameter>
      <parameter>
        type=int
        name=timeframe
        description=Период. Может быть одним из <a href="help://constants_timeframes">периодов графика</a>. 0 означает период текущего графика.
      </parameter>
      <parameter>
        type=int
        name=period
        description=Период усреднения для вычисления индикатора.
      </parameter>
      <parameter>
        type=int
        name=applied_price
        description=Используемая цена. Может быть любой из <a href="help://constants_prices">ценовых констант</a>.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из индикаторного буфера (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>

    <function>
      tag=indicators_iCCI
      caption=iCCI() - Commodity Channel Index (Индекс Торгового Канала)
      type=double
      <content>
      Расчет индикатора Commodity Channel Index.
      </content>
      <example>
  if(iCCI(Symbol(),0,12,PRICE_TYPICAL,0)&gt;iCCI(Symbol(),0,20,PRICE_TYPICAL,0)) return(0);
      </example>
      <parameter>
        type=string
        name=symbol
        description=Символьное имя инструмента, на данных которого будет вычисляться индикатор. NULL означает текущий символ.
      </parameter>
      <parameter>
        type=int
        name=timeframe
        description=Период. Может быть одним из <a href="help://constants_timeframes">периодов графика</a>. 0 означает период текущего графика.
      </parameter>
      <parameter>
        type=int
        name=period
        description=Период усреднения для вычисления индикатора.
      </parameter>
      <parameter>
        type=int
        name=applied_price
        description=Используемая цена. Может быть любой из <a href="help://constants_prices">ценовых констант</a>.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из индикаторного буфера (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>

    <function>
      tag=indicators_iCCIOnArray
      caption=iCCIOnArray() - Commodity Channel Index on buffer (Индекс Торгового Канала)
      type=double
      <content>
        Расчет индикатора Commodity Channel Index на данных, хранящихся в массиве.
        В отличие от iCCI(...) функция iCCIOnArray не выбирает данные на основе названия инструмента,
        таймфрейма и используемой цены - ценовые данные должны быть подготовлены заранее.
        Расчет производится слева направо. Для организации доступа к элементам массива, как к таймсерии
        (то есть справа налево), необходимо использовать функцию <a href="help://array_ArraySetAsSeries">ArraySetAsSeries</a>.
      </content>
      example=if(iCCIOnArray(ExtBuffer,total,12,0)&gt;iCCIOnArray(ExtBuffer,total,20,0)) return(1);
      <parameter>
        type=double
        name=<nobr>array[]</nobr>
        description=Массив с данными.
      </parameter>
      <parameter>
        type=int
        name=total
        description=Количество элементов для вычисления. 0 означает все элементы массива.
      </parameter>
      <parameter>
        type=int
        name=period
        description=Период усреднения для вычисления индикатора.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из индикаторного буфера (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>

    <function>
      tag=indicators_iCustom
      caption=iCustom() - Custom Indicator (Пользовательский Индикатор)
      type=double
      <content>
Расчет указанного пользовательского индикатора. Пользовательский индикатор должен быть скомпилирован (файл с расширением EX4) 
и находиться в директории <em>каталог_терминала\experts\indicators</em>.
      </content>
      <example>
  double val=iCustom(NULL, 0, &quot;SampleInd&quot;,13,1,0);
      </example>
      <parameter>
        type=string
        name=symbol
        description=Символьное имя инструмента, на данных которого будет вычисляться индикатор. NULL означает текущий символ.
      </parameter>
      <parameter>
        type=int
        name=timeframe
        description=Период. Может быть одним из <a href="help://constants_timeframes">периодов графика</a>. 0 означает период текущего графика.
      </parameter>
      <parameter>
        type=string
        name=name
        description=Имя пользовательского индикатора.
      </parameter>
      <parameter>
        type=...
        name=
        description=Список параметров (при необходимости). Передаваемые параметры должны соответствовать порядку объявления и типу внешних (extern) переменных пользовательского индикатора.
      </parameter>
      <parameter>
        type=int
        name=mode
        description=Индекс линии индикатора. Может быть от 0 до 7 и должен соответствовать индексу, используемому одной из функций <a href="help://customind_SetIndexBuffer">SetIndexBuffer</a>.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из индикаторного буфера (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>

    <function>
      tag=indicators_iDeMarker
      caption=iDeMarker() - DeMarker (Индикатор Демарка)
      type=double
      <content>
      Расчет индикатора DeMarker.
      </content>
      <example>
  double val=iDeMarker(NULL, 0, 13, 1);
      </example>
      <parameter>
        type=string
        name=symbol
        description=Символьное имя инструмента, на данных которого будет вычисляться индикатор. NULL означает текущий символ.
      </parameter>
      <parameter>
        type=int
        name=timeframe
        description=Период. Может быть одним из <a href="help://constants_timeframes">периодов графика</a>. 0 означает период текущего графика.
      </parameter>
      <parameter>
        type=int
        name=period
        description=Период усреднения для вычисления индикатора.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из индикаторного буфера (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>

    <function>
      tag=indicators_iEnvelopes
      caption=iEnvelopes() - Envelopes (Огибающие линии)
      type=double
      <content>
      Расчет индикатора Envelopes.
      </content>
      <example>
  double val=iEnvelopes(NULL, 0, 13,MODE_SMA,10,PRICE_CLOSE,0.2,MODE_UPPER,0);
      </example>
      <parameter>
        type=string
        name=symbol
        description=Символьное имя инструмента, на данных которого будет вычисляться индикатор. NULL означает текущий символ.
      </parameter>
      <parameter>
        type=int
        name=timeframe
        description=Период. Может быть одним из <a href="help://constants_timeframes">периодов графика</a>. 0 означает период текущего графика.
      </parameter>
      <parameter>
        type=int
        name=ma_period
        description=Период усреднения основной линии индикатора.
      </parameter>
      <parameter>
        type=int
        name=ma_method
        description=Метод усреднения. Может быть любым из значений <a href="help://constants_movings">методов скользящего среднего (Moving Average)</a>.
      </parameter>
      <parameter>
        type=int
        name=ma_shift
        description=Сдвиг индикатора относительно ценового графика.
      </parameter>
      <parameter>
        type=int
        name=applied_price
        description=Используемая цена. Может быть любой из <a href="help://constants_prices">ценовых констант</a>.
      </parameter>
      <parameter>
        type=double
        name=deviation
        description=Отклонение от основной линии в процентах.
      </parameter>
      <parameter>
        type=int
        name=mode
        description=Индекс линии индикатора. Может быть любым из значений <a href="help://constants_lines">идентификаторов линий индикаторов</a>.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из индикаторного буфера (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>

    <function>
      tag=indicators_iEnvelopesOnArray
      caption=iEnvelopesOnArray() - Envelopes on buffer (Огибающие линии)
      type=double
      <content>
        Расчет индикатора Envelopes на данных, хранящихся в массиве.
        В отличие от iEnvelopes(...) функция iEnvelopesOnArray не выбирает данные на основе названия инструмента,
        таймфрейма и используемой цены - ценовые данные должны быть подготовлены заранее.
        Расчет производится слева направо. Для организации доступа к элементам массива, как к таймсерии
        (то есть справа налево), необходимо использовать функцию <a href="help://array_ArraySetAsSeries">ArraySetAsSeries</a>.
      </content>
      <example>
  double val=iEnvelopesOnArray(ExtBuffer,10,13,MODE_SMA,0,0.2,MODE_UPPER,0);
      </example>
      <parameter>
        type=double
        name=<nobr>array[]</nobr>
        description=Массив с данными.
      </parameter>
      <parameter>
        type=int
        name=total
        description=Количество элементов для вычисления. 0 означает все элементы массива.
      </parameter>
      <parameter>
        type=int
        name=ma_period
        description=Период усреднения основной линии индикатора.
      </parameter>
      <parameter>
        type=int
        name=ma_method
        description=Метод усреднения. Может быть любым из значений <a href="help://constants_movings">методов скользящей средней (Moving Average)</a>.
      </parameter>
      <parameter>
        type=int
        name=ma_shift
        description=Сдвиг индикатора относительно ценового графика.
      </parameter>
      <parameter>
        type=double
        name=deviation
        description=Отклонение от основной линии в процентах.
      </parameter>
      <parameter>
        type=int
        name=mode
        description=Индекс линии индикатора. Может быть любым из значений <a href="help://constants_lines">идентификаторов линий индикаторов</a>.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из индикаторного буфера (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>

    <function>
      tag=indicators_iForce
      caption=iForce() - Force Index (Индекс Силы)
      type=double
      <content>
      Расчет Force Index.
      </content>
      <example>
  double val=iForce(NULL, 0, 13,MODE_SMA,PRICE_CLOSE,0);
      </example>
      <parameter>
        type=string
        name=symbol
        description=Символьное имя инструмента, на данных которого будет вычисляться индикатор. NULL означает текущий символ.
      </parameter>
      <parameter>
        type=int
        name=timeframe
        description=Период. Может быть одним из <a href="help://constants_timeframes">периодов графика</a>. 0 означает период текущего графика.
      </parameter>
      <parameter>
        type=int
        name=period
        description=Период усреднения для вычисления индикатора.
      </parameter>
      <parameter>
        type=int
        name=ma_method
        description=Метод усреднения. Может быть любым из значений <a href="help://constants_movings">методов скользящей средней (Moving Average)</a>.
      </parameter>
      <parameter>
        type=int
        name=applied_price
        description=Используемая цена. Может быть любой из <a href="help://constants_prices">ценовых констант</a>.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из индикаторного буфера (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>

    <function>
      tag=indicators_iFractals
      caption=iFractals() - Fractals (Фракталы)
      type=double
      <content>
      Расчет индикатора Fractals.
      </content>
      <example>
  double val=iFractals(NULL, 0, MODE_UPPER, 3);
      </example>
      <parameter>
        type=string
        name=symbol
        description=Символьное имя инструмента, на данных которого будет вычисляться индикатор. NULL означает текущий символ.
      </parameter>
      <parameter>
        type=int
        name=timeframe
        description=Период. Может быть одним из <a href="help://constants_timeframes">периодов графика</a>. 0 означает период текущего графика.
      </parameter>
      <parameter>
        type=int
        name=mode
        description=Индекс линии индикатора. Может быть любым из значений <a href="help://constants_lines">идентификаторов линии индикаторов</a>.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из индикаторного буфера (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>

    <function>
      tag=indicators_iGator
      caption=iGator() - Gator Oscillator (Гатор Осциллятор)
      type=double
      <content>
      Расчет осциллятора Gator. Осциллятор показывает разницу между синей и красной линией <a href="help://indicators_iAlligator">Аллигатора</a> (верхняя гистограмма) и разницу между красной и зеленой линией (нижняя гистограмма).
      </content>
      <example>
  double diff=iGator(NULL, 0, 13, 8, 8, 5, 5, 3, MODE_SMMA, PRICE_MEDIAN, MODE_UPPER, 1);
      </example>
      <parameter>
        type=string
        name=symbol
        description=Символьное имя инструмента, на данных которого будет вычисляться индикатор. NULL означает текущий символ.
      </parameter>
      <parameter>
        type=int
        name=timeframe
        description=Период. Может быть одним из <a href="help://constants_timeframes">периодов графика</a>. 0 означает период текущего графика.
      </parameter>
      <parameter>
        type=int
        name=jaw_period
        description=Период усреднения синей линии (челюсти аллигатора).
      </parameter>
      <parameter>
        type=int
        name=jaw_shift
        description=Смещение синей линии относительно графика цены.
      </parameter>
      <parameter>
        type=int
        name=teeth_period
        description=Период усреднения красной линии (зубов аллигатора).
      </parameter>
      <parameter>
        type=int
        name=teeth_shift
        description=Смещение красной линии относительно графика цены.
      </parameter>
      <parameter>
        type=int
        name=lips_period
        description=Период усреднения зеленой линии (губ аллигатора).
      </parameter>
      <parameter>
        type=int
        name=lips_shift
        description=Смещение зеленой линии относительно графика цены.
      </parameter>
      <parameter>
        type=int
        name=ma_method
        description=Метод усреднения. Может быть любым из значений <a href="help://constants_movings">методов скользящей средней (Moving Average)</a>.
      </parameter>
      <parameter>
        type=int
        name=applied_price
        description=Используемая цена. Может быть любой из <a href="help://constants_prices">ценовых констант</a>.
      </parameter>
      <parameter>
        type=int
        name=mode
        description=Индекс линии индикатора. Может быть любым из значений <a href="help://constants_lines">идентификаторов линии индикаторов</a>.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из индикаторного буфера (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>

    <function>
      tag=indicators_iIchimoku
      caption=iIchimoku() - Ichimoku Kinko Hyo (Ишимоку Кинко Хайо)
      type=double
      <content>
      Расчет индикатора Ichimoku Kinko Hyo.
      </content>
      keywords=;MODE_TENKANSEN;MODE_KIJUNSEN;MODE_SENKOUSPANA;MODE_SENKOUSPANB;MODE_CHINKOUSPAN;
      <example>
  double tenkan_sen=iIchimoku(NULL, 0, 9, 26, 52, MODE_TENKANSEN, 1);
      </example>
      <parameter>
        type=string
        name=symbol
        description=Символьное имя инструмента, на данных которого будет вычисляться индикатор. NULL означает текущий символ.
      </parameter>
      <parameter>
        type=int
        name=timeframe
        description=Период. Может быть одним из <a href="help://constants_timeframes">периодов графика</a>. 0 означает период текущего графика.
      </parameter>
      <parameter>
        type=int
        name=tenkan_sen
        description=Период усреднения Tenkan Sen.
      </parameter>
      <parameter>
        type=int
        name=kijun_sen
        description=Период усреднения Kijun Sen.
      </parameter>
      <parameter>
        type=int
        name=senkou_span_b
        description=Период усреднения Senkou Span B.
      </parameter>
      <parameter>
        type=int
        name=mode
        description=Источник данных. Может быть одним из перечисленных <a href="help://constants_ichimoku">идентификаторов Ichimoku Kinko Hyo</a>.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из индикаторного буфера (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>

    <function>
      tag=indicators_iBWMFI
      caption=iBWMFI() - Bill Williams Market Facilitation Index (Индекс Облегчения Рынка Билла Вильямса)
      type=double
      <content>
      Расчет Market Facilitation Index.
      </content>
      <example>
  double val=iBWMFI(NULL, 0, 0);
      </example>
      <parameter>
        type=string
        name=symbol
        description=Символьное имя инструмента, на данных которого будет вычисляться индикатор. NULL означает текущий символ.
      </parameter>
      <parameter>
        type=int
        name=timeframe
        description=Период. Может быть одним из <a href="help://constants_timeframes">периодов графика</a>. 0 означает период текущего графика.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из индикаторного буфера (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>

    <function>
      tag=indicators_iMomentum
      caption=iMomentum() - Momentum (Темп Изменения Цены)
      type=double
      <content>
      Расчет индикатора Momentum.
      </content>
      example=if(iMomentum(NULL,0,12,PRICE_CLOSE,0)&gt;iMomentum(NULL,0,20,PRICE_CLOSE,0)) return(0);
      <parameter>
        type=string
        name=symbol
        description=Символьное имя инструмента, на данных которого будет вычисляться индикатор. NULL означает текущий символ.
      </parameter>
      <parameter>
        type=int
        name=timeframe
        description=Период. Может быть одним из <a href="help://constants_timeframes">периодов графика</a>. 0 означает период текущего графика.
      </parameter>
      <parameter>
        type=int
        name=period
        description=Период(количество баров) для вычисления изменения цены.
      </parameter>
      <parameter>
        type=int
        name=applied_price
        description=Используемая цена. Может быть любой из <a href="help://constants_prices">ценовых констант</a>.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из индикаторного буфера (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>

    <function>
      tag=indicators_iMomentumOnArray
      caption=iMomentumOnArray() - Momentum on buffer (Темп Изменения Цены)
      type=double
      <content>
        Расчет индикатора Momentum на данных, хранящихся в массиве.
        В отличие от iMomentum(...) функция iMomentumOnArray не выбирает данные на основе названия инструмента,
        таймфрейма и используемой цены - ценовые данные должны быть подготовлены заранее.
        Расчет производится слева направо. Для организации доступа к элементам массива, как к таймсерии
        (то есть справа налево), необходимо использовать функцию <a href="help://array_ArraySetAsSeries">ArraySetAsSeries</a>.
      </content>
      example=if(iMomentumOnArray(mybuffer,100,12,0)&gt;iMomentumOnArray(mubuffer,100,20,0)) return(0);
      <parameter>
        type=double
        name=<nobr>array[]</nobr>
        description=Массив с данными.
      </parameter>
      <parameter>
        type=int
        name=total
        description=Количество элементов для вычисления. 0 означает все элементы массива.
      </parameter>
      <parameter>
        type=int
        name=period
        description=Период(количество баров) для вычисления изменения цены.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из индикаторного буфера (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>

    <function>
      tag=indicators_iMFI
      caption=iMFI() - Money Flow Index (Индекс Денежных Потоков)
      type=double
      <content>
      Расчет Money Flow Index.
      </content>
      example=if(iMFI(NULL,0,14,0)&gt;iMFI(NULL,0,14,1)) return(0);
      <parameter>
        type=string
        name=symbol
        description=Символьное имя инструмента, на данных которого будет вычисляться индикатор. NULL означает текущий символ.
      </parameter>
      <parameter>
        type=int
        name=timeframe
        description=Период. Может быть одним из <a href="help://constants_timeframes">периодов графика</a>. 0 означает период текущего графика.
      </parameter>
      <parameter>
        type=int
        name=period
        description=Период(количество баров) для вычисления индикатора.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из индикаторного буфера (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>

    <function>
      tag=indicators_iMA
      caption=iMA() - Moving Average (Скользящее Среднее)
      type=double
      <content>
      Расчет скользящего среднего.
      </content>
      example=AlligatorJawsBuffer[i]=iMA(NULL,0,13,8,MODE_SMMA,PRICE_MEDIAN,i);
      <parameter>
        type=string
        name=symbol
        description=Символьное имя инструмента, на данных которого будет вычисляться индикатор. NULL означает текущий символ.
      </parameter>
      <parameter>
        type=int
        name=timeframe
        description=Период. Может быть одним из <a href="help://constants_timeframes">периодов графика</a>. 0 означает период текущего графика.
      </parameter>
      <parameter>
        type=int
        name=period
        description=Период усреднения для вычисления скользящего среднего.
      </parameter>
      <parameter>
        type=int
        name=ma_shift
        description=Сдвиг индикатора относительно ценового графика.
      </parameter>
      <parameter>
        type=int
        name=ma_method
        description=Метод усреднения. Может быть любым из значений <a href="help://constants_movings">методов скользящего среднего (Moving Average)</a>.
      </parameter>
      <parameter>
        type=int
        name=applied_price
        description=Используемая цена. Может быть любой из <a href="help://constants_prices">ценовых констант</a>.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из индикаторного буфера (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>

    <function>
      tag=indicators_iMAOnArray
      caption=iMAOnArray() - Moving Average on buffer (Скользящее Среднее) 
      type=double
      <content>
        Расчет скользящего среднего на данных, хранящихся в массиве.
        В отличие от iMA(...) функция iMAOnArray не выбирает данные на основе названия инструмента,
        таймфрейма и используемой цены - ценовые данные должны быть подготовлены заранее.
        Расчет производится слева направо. Для организации доступа к элементам массива, как к таймсерии
        (то есть справа налево), необходимо использовать функцию <a href="help://array_ArraySetAsSeries">ArraySetAsSeries</a>.
      </content>
      <example>
   double macurrent=iMAOnArray(ExtBuffer,0,5,0,MODE_LWMA,0);
   double macurrentslow=iMAOnArray(ExtBuffer,0,10,0,MODE_LWMA,0);
   double maprev=iMAOnArray(ExtBuffer,0,5,0,MODE_LWMA,1);
   double maprevslow=iMAOnArray(ExtBuffer,0,10,0,MODE_LWMA,1);
   //----
   if(maprev&lt;maprevslow &amp;&amp; macurrent&gt;=macurrentslow)
     Alert(&quot;crossing up&quot;);
      </example>
      <parameter>
        type=double
        name=<nobr>array[]</nobr>
        description=Массив с данными.
      </parameter>
      <parameter>
        type=int
        name=total
        description=Количество элементов для вычисления. 0 означает все элементы массива.
      </parameter>
      <parameter>
        type=int
        name=period
        description=Период усреднения для вычисления скользящего среднего.
      </parameter>
      <parameter>
        type=int
        name=ma_shift
        description=Сдвиг индикатора относительно ценового графика.
      </parameter>
      <parameter>
        type=int
        name=ma_method
        description=Метод усреднения. Может быть любым из значений <a href="help://constants_movings">методов скользящего среднего (Moving Average)</a>.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из индикаторного буфера (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>

    <function>
      tag=indicators_iOsMA
      caption=iOsMA() - Moving Average of Oscillator (Осциллятор Скользящих Средних)
      type=double
      <content>
      Расчет Moving Average of Oscillator. Осциллятор OsMA показывает разницу между значениями <a href="help://indicators_iMACD">MACD</a> и его сигнальной линии. В некоторых системах этот осциллятор называется гистограммой MACD.
      </content>
      example=if(iOsMA(NULL,0,12,26,9,PRICE_OPEN,1)&gt;iOsMA(NULL,0,12,26,9,PRICE_OPEN,0)) return(0);
      <parameter>
        type=string
        name=symbol
        description=Символьное имя инструмента, на данных которого будет вычисляться индикатор. NULL означает текущий символ.
      </parameter>
      <parameter>
        type=int
        name=timeframe
        description=Период. Может быть одним из <a href="help://constants_timeframes">периодов графика</a>. 0 означает период текущего графика.
      </parameter>
      <parameter>
        type=int
        name=fast_ema_period
        description=Период усреднения для вычисления быстрой скользящей средней.
      </parameter>
      <parameter>
        type=int
        name=slow_ema_period
        description=Период усреднения для вычисления медленной скользящей средней.
      </parameter>
      <parameter>
        type=int
        name=signal_period
        description=Период усреднения для вычисления сигнальной линии.
      </parameter>
      <parameter>
        type=int
        name=applied_price
        description=Используемая цена. Может быть любой из <a href="help://constants_prices">ценовых констант</a>.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из индикаторного буфера (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>

    <function>
      tag=indicators_iMACD
      caption=iMACD() - Moving Averages Convergence/Divergence (Cхождение/Расхождение Скользящих Средних)
      type=double
      <content>
      Расчет индикатора Moving Averages Convergence/Divergence. В тех системах, где ОsМА называют гистограммой МАКД, данный индикатгор изображается в виде двух линий.
      В клиентском терминале схожденние/расхождение скользящих средних рисуется в виде гистограммы.
      </content>
      example=if(iMACD(NULL,0,12,26,9,PRICE_CLOSE,MODE_MAIN,0)&gt;iMACD(NULL,0,12,26,9,PRICE_CLOSE,MODE_SIGNAL,0)) return(0);
      <parameter>
        type=string
        name=symbol
        description=Символьное имя инструмента, на данных которого будет вычисляться индикатор. NULL означает текущий символ.
      </parameter>
      <parameter>
        type=int
        name=timeframe
        description=Период. Может быть одним из <a href="help://constants_timeframes">периодов графика</a>. 0 означает период текущего графика.
      </parameter>
      <parameter>
        type=int
        name=fast_ema_period
        description=Период усреднения для вычисления быстрой скользящей средней.
      </parameter>
      <parameter>
        type=int
        name=slow_ema_period
        description=Период усреднения для вычисления медленной скользящей средней.
      </parameter>
      <parameter>
        type=int
        name=signal_period
        description=Период усреднения для вычисления сигнальной линии.
      </parameter>
      <parameter>
        type=int
        name=applied_price
        description=Используемая цена. Может быть любой из <a href="help://constants_prices">ценовых констант</a>.
      </parameter>
      <parameter>
        type=int
        name=mode
        description=Индекс линии индикатора. Может быть любым из значений <a href="help://constants_lines">идентификаторов линии индикаторов</a>.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из индикаторного буфера (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>

    <function>
      tag=indicators_iOBV
      caption=iOBV() - On Balance Volume (Балансовый Объем)
      type=double
      <content>
      Расчет индикатора On Balance Volume.
      </content>
      <example>
  double val=iOBV(NULL, 0, PRICE_CLOSE, 1);
      </example>
      <parameter>
        type=string
        name=symbol
        description=Символьное имя инструмента, на данных которого будет вычисляться индикатор. NULL означает текущий символ.
      </parameter>
      <parameter>
        type=int
        name=timeframe
        description=Период. Может быть одним из <a href="help://constants_timeframes">периодов графика</a>. 0 означает период текущего графика.
      </parameter>
      <parameter>
        type=int
        name=applied_price
        description=Используемая цена. Может быть любой из <a href="help://constants_prices">ценовых констант</a>.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из индикаторного буфера (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>

    <function>
      tag=indicators_iSAR
      caption=iSAR() - Parabolic SAR (Параболическая система SAR)
      type=double
      <content>
      Расчет индикатора Parabolic Stop and Reverse system.
      </content>
      example=if(iSAR(NULL,0,0.02,0.2,0)&gt;Close[0]) return(0);
      <parameter>
        type=string
        name=symbol
        description=Символьное имя инструмента, на данных которого будет вычисляться индикатор. NULL означает текущий символ.
      </parameter>
      <parameter>
        type=int
        name=timeframe
        description=Период. Может быть одним из <a href="help://constants_timeframes">периодов графика</a>. 0 означает период текущего графика.
      </parameter>
      <parameter>
        type=double
        name=step
        description=Приращение уровня стопа, обычно 0.02.
      </parameter>
      <parameter>
        type=double
        name=maximum
        description=Максимальный уровень стопа, обычно 0.2.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из индикаторного буфера (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>

    <function>
      tag=indicators_iRSI
      caption=iRSI() - Relative Strength Index (Индекс Относительной Силы)
      type=double
      <content>
      Расчет Relative Strength Index.
      </content>
      example=if(iRSI(NULL,0,14,PRICE_CLOSE,0)&gt;iRSI(NULL,0,14,PRICE_CLOSE,1)) return(0);
      <parameter>
        type=string
        name=symbol
        description=Символьное имя инструмента, на данных которого будет вычисляться индикатор. NULL означает текущий символ.
      </parameter>
      <parameter>
        type=int
        name=timeframe
        description=Период. Может быть одним из <a href="help://constants_timeframes">периодов графика</a>. 0 означает период текущего графика.
      </parameter>
      <parameter>
        type=int
        name=period
        description=Период усреднения для вычисления индекса.
      </parameter>
      <parameter>
        type=int
        name=applied_price
        description=Используемая цена. Может быть любой из <a href="help://constants_prices">ценовых констант</a>.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из индикаторного буфера (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>

    <function>
      tag=indicators_iRSIOnArray
      caption=iRSIOnArray() - Relative Strength Index on buffer (Индекс Относительной Силы)
      type=double
      <content>
        Расчет индикатора Relative Strength Index на данных, хранящихся в массиве.
        В отличие от iRSI(...) функция iRSI не выбирает данные на основе названия инструмента,
        таймфрейма и используемой цены - ценовые данные должны быть подготовлены заранее.
        Расчет производится слева направо. Для организации доступа к элементам массива, как к таймсерии
        (то есть справа налево), необходимо использовать функцию <a href="help://array_ArraySetAsSeries">ArraySetAsSeries</a>.
      </content>
      example=if(iRSIOnArray(ExtBuffer,1000,14,0)&gt;iRSI(NULL,0,14,PRICE_CLOSE,1)) return(0);
      <parameter>
        type=double
        name=<nobr>array[]</nobr>
        description=Массив с данными.
      </parameter>
      <parameter>
        type=int
        name=total
        description=Количество элементов для вычисления. 0 означает все элементы массива.
      </parameter>
      <parameter>
        type=int
        name=period
        description=Период усреднения для вычисления индекса.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из индикаторного буфера (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>

    <function>
      tag=indicators_iRVI
      caption=iRVI() - Relative Vigor Index (Индекс Относительной Бодрости)
      type=double
      <content>
      Расчет Relative Vigor Index.
      </content>
      <example>
  double val=iRVI(NULL, 0, 10,MODE_MAIN,0);
      </example>
      <parameter>
        type=string
        name=symbol
        description=Символьное имя инструмента, на данных которого будет вычисляться индикатор. NULL означает текущий символ.
      </parameter>
      <parameter>
        type=int
        name=timeframe
        description=Период. Может быть одним из <a href="help://constants_timeframes">периодов графика</a>. 0 означает период текущего графика.
      </parameter>
      <parameter>
        type=int
        name=period
        description=Период усреднения для вычисления индекса.
      </parameter>
      <parameter>
        type=int
        name=mode
        description=Индекс линии индикатора. Может быть любым из значений <a href="help://constants_lines">идентификаторов линии индикаторов</a>.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из индикаторного буфера (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>

    <function>
      tag=indicators_iStdDev
      caption=iStdDev() - Standard Deviation (Стандартное Отклонение)
      type=double
      <content>
      Расчет индикатора Standard Deviation.
      </content>
      example=double val=iStdDev(NULL,0,10,0,MODE_EMA,PRICE_CLOSE,0);
      <parameter>
        type=string
        name=symbol
        description=Символьное имя инструмента, на данных которого будет вычисляться индикатор. NULL означает текущий символ.
      </parameter>
      <parameter>
        type=int
        name=timeframe
        description=Период. Может быть одним из <a href="help://constants_timeframes">периодов графика</a>. 0 означает период текущего графика.
      </parameter>
      <parameter>
        type=int
        name=ma_period
        description=Период усреднения для вычисления индикатора.
      </parameter>
      <parameter>
        type=int
        name=ma_shift
        description=Сдвиг индикатора относительно ценового графика.
      </parameter>
      <parameter>
        type=int
        name=ma_method
        description=Метод усреднения. Может быть любым из значений <a href="help://constants_movings">методов скользящего среднего (Moving Average)</a>.
      </parameter>
      <parameter>
        type=int
        name=applied_price
        description=Используемая цена. Может быть любой из <a href="help://constants_prices">ценовых констант</a>.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из индикаторного буфера (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>

    <function>
      tag=indicators_iStdDevOnArray
      caption=iStdDevOnArray() - Standard Deviation on buffer (Стандартное Отклонение)
      type=double
      <content>
        Расчет индикатора Standard Deviation на данных, хранящихся в массиве.
        В отличие от iStdDev(...) функция iStdDevOnArray не выбирает данные на основе названия инструмента,
        таймфрейма и используемой цены - ценовые данные должны быть подготовлены заранее.
        Расчет производится слева направо. Для организации доступа к элементам массива, как к таймсерии
        (то есть справа налево), необходимо использовать функцию <a href="help://array_ArraySetAsSeries">ArraySetAsSeries</a>.
      </content>
      example=double val=iStdDevOnArray(ExtBuffer,100,10,0,MODE_EMA,0);
      <parameter>
        type=double
        name=<nobr>array[]</nobr>
        description=Массив с данными.
      </parameter>
      <parameter>
        type=int
        name=total
        description=Количество элементов для вычисления. 0 означает все элементы массива.
      </parameter>
      <parameter>
        type=int
        name=ma_period
        description=Период усреднения для вычисления индикатора.
      </parameter>
      <parameter>
        type=int
        name=ma_shift
        description=Сдвиг индикатора относительно ценового графика.
      </parameter>
      <parameter>
        type=int
        name=ma_method
        description=Метод усреднения. Может быть любым из значений <a href="help://constants_movings">методов скользящего среднего (Moving Average)</a>.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из индикаторного буфера (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>

    <function>
      tag=indicators_iStochastic
      caption=iStochastic() - Stochastic Oscillator (Стохастический Осциллятор)
      type=double
      <content>
      Расчет Stochastic Oscillator.
      </content>
      <example>
  if(iStochastic(NULL,0,5,3,3,MODE_SMA,0,MODE_MAIN,0)&gt;iStochastic(NULL,0,5,3,3,MODE_SMA,0,MODE_SIGNAL,0))
    return(0);
      </example>
      <parameter>
        type=string
        name=symbol
        description=Символьное имя инструмента, на данных которого будет вычисляться индикатор. NULL означает текущий символ.
      </parameter>
      <parameter>
        type=int
        name=timeframe
        description=Период. Может быть одним из <a href="help://constants_timeframes">периодов графика</a>. 0 означает период текущего графика.
      </parameter>
      <parameter>
        type=int
        name=%Kperiod
        description=Период(количество баров) для вычисления линии %K.
      </parameter>
      <parameter>
        type=int
        name=%Dperiod
        description=Период усреднения для вычисления линии %D.
      </parameter>
      <parameter>
        type=int
        name=slowing
        description=Значение замедления.
      </parameter>
      <parameter>
        type=int
        name=method
        description=Метод усреднения. Может быть любым из значений <a href="help://constants_movings">методов скользящего среднего (Moving Average)</a>.
      </parameter>
      <parameter>
        type=int
        name=price_field
        description=Параметр выбора цен для расчета. Может быть одной из следующих величин: 0 - Low/High или 1 - Close/Close.
      </parameter>
      <parameter>
        type=int
        name=mode
        description=Индекс линии индикатора. Может быть любым из значений <a href="help://constants_lines">идентификаторов линий индикаторов</a>.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из индикаторного буфера (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>

    <function>
      tag=indicators_iWPR
      caption=iWPR() - Williams' Percent Range (Процентный Диапазон Ларри Уильямса)
      type=double
      <content>
      Расчет индикатора Larry Williams' Percent Range.
      </content>
      example=if(iWPR(NULL,0,14,0)&gt;iWPR(NULL,0,14,1)) return(0);
      <parameter>
        type=string
        name=symbol
        description=Символьное имя инструмента, на данных которого будет вычисляться индикатор. NULL означает текущий символ.
      </parameter>
      <parameter>
        type=int
        name=timeframe
        description=Период. Может быть одним из <a href="help://constants_timeframes">периодов графика</a>. 0 означает период текущего графика.
      </parameter>
      <parameter>
        type=int
        name=period
        description=Период(количество баров) для вычисления индикатора.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из индикаторного буфера (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>
  </group>

  <group>
    tag=series
    caption=Доступ к таймсериям
    <content>
    Группа функций, предназначенных для доступа к ценовым данным любого доступного символа/периода.<br/><br/>
    Если запрашивается информация с другого графика (название <a href="help://windows_Symbol">инструмента</a> и/или <a href="help://windows_Period">значение таймфрейма</a>
    отличаются от текущих), то возможна ситуация, что в клиентском терминале не открыт соответствующий график и необходимые данные должны быть запрошены у сервера.
    В этом случае в переменную <a href="help://runtime_errors">last_error</a> будет помещена <a href="help://constants_errors">ошибка</a> ERR_HISTORY_WILL_UPDATED
    (4066 - запрошенные исторические данные в состоянии обновления) и необходимо через некоторое время повторить попытку запроса
    (см. пример <a href="help://array_ArrayCopySeries">ArrayCopySeries()</a>).<br/><br/>
    При тестировании ценовые данные того же самого символа, но другого таймфрейма, моделируются точно, за исключением объемов. Объемы других таймфреймов не моделируются.
    Ценовые данные других символов не моделируются. Во всех случаях количество <a href="help://series_iBars">баров</a> в таймсериях моделируется точно.
    </content>

    <function>
      tag=series_iBars
      caption=iBars()
      type=int
      <content>
Возвращает количество баров на определенном графике.<br/>
Для текущего графика информация о количестве баров находится в предопределенной переменной <a href="help://predefined_variables_Bars">Bars</a>.
      </content>
      <example>
  Print(&quot;Bar count on the 'EURUSD,H1' is &quot;,iBars(&quot;EURUSD&quot;,PERIOD_H1));
      </example>
      <parameter>
        type=string
        name=symbol
        description=Символьное имя инструмента. NULL означает текущий символ.
      </parameter>
      <parameter>
        type=int
        name=timeframe
        description=Период. Может быть одним из <a href="help://constants_timeframes">периодов графика</a>. 0 означает период текущего графика.
      </parameter>
    </function>

    <function>
      tag=series_iBarShift
      caption=iBarShift()
      type=int
      <content>
Поиск бара по времени. Функция возвращает смещение бара, которому принадлежит указанное время.
Если для указанного времени бар отсутствует (&quot;дыра&quot; в истории), то функция возвращает,
в зависимости от параметра <i>exact</i>, -1 или смещение ближайшего бара.<br/>
      </content>
      <example>
  datetime some_time=D'2004.03.21 12:00';
  int      shift=iBarShift(&quot;EUROUSD&quot;,PERIOD_M1,some_time);
  Print(&quot;shift of bar with open time &quot;,TimeToStr(some_time),&quot; is &quot;,shift);
      </example>
      <parameter>
        type=string
        name=symbol
        description=Символьное имя инструмента. NULL означает текущий символ.
      </parameter>
      <parameter>
        type=int
        name=timeframe
        description=Период. Может быть одним из <a href="help://constants_timeframes">периодов графика</a>. 0 означает период текущего графика.
      </parameter>
      <parameter>
        type=datetime
        name=time
        description=Значение времени для поиска.
      </parameter>
      <parameter>
        type=bool
        name=exact
        def_value=false
        description=Возвращаемое значение если бар не найден. FALSE - iBarShift возвращает ближайший. TRUE - iBarShift возвращает -1.
      </parameter>
    </function>

    <function>
      tag=series_iClose
      caption=iClose()
      type=double
<content>
Возвращает значение цены закрытия указанного параметром <i>shift</i> бара с соответствующего графика (<i>symbol</i>, <i>timeframe</i>).
В случае ошибки функция возвращает 0. Для получения дополнительной информации об ошибке необходимо вызвать функцию <a href="help://check_GetLastError"> GetLastError()</a>.<br/>
Для текущего графика информация о ценах закрытия находится в предопределенном массиве <a href="help://predefined_variables_Close">Close[]</a>.
</content>
      <example>
  Print(&quot;Current bar for USDCHF H1: &quot;,iTime(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,  iOpen(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,
                                      iHigh(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,  iLow(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,
                                      iClose(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;, iVolume(&quot;USDCHF&quot;,PERIOD_H1,i));
      </example>
      <parameter>
        type=string
        name=symbol
        description=Символьное имя инструмента. NULL означает текущий символ.
      </parameter>
      <parameter>
        type=int
        name=timeframe
        description=Период. Может быть одним из <a href="help://constants_timeframes">периодов графика</a>. 0 означает период текущего графика.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из таймсерии (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>

    <function>
      tag=series_iHigh
      caption=iHigh()
      type=double
      <content>
Возвращает значение максимальной цены указанного параметром <i>shift</i> бара с соответствующего графика (<i>symbol</i>, <i>timeframe</i>).
В случае ошибки функция возвращает 0. Для получения дополнительной информации об ошибке необходимо вызвать функцию <a href="help://check_GetLastError"> GetLastError()</a>.<br/>
Для текущего графика информация о максимальных ценах находится в предопределенном массиве <a href="help://predefined_variables_High">High[]</a>.
      </content>
      <example>
  Print(&quot;Current bar for USDCHF H1: &quot;,iTime(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,  iOpen(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,
                                      iHigh(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,  iLow(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,
                                      iClose(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;, iVolume(&quot;USDCHF&quot;,PERIOD_H1,i));
      </example>
      <parameter>
        type=string
        name=symbol
        description=Символьное имя инструмента. NULL означает текущий символ.
      </parameter>
      <parameter>
        type=int
        name=timeframe
        description=Период. Может быть одним из <a href="help://constants_timeframes">периодов графика</a>. 0 означает период текущего графика.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из таймсерии (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>

    <function>
      tag=series_iHighest
      caption=iHighest()
      type=int
      <content>
      Возвращает индекс найденного наибольшего значения (смещение относительно текущего бара).
      </content>
      <example>
  double val;
  // расчет максимального значения цены на 20 последовательных барах
  // с индекса 4 по индекс 23 включительно на текущем графике
  val=High[iHighest(NULL,0,MODE_HIGH,20,4)];
      </example>
      <parameter>
        type=string
        name=symbol
        description=Символьное имя инструмента, на данных которого будет производиться поиск. NULL означает текущий символ.
      </parameter>
      <parameter>
        type=int
        name=timeframe
        description=Период. Может быть одним из <a href="help://constants_timeframes">периодов графика</a>. 0 означает период текущего графика.
      </parameter>
      <parameter>
        type=int
        name=type
        description=Идентификатор таймсерии. Может быть любым из значений <a href="help://constants_series">иденитификаторов таймсерий</a>.
      </parameter>
      <parameter>
        type=int
        name=count
        def_value=WHOLE_ARRAY
        description=Число элементов таймсерии (в направлении от текущего бара в сторону возрастания индекса), среди которых должен быть произведен поиск.
      </parameter>
      <parameter>
        type=int
        name=start
        def_value=0
        description=Индекс (смещение относительно текущего бара) начального бара, с которого начинается поиск наибольшего значения. Отрицательные значения игнорируются и заменяются нулевым значением.
      </parameter>
    </function>

    <function>
      tag=series_iLow
      caption=iLow()
      type=double
      <content>
Возвращает значение минимальной цены указанного параметром <i>shift</i> бара с соответствующего графика (<i>symbol</i>, <i>timeframe</i>).
В случае ошибки функция возвращает 0. Для получения дополнительной информации об ошибке необходимо вызвать функцию <a href="help://check_GetLastError"> GetLastError()</a>.<br/>
Для текущего графика информация о минимальных ценах находится в предопределенном массиве <a href="help://predefined_variables_Low">Low[]</a>.
      </content>
      <example>
  Print(&quot;Current bar for USDCHF H1: &quot;,iTime(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,  iOpen(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,
                                      iHigh(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,  iLow(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,
                                      iClose(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;, iVolume(&quot;USDCHF&quot;,PERIOD_H1,i));
      </example>
      <parameter>
        type=string
        name=symbol
        description=Символьное имя инструмента. NULL означает текущий символ.
      </parameter>
      <parameter>
        type=int
        name=timeframe
        description=Период. Может быть одним из <a href="help://constants_timeframes">периодов графика</a>. 0 означает период текущего графика.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из таймсерии (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>

    <function>
      tag=series_iLowest
      caption=iLowest()
      type=int
      <content>
      Возвращает индекс найденного наименьшего значения (смещение относительно текущего бара).
      </content>
      <example>
  double val=Low[iLowest(NULL,0,MODE_LOW,10,10)];
      </example>
      <parameter>
        type=string
        name=symbol
        description=Символьное имя инструмента, на данных которого будет производиться поиск. NULL означает текущий символ.
      </parameter>
      <parameter>
        type=int
        name=timeframe
        description= Период. Может быть одним из значений <a href="help://constants_timeframes">периодов графика</a>. 0 означает период текущего графика.
      </parameter>
      <parameter>
        type=int
        name=type
        description=Идентификатор таймсерии. Может быть любым из значений <a href="help://constants_series">идентификаторов таймсерий</a>.
      </parameter>
      <parameter>
        type=int
        name=count
        def_value=WHOLE_ARRAY
        description=Число элементов таймсерии (в направлении от текущего бара в сторону возрастания индекса), среди которых должен быть произведен поиск.
      </parameter>
      <parameter>
        type=int
        name=start
        def_value=0
        description=Смещение (относительно текущего) начального бара, с которого начинается поиск наименьшего значения.
      </parameter>
    </function>

    <function>
      tag=series_iOpen
      caption=iOpen()
      type=double
      <content>
Возвращает значение цены открытия указанного параметром <i>shift</i> бара с соответствующего графика (<i>symbol</i>, <i>timeframe</i>).
В случае ошибки функция возвращает 0. Для получения дополнительной информации об ошибке необходимо вызвать функцию <a href="help://check_GetLastError"> GetLastError()</a>.<br/>
Для текущего графика информация о ценах открытия находится в предопределенном массиве <a href="help://predefined_variables_Open">Open[]</a>.
      </content>
      <example>
  Print(&quot;Current bar for USDCHF H1: &quot;,iTime(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,  iOpen(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,
                                      iHigh(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,  iLow(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,
                                      iClose(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;, iVolume(&quot;USDCHF&quot;,PERIOD_H1,i));
      </example>
      <parameter>
        type=string
        name=symbol
        description=Символьное имя инструмента. NULL означает текущий символ.
      </parameter>
      <parameter>
        type=int
        name=timeframe
        description=Период. Может быть одним из <a href="help://constants_timeframes">периодов графика</a>. 0 означает период текущего графика.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из таймсерии (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>

    <function>
      tag=series_iTime
      caption=iTime()
      type=datetime
      <content>
Возвращает значение времени открытия указанного параметром <i>shift</i> бара с соответствующего графика (<i>symbol</i>, <i>timeframe</i>).
В случае ошибки функция возвращает 0. Для получения дополнительной информации об ошибке необходимо вызвать функцию <a href="help://check_GetLastError"> GetLastError()</a>.<br/>
Для текущего графика информация о времени открытия каждого бара находится в предопределенном массиве <a href="help://predefined_variables_Time">Time[]</a>.
      </content>
      <example>
  Print(&quot;Current bar for USDCHF H1: &quot;,iTime(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,  iOpen(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,
                                      iHigh(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,  iLow(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,
                                      iClose(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;, iVolume(&quot;USDCHF&quot;,PERIOD_H1,i));
      </example>
      <parameter>
        type=string
        name=symbol
        description=Символьное имя инструмента. NULL означает текущий символ.
      </parameter>
      <parameter>
        type=int
        name=timeframe
        description=Период. Может быть одним из <a href="help://constants_timeframes">периодов графика</a>. 0 означает период текущего графика.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из таймсерии (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>

    <function>
      tag=series_iVolume
      caption=iVolume()
      type=double
      <content>
Возвращает значение тикового объема указанного параметром <i>shift</i> бара с соответствующего графика (<i>symbol</i>, <i>timeframe</i>).
В случае ошибки функция возвращает 0. Для получения дополнительной информации об ошибке необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.<br/>
Для текущего графика информация о тиковых объемах каждого бара находится в предопределенном массиве <a href="help://predefined_variables_Volume">Volume[]</a>.
      </content>
      <example>
  Print(&quot;Current bar for USDCHF H1: &quot;,iTime(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,  iOpen(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,
                                      iHigh(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,  iLow(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,
                                      iClose(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;, iVolume(&quot;USDCHF&quot;,PERIOD_H1,i));
      </example>
      <parameter>
        type=string
        name=symbol
        description=Символьное имя инструмента. NULL означает текущий символ.
      </parameter>
      <parameter>
        type=int
        name=timeframe
        description=Период. Может быть одним из <a href="help://constants_timeframes">периодов графика</a>. 0 означает период текущего графика.
      </parameter>
      <parameter>
        type=int
        name=shift
        description=Индекс получаемого значения из таймсерии (сдвиг относительно текущего бара на указанное количество периодов назад).
      </parameter>
    </function>
  </group>


  <group>
    tag=trading
    caption=Торговые функции
    <content>
    Группа функций, предназначенных для управления торговой деятельностью.<br/><br/>
    Торговые функции <a href="help://trading_OrderSend">OrderSend()</a>, <a href="help://trading_OrderClose">OrderClose</a>,
    <a href="help://trading_OrderCloseBy">OrderCloseBy</a>, <a href="help://trading_OrderDelete">OrderDelete</a> и <a href="help://trading_OrderModify">OrderModify</a>
    не могут быть вызваны из пользовательских индикаторов.<br/><br/>
    Торговые функции могут использоваться в экспертах и скриптах. Торговые функции могут быть вызваны только в том случае, если в свойствах соответствующего
    эксперта или скрипта включена галочка "Разрешить советнику торговать".<br/><br/>
    Для проведения торговых операций из экспертов и скриптов предусмотрен всего один поток, который запускается в программном торговом контексте (контекст
    автоматической торговли из экспертов и скриптов). Поэтому, если этот контекст занят торговой операцией какого-либо эксперта, то другой эксперт или скрипт не может
    в этот момент вызывать торговые функции из-за <a href="help://constants_errors">ошибки</a> 146 (ERR_TRADE_CONTEXT_BUSY). Для определения возможности выполнять торговые
    операции необходимо использовать функцию <a href="help://check_IsTradeAllowed">IsTradeAllowed()</a>. Для чёткого разделения доступа к торговому контексту можно
    использовать семафор на основе глобальной переменной, значение которой необходимо менять при помощи функции
    <a href="help://globals_GlobalVariableSetOnCondition">GlobalVariableSetOnCondition()</a>.
    </content>

    <text>
      tag=trading_errors
      caption=Ошибки исполнения
      <keywords>
      ;ERR_NO_ERROR;ERR_NO_RESULT;ERR_COMMON_ERROR;ERR_INVALID_TRADE_PARAMETERS;ERR_SERVER_BUSY;
      ;ERR_OLD_VERSION;ERR_NO_CONNECTION;ERR_TOO_FREQUENT_REQUESTS;
      ;ERR_ACCOUNT_DISABLED;ERR_INVALID_ACCOUNT;ERR_TRADE_TIMEOUT;ERR_INVALID_PRICE;ERR_INVALID_STOPS;
      ;ERR_INVALID_TRADE_VOLUME;ERR_MARKET_CLOSED;ERR_TRADE_DISABLED;ERR_NOT_ENOUGH_MONEY;ERR_PRICE_CHANGED;
      ;ERR_OFF_QUOTES;ERR_REQUOTE;ERR_ORDER_LOCKED;ERR_LONG_POSITIONS_ONLY_ALLOWED;
      ;ERR_TOO_MANY_REQUESTS;ERR_TRADE_MODIFY_DENIED;ERR_TRADE_CONTEXT_BUSY;ERR_TRADE_EXPIRATION_DENIED;
      </keywords>
      <content>
        <p>Любая торговая операция (функции <a href="help://trading_OrderSend">OrderSend()</a>, <a href="help://trading_OrderClose">OrderClose</a>,
        <a href="help://trading_OrderCloseBy">OrderCloseBy</a>, <a href="help://trading_OrderDelete">OrderDelete</a> или <a href="help://trading_OrderModify">OrderModify</a>)
        по ряду причин может завершиться неудачей и вернуть либо отрицательный <a href="help://trading_OrderSend">номер тикета</a>, либо FALSE.
        Причину неудачи можно выяснить, вызвав функцию <a href="help://check_GetLastError">GetLastError()</a>. Каждая ошибка должна быть обработана
        по-своему. Ниже в таблице приведены общие рекомендации.</p>

        <p>Коды ошибок, возвращаемые торговым сервером:</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums">
        <tr><th>Константа</th><th>Код</th><th>Описание</th></tr>
        <tr><td>ERR_NO_ERROR</td><td>0</td><td>Торговая операция прошла успешно.</td></tr>
        <tr><td>ERR_NO_RESULT</td><td>1</td><td><a href="help://trading_OrderModify">OrderModify</a> пытается изменить уже установленные значения такими же значениями.
                                                 Необходимо изменить одно или несколько значений и повторить попытку.</td></tr>
        <tr><td>ERR_COMMON_ERROR</td><td>2</td><td>Общая ошибка. Прекратить все попытки торговых операций до выяснения обстоятельств. Возможно перезагрузить операционную систему и клиентский терминал.</td></tr>
        <tr><td>ERR_INVALID_TRADE_PARAMETERS</td><td>3</td><td>В торговую функцию переданы неправильные параметры, например, неправильный символ, неопознанная
                                                 <a href="help://constants_trading">торговая операция</a>, отрицательное допустимое отклонение цены, несуществующий номер тикета и т.п.
                                                 Необходимо изменить логику программы.</td></tr>
        <tr><td>ERR_SERVER_BUSY</td><td>4</td><td>Торговый сервер занят. Можно повторить попытку через достаточно большой промежуток времени (от нескольких минут).</td></tr>
        <tr><td>ERR_OLD_VERSION</td><td>5</td><td>Старая версия клиентского терминала. Необходимо установить последнюю версию клиентского терминала.</td></tr>
        <tr><td>ERR_NO_CONNECTION</td><td>6</td><td>Нет связи с торговым сервером. Необходимо убедиться, что связь не нарушена (например, при помощи функции
                                                 <a href="help://check_IsConnected">IsConnected</a>) и через небольшой промежуток времени (от 5 секунд) повторить попытку.</td></tr>
        <tr><td>ERR_TOO_FREQUENT_REQUESTS</td><td>8</td><td>Слишком частые запросы. Необходимо уменьшить частоту запросов, изменить логику программы.</td></tr>
        <tr><td>ERR_ACCOUNT_DISABLED</td><td>64</td><td>Счет заблокирован. Необходимо прекратить все попытки торговых операций.</td></tr>
        <tr><td>ERR_INVALID_ACCOUNT</td><td>65</td><td>Неправильный номер счета. Необходимо прекратить все попытки торговых операций.</td></tr>
        <tr><td>ERR_TRADE_TIMEOUT</td><td>128</td><td>Истек срок ожидания совершения сделки. Прежде, чем производить повторную попытку (не менее, чем через 1 минуту),
                                                 необходимо убедиться, что торговая операция действительно не прошла (новая позиция не была открыта, либо существующий ордер не был
                                                 изменён или удалён, либо существующая позиция не была закрыта)</td></tr>
        <tr><td>ERR_INVALID_PRICE</td><td>129</td><td>Неправильная цена bid или ask, возможно, ненормализованная цена. Необходимо после задержки от 5 секунд обновить
                                                 <a href="help://predefined_variables">данные</a> при помощи функции <a href="help://windows_RefreshRates">RefreshRates</a> и повторить попытку.
                                                 Если ошибка не исчезает, необходимо прекратить все попытки торговых операций и изменить логику программы.</td></tr>
        <tr><td>ERR_INVALID_STOPS</td><td>130</td><td>Слишком близкие стопы или неправильно рассчитанные или ненормализованные цены в стопах (или в цене открытия отложенного
                                                 ордера). Попытку можно повторять только в том случае, если ошибка произошла из-за устаревания цены. Необходимо после задержки от 5 секунд
                                                 обновить <a href="help://predefined_variables">данные</a> при помощи функции <a href="help://windows_RefreshRates">RefreshRates</a> и повторить попытку.
                                                 Если ошибка не исчезает, необходимо прекратить все попытки торговых операций и изменить логику программы.</td></tr>
        <tr><td>ERR_INVALID_TRADE_VOLUME</td><td>131</td><td>Неправильный объем, ошибка в грануляции объема. Необходимо прекратить все попытки торговых операций и изменить логику программы.</td></tr>
        <tr><td>ERR_MARKET_CLOSED</td><td>132</td><td>Рынок закрыт. Можно повторить попытку через достаточно большой промежуток времени (от нескольких минут).</td></tr>
        <tr><td>ERR_TRADE_DISABLED</td><td>133</td><td>Торговля запрещена. Необходимо прекратить все попытки торговых операций.</td></tr>
        <tr><td>ERR_NOT_ENOUGH_MONEY</td><td>134</td><td>Недостаточно денег для совершения операции. Повторять сделку с теми же параметрами нельзя. Попытку можно повторить после задержки от 5 секунд,
                                                 уменьшив объем, но надо быть уверенным в достаточности средств для совершения операции.</td></tr>
        <tr><td>ERR_PRICE_CHANGED</td><td>135</td><td>Цена изменилась. Можно без задержки обновить <a href="help://predefined_variables">данные</a> при помощи функции
                                                 <a href="help://windows_RefreshRates">RefreshRates</a> и повторить попытку.</td></tr>
        <tr><td>ERR_OFF_QUOTES</td><td>136</td><td>Нет цен. Брокер по какой-то причине (например, в начале сессии цен нет, неподтвержденные цены, быстрый рынок) не дал цен или отказал.
                                                 Необходимо после задержки от 5 секунд обновить <a href="help://predefined_variables">данные</a> при помощи функции
                                                 <a href="help://windows_RefreshRates">RefreshRates</a> и повторить попытку.</td></tr>
        <tr><td>ERR_REQUOTE</td><td>138</td><td>Запрошенная цена устарела, либо перепутаны bid и ask. Можно без задержки обновить
                                                 <a href="help://predefined_variables">данные</a> при помощи функции <a href="help://windows_RefreshRates">RefreshRates</a> и повторить попытку.
                                                 Если ошибка не исчезает, необходимо прекратить все попытки торговых операций и изменить логику программы.</td></tr>
        <tr><td>ERR_ORDER_LOCKED</td><td>139</td><td>Ордер заблокирован и уже обрабатывается. Необходимо прекратить все попытки торговых операций  и изменить логику программы.</td></tr>
        <tr><td>ERR_LONG_POSITIONS_ONLY_ALLOWED</td><td>140</td><td>Разрешена только покупка. Повторять операцию SELL нельзя.</td></tr>
        <tr><td>ERR_TOO_MANY_REQUESTS</td><td>141</td><td>Слишком много запросов. Необходимо уменьшить частоту запросов, изменить логику программы.</td></tr>
        <tr><td>&nbsp;</td><td>142</td><td>Ордер поставлен в очередь. Это не ошибка, а один из кодов взаимодействия между клиентским терминалом и торговым сервером. Этот код может быть получен в редком случае, когда во время выполнения торговой операции произошёл обрыв и последующее восстановление связи. Необходимо обрабатывать так же как и ошибку 128.</td></tr>
        <tr><td>&nbsp;</td><td>143</td><td>Ордер принят дилером к исполнению. Один из кодов взаимодействия между клиентским терминалом и торговым сервером. Может возникнуть по той же причине, что и код 142. Необходимо обрабатывать так же как и ошибку 128.</td></tr>
        <tr><td>&nbsp;</td><td>144</td><td>Ордер аннулирован самим клиентом при ручном подтверждении сделки. Один из кодов взаимодействия между клиентским терминалом и торговым сервером.</td></tr>
        <tr><td>ERR_TRADE_MODIFY_DENIED</td><td>145</td><td>Модификация запрещена, так как ордер слишком близок к рынку и заблокирован из-за возможного скорого исполнения.
                                                 Можно не ранее, чем через 15 секунд, обновить <a href="help://predefined_variables">данные</a> при помощи функции <a href="help://windows_RefreshRates">RefreshRates</a>
                                                 и повторить попытку.</td></tr>
        <tr><td>ERR_TRADE_CONTEXT_BUSY</td><td>146</td><td>Подсистема торговли занята. Повторить попытку только после того, как функция <a href="help://check_IsTradeContextBusy">IsTradeContextBusy</a> вернет FALSE.</td></tr>
        <tr><td>ERR_TRADE_EXPIRATION_DENIED</td><td>147</td><td>Использование даты истечения ордера запрещено брокером. Операцию можно повторить только в том случае, если обнулить параметр expiration.</td></tr>
        <tr><td>ERR_TRADE_TOO_MANY_ORDERS</td><td>148</td><td>Количество открытых и отложенных ордеров достигло предела, установленного брокером. Новые открытые позиции и отложенные ордера возможны только после закрытия или удаления существующих позиций или ордеров.</td></tr>
        <tr><td>ERR_TRADE_HEDGE_PROHIBITED</td><td>149</td><td>Попытка открыть противоположную позицию к уже существующей в случае, если хеджирование запрещено. Сначала необходимо закрыть существующую противоположную позицию, либо отказаться от всех попыток таких торговых операций, либо изменить логику программы.</td></tr>
        <tr><td>ERR_TRADE_PROHIBITED_BY_FIFO</td><td>150</td><td>Попытка закрыть позицию по инструменту в противоречии с правилом FIFO. Сначала необходимо закрыть более ранние существующие позиции по данному инструменту, либо отказаться от всех попыток таких торговых операций, либо изменить логику программы.</td></tr>
        </table><br/>
      </content>
    </text>

    <function>
      tag=trading_OrderClose
      caption=OrderClose()
      type=bool
      <content>
Закрытие позиции.
Возвращает TRUE при успешном завершении функции.
Возвращает FALSE при неудачном завершении функции.
Чтобы получить информацию об ошибке, необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.
      </content>
      <example>
  if(iRSI(NULL,0,14,PRICE_CLOSE,0)&gt;75)
    {
     OrderClose(order_id,1,Ask,3,Red);
     return(0);
    }
      </example>
      <parameter>
        type=int
        name=ticket
        description=Уникальный порядковый номер ордера.
      </parameter>
      <parameter>
        type=double
        name=lots
        description=Количество лотов для закрытия.
      </parameter>
      <parameter>
        type=double
        name=price
        description=Цена закрытия.
      </parameter>
      <parameter>
        type=int
        name=slippage
        description=Значение максимального проскальзывания в пунктах.
      </parameter>
      <parameter>
        type=color
        name=Color
        def_value=CLR_NONE
        <description>
Цвет стрелки закрытия на графике. Если параметр отсутствует или его значение равно CLR_NONE, то стрелка на графике не отображается.
        </description>
      </parameter>
    </function>

    <function>
      tag=trading_OrderCloseBy
      caption=OrderCloseBy()
      type=bool
      <content>
Закрытие одной открытой позиции другой позицией, открытой по тому же самому инструменту, но в противоположном направлении.
Возвращает TRUE при успешном завершении функции.
Возвращает FALSE при неудачном завершении функции.
Чтобы получить информацию об ошибке, необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.
      </content>
      <example>
  if(iRSI(NULL,0,14,PRICE_CLOSE,0)&gt;75)
    {
     OrderCloseBy(order_id,opposite_id);
     return(0);
    }
      </example>
      <parameter>
        type=int
        name=ticket
        description=Уникальный порядковый номер закрываемого ордера.
      </parameter>
      <parameter>
        type=int
        name=opposite
        description=Уникальный порядковый номер противоположного ордера.
      </parameter>
      <parameter>
        type=color
        name=Color
        def_value=CLR_NONE
        <description>
Цвет стрелки закрытия на графике. Если параметр отсутствует или его значение равно CLR_NONE, то стрелка на графике не отображается.
        </description>
      </parameter>
    </function>

    <function>
      tag=trading_OrderClosePrice
      caption=OrderClosePrice()
      type=double
      <content>
Возвращает цену закрытия выбранного ордера.<br/>
Ордер должен быть предварительно выбран с помощью функции <a href="help://trading_OrderSelect">OrderSelect()</a>.
      </content>
      <example>
  if(OrderSelect(10,SELECT_BY_POS,MODE_HISTORY)==true)
    {
     datetime ctm=OrderOpenTime();
     if(ctm&gt;0) Print(&quot;Open time for the order 10 &quot;, ctm);
     ctm=OrderCloseTime();
     if(ctm&gt;0) Print(&quot;Close time for the order 10 &quot;, ctm);
    }
  else
    Print(&quot;OrderSelect failed error code is&quot;,GetLastError());
      </example>
    </function>

    <function>
      tag=trading_OrderCloseTime
      caption=OrderCloseTime()
      type=datetime
      <content>
Возвращает время закрытия для выбранного ордера. Только закрытые ордера имеют время закрытия, не равное 0. Открытые или отложенные ордера имеют время закрытия, равное 0.<br/>
Ордер должен быть предварительно выбран с помощью функции <a href="help://trading_OrderSelect">OrderSelect()</a>.
      </content>
      <example>
  if(OrderSelect(10,SELECT_BY_POS,MODE_HISTORY)==true)
    {
     datetime ctm=OrderOpenTime();
     int      ticket=OrderTicket();
     if(ctm&gt;0) Print(&quot;Время открытия ордера № &quot;,ticket,&quot; &quot;,ctm);
     ctm=OrderCloseTime();
     if(ctm&gt;0) Print(&quot;Время закрытия ордера № &quot;,ticket,&quot; &quot;,ctm);
    }
  else
    Print(&quot;OrderSelect() вернул ошибку &quot;,GetLastError());
      </example>
    </function>

    <function>
      tag=trading_OrderComment
      caption=OrderComment()
      type=string
      <content>
Возвращает комментарий для выбранного ордера.<br/>
Ордер должен быть предварительно выбран с помощью функции <a href="help://trading_OrderSelect">OrderSelect()</a>.
      </content>
      <example>
  string comment;
  if(OrderSelect(10,SELECT_BY_TICKET)==false)
    {
     Print(&quot;OrderSelect() вернул ошибку - &quot;,GetLastError());
     return(0);
    }
  comment = OrderComment();
  // ...
      </example>
    </function>

    <function>
      tag=trading_OrderCommission
      caption=OrderCommission()
      type=double
      <content>
Возвращает значение рассчитанной комиссии для выбранного ордера.<br/>
Ордер должен быть предварительно выбран с помощью функции <a href="help://trading_OrderSelect">OrderSelect()</a>.
      </content>
      <example>
  if(OrderSelect(10,SELECT_BY_POS)==true)
    Print(&quot;Commission for the order 10 &quot;,OrderCommission());
  else
    Print(&quot;OrderSelect() вернул ошибку - &quot;,GetLastError());
      </example>
    </function>

    <function>
      tag=trading_OrderDelete
      caption=OrderDelete()
      type=bool
      <content>
Удаляет ранее установленный отложенный ордер.
Возвращает TRUE при успешном завершении функции.
Возвращает FALSE при неудачном завершении функции.
Чтобы получить информацию об ошибке, необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.
      </content>
      <example>
  if(Ask&gt;var1)
    {
     OrderDelete(order_ticket);
     return(0);
    }
      </example>
      <parameter>
        type=int
        name=ticket
        description=Уникальный порядковый номер ордера.
      </parameter>
      <parameter>
        type=color
        name=arrow_color
        def_value=CLR_NONE
        <description>
Цвет стрелки на графике. Если параметр отсутствует или его значение равно CLR_NONE, то стрелка на графике не отображаются.
        </description>
      </parameter>
    </function>

    <function>
      tag=trading_OrderExpiration
      caption=OrderExpiration()
      type=datetime
      <content>
Возвращает дату истечения для выбранного отложенного ордера.<br/>
Ордер должен быть предварительно выбран с помощью функции <a href="help://trading_OrderSelect">OrderSelect()</a>.
      </content>
      <example>
  if(OrderSelect(10, SELECT_BY_TICKET)==true)
    Print(&quot;Order expiration for the order #10 is &quot;,OrderExpiration());
  else
    Print(&quot;OrderSelect() вернул ошибку - &quot;,GetLastError());
      </example>
    </function>

    <function>
      tag=trading_OrderLots
      caption=OrderLots()
      type=double
      <content>
Возвращает количество лотов для выбранного ордера.<br/>
Ордер должен быть предварительно выбран с помощью функции <a href="help://trading_OrderSelect">OrderSelect()</a>.
      </content>
      <example>
  if(OrderSelect(10,SELECT_BY_POS)==true)
    Print(&quot;lots for the order 10 &quot;,OrderLots());
  else
    Print(&quot;OrderSelect() вернул ошибку - &quot;,GetLastError());
      </example>
    </function>

    <function>
      tag=trading_OrderMagicNumber
      caption=OrderMagicNumber()
      type=int
      <content>
Возвращает идентификационное (&quot;магическое&quot;) число для выбранного ордера.<br/>
Ордер должен быть предварительно выбран с помощью функции <a href="help://trading_OrderSelect">OrderSelect()</a>.
      </content>
      <example>
  if(OrderSelect(10,SELECT_BY_POS)==true)
    Print(&quot;Magic number for the order 10 &quot;, OrderMagicNumber());
  else
    Print(&quot;OrderSelect() вернул ошибку - &quot;,GetLastError());
      </example>
    </function>

    <function>
      tag=trading_OrderModify
      caption=OrderModify()
      type=bool
      <content>
Изменяет параметры ранее открытых позиций или отложенных ордеров.
Возвращает TRUE при успешном завершении функции.
Возвращает FALSE при неудачном завершении функции.
Чтобы получить информацию об ошибке, необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.<br/>
Замечания: цену открытия и время истечения можно изменять только у отложенных ордеров.<br/>
Если в качестве параметров функции передать неизмененные значения, то в этом случае будет сгенерирована <a href="help://constants_errors">ошибка</a> 1 (ERR_NO_RESULT).<br/>
На некоторых торговых серверах может быть установлен запрет на применение срока истечения отложенных ордеров. В этом случае при попытке задать
ненулевое значение в параметре <i>expiration</i> будет сгенерирована <a href="help://constants_errors">ошибка</a> 147 (ERR_TRADE_EXPIRATION_DENIED).
      </content>
      <example>
  if(TrailingStop&gt;0)
    {
     OrderSelect(12345,SELECT_BY_TICKET); 
     if(Bid-OrderOpenPrice()&gt;Point*TrailingStop)
       {
        if(OrderStopLoss()&lt;Bid-Point*TrailingStop)
          {
           OrderModify(OrderTicket(),OrderOpenPrice(),Bid-Point*TrailingStop,OrderTakeProfit(),0,Blue);
           return(0);
          }
       }
    }
      </example>
      <parameter>
        type=int
        name=ticket
        description=Уникальный порядковый номер ордера.
      </parameter>
      <parameter>
        type=double
        name=price
        description=Новая цена открытия отложенного ордера.
      </parameter>
      <parameter>
        type=double
        name=stoploss
        description=Новое значение StopLoss.
      </parameter>
      <parameter>
        type=double
        name=takeprofit
        description=Новое значение TakeProfit.
      </parameter>
      <parameter>
        type=datetime
        name=expiration
        description=Время истечения отложенного ордера.
      </parameter>
      <parameter>
        type=color
        name=arrow_color
        def_value=CLR_NONE
        <description>
Цвет стрелок модификации StopLoss и/или TakeProfit на графике. Если параметр отсутствует или его значение равно CLR_NONE, то стрелки на графике не отображаются.
        </description>
      </parameter>
    </function>

    <function>
      tag=trading_OrderOpenPrice
      caption=OrderOpenPrice()
      type=double
      <content>
Возвращает цену открытия для выбранного ордера.<br/>
Ордер должен быть предварительно выбран с помощью функции <a href="help://trading_OrderSelect">OrderSelect()</a>.
      </content>
      <example>
  if(OrderSelect(10, SELECT_BY_POS)==true)
    Print(&quot;open price for the order 10 &quot;,OrderOpenPrice());
  else
    Print(&quot;OrderSelect() вернул ошибку - &quot;,GetLastError());
      </example>
    </function>

    <function>
      tag=trading_OrderOpenTime
      caption=OrderOpenTime()
      type=datetime
      <content>
Возвращает время открытия выбранного ордера.<br/>
Ордер должен быть предварительно выбран с помощью функции <a href="help://trading_OrderSelect">OrderSelect()</a>.
      </content>
      <example>
  if(OrderSelect(10, SELECT_BY_POS)==true)
    Print(&quot;open time for the order 10 &quot;, OrderOpenTime());
  else
    Print(&quot;OrderSelect() вернул ошибку - &quot;,GetLastError());
      </example>
    </function>

    <function>
      tag=trading_OrderPrint
      caption=OrderPrint()
      type=void
      <content>
Выводит данные ордера в журнал в виде строки следующего формата:<br/>
<a href="help://trading_OrderTicket">номер тикета;</a> <a href="help://trading_OrderOpenTime">время открытия;</a> <a href="help://trading_OrderType">торговая операция;</a>
 <a href="help://trading_OrderLots">количество лотов;</a> <a href="help://trading_OrderOpenPrice">цена открытия;</a> <a href="help://trading_OrderStopLoss">стоп лосс;</a>
 <a href="help://trading_OrderTakeProfit">тейк профит;</a> <a href="help://trading_OrderCloseTime">время закрытия;</a> <a href="help://trading_OrderClosePrice">цена закрытия;</a>
 <a href="help://trading_OrderCommission">комиссия;</a> <a href="help://trading_OrderSwap">своп;</a> <a href="help://trading_OrderProfit">прибыль;</a>
 <a href="help://trading_OrderComment">комментарий;</a> <a href="help://trading_OrderMagicNumber">магическое число;</a> <a href="help://trading_OrderExpiration">дата истечения отложенного ордера.</a><br/>
Ордер должен быть предварительно выбран с помощью функции <a href="help://trading_OrderSelect">OrderSelect()</a>.
      </content>
      <example>
  if(OrderSelect(10, SELECT_BY_TICKET)==true)
    OrderPrint();
  else
    Print(&quot;OrderSelect() вернул ошибку - &quot;,GetLastError());
      </example>
    </function>

    <function>
      tag=trading_OrderProfit
      caption=OrderProfit()
      type=double
      <content>
Возвращает значение чистой прибыли (без учёта свопов и комиссий) для выбранного ордера. Для открытых позиций это - текущая нереализованная прибыль. Для закрытых ордеров - зафиксированная прибыль.<br/>
Ордер должен быть предварительно выбран с помощью функции <a href="help://trading_OrderSelect">OrderSelect()</a>.
      </content>
      <example>
  if(OrderSelect(10, SELECT_BY_POS)==true)
    Print(&quot;Profit for the order 10 &quot;,OrderProfit());
  else
    Print(&quot;OrderSelect() вернул ошибку - &quot;,GetLastError());
      </example>
    </function>

    <function>
      tag=trading_OrderSelect
      caption=OrderSelect()
      type=bool
      keywords=;SELECT_BY_POS;SELECT_BY_TICKET;MODE_TRADES;MODE_HISTORY;
      <content>
Функция выбирает ордер для дальнейшей работы с ним. Возвращает TRUE при успешном завершении функции.
Возвращает FALSE при неудачном завершении функции.
Чтобы получить информацию об ошибке, необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.<br/>
Параметр <i>pool</i> игнорируется, если ордер выбирается по номеру тикета. Номер тикета является уникальным идентификатором ордера.
Чтобы определить, из какого списка выбран ордер, необходимо проанализировать его <a href="help://trading_OrderCloseTime">время закрытия</a>. Если время закрытия
ордера равно 0, то ордер является открытым или отложенным и взят из списка открытых позиций терминала. Отличить открытую позицию от отложенного ордера
можно по <a href="help://trading_OrderType">типу ордера</a>. Если <a href="help://trading_OrderCloseTime">время закрытия</a> ордера не равно 0, то ордер является
<a href="help://trading_OrderClose">закрытым</a> или <a href="help://trading_OrderDelete">удаленным</a> отложенным и был выбран из истории терминала. Отличить закрытый
ордер от удаленного отложенного также можно по <a href="help://trading_OrderType">типу ордера</a>.
      </content>
      <example>
  if(OrderSelect(12470, SELECT_BY_TICKET)==true)
    {
     Print(&quot;order #12470 open price is &quot;, OrderOpenPrice());
     Print(&quot;order #12470 close price is &quot;, OrderClosePrice());
    }
  else
    Print(&quot;OrderSelect() вернул ошибку - &quot;,GetLastError());
      </example>
      <parameter>
        type=int
        name=index
        description=Позиция ордера или номер ордера в зависимости от второго параметра.
      </parameter>
      <parameter>
        type=int
        name=select
        <description>
Флаг способа выбора. Mожет быть одним из следующих величин:<br/>
SELECT_BY_POS - в параметре <i>index</i> передается порядковый номер позиции в списке,<br/>
SELECT_BY_TICKET - в параметре <i>index</i> передается номер тикета.
        </description>
      </parameter>
      <parameter>
        type=int
        name=pool
        def_value=MODE_TRADES
        <description>
Источник данных для выбора. Используется, когда параметр <i>select</i> равен SELECT_BY_POS. Mожет быть одной из следующих величин:<br/>
MODE_TRADES (по умолчанию) - ордер выбирается среди открытых и отложенных ордеров,<br/>
MODE_HISTORY - ордер выбирается среди закрытых и удаленных ордеров.
        </description>
      </parameter>
    </function>

    <function>
      tag=trading_OrderSend
      caption=OrderSend()
      type=int
      <content>
Основная функция, используемая для открытия позиции или установки отложенного ордера.<br/>
Возвращает номер тикета, который назначен ордеру торговым сервером или -1 в случае неудачи.
Чтобы получить дополнительную информацию об ошибке, необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.<br/>
Замечания.<br/>
При открытии рыночного ордера (OP_SELL или OP_BUY) в качестве цены открытия могут использоваться только самые последние цены
<a href="help://predefined_variables_Bid">Bid</a> (для продажи) или <a href="help://predefined_variables_Ask">Ask</a> (для покупки). Если операция проводится по финансовому инструменту,
отличному от текущего, то для получения последних котировок по этому инструменту необходимо воспользоваться функцией
<a href="help://common_MarketInfo">MarketInfo()</a> с параметром MODE_BID или MODE_ASK. Нельзя использовать расчетную либо ненормализованную цену.
Если запрашиваемой цены открытия не было в ценовом потоке либо запрашиваемая цена не нормализована в соответствии с <a href="help://predefined_variables_Digits">количеством
знаков после десятичной точки</a>, то будет сгенерирована <a href="help://constants_errors">ошибка</a> 129 (ERR_INVALID_PRICE). Если запрашиваемая цена
открытия сильно устарела, то независимо от значения параметра <i>slippage</i> будет сгенерирована <a href="help://constants_errors">ошибка</a> 138
 (ERR_REQUOTE). Если же запрашиваемая цена устарела, но ещё присутствует в ценовом потоке, то позиция открывается по текущей цене и только в том случае,
 если текущая цена попадает в диапазон <i>price</i>+-<i>slippage</i>.<br/><br/>
Цены StopLoss и TakeProfit не могут располагаться слишком близко к рынку. Минимальное расстояние стопов в пунктах можно получить, используя
функцию <a href="help://common_MarketInfo">MarketInfo()</a> с параметром MODE_STOPLEVEL. В случае ошибочных, а также ненормализованных стопов генерируется
<a href="help://constants_errors">ошибка</a> 130 (ERR_INVALID_STOPS).<br/><br/>
При установке отложенного ордера цена открытия не может быть слишком близкой к рынку. Минимальное расстояние отложенной цены от текущей рыночной цены
в пунктах также можно получить, используя функцию <a href="help://common_MarketInfo">MarketInfo()</a> с параметром MODE_STOPLEVEL. В случае неправильной
цены открытия отложенного ордера будет сгенерирована <a href="help://constants_errors">ошибка</a> 130 (ERR_INVALID_STOPS).<br/><br/>
На некоторых торговых серверах может быть установлен запрет на применение срока истечения отложенных ордеров. В этом случае при попытке задать
ненулевое значение в параметре <i>expiration</i> будет сгенерирована <a href="help://constants_errors">ошибка</a> 147 (ERR_TRADE_EXPIRATION_DENIED).<br/><br/>
На некоторых торговых серверах может быть установлен лимит на <a href="help://trading_OrdersTotal">общее количество</a> открытых и отложенных ордеров.
При превышении этого лимита новая позиция открыта не будет (отложенный ордер не будет установлен), и торговый сервер вернет <a href="help://constants_errors">ошибку</a>
148 (ERR_TRADE_TOO_MANY_ORDERS).
      </content>
      <example>
  int ticket;
  if(iRSI(NULL,0,14,PRICE_CLOSE,0)&lt;25)
    {
     ticket=OrderSend(Symbol(),OP_BUY,1,Ask,3,Bid-25*Point,Ask+25*Point,&quot;My order #&quot;+counter,16384,0,Green);
     if(ticket&lt;0)
       {
        Print("OrderSend failed with error #",GetLastError());
        return(0);
       }
    }
      </example>
      <parameter>
        type=string
        name=symbol
        description=Наименование финансового инструмента, с которым проводится торговая операция.
      </parameter>
      <parameter>
        type=int
        name=cmd
        <description>
Торговая операция. Может быть любым из значений <a href="help://constants_trading">торговых операций</a>.
        </description>
      </parameter>
      <parameter>
        type=double
        name=volume
        description=Количество лотов.
      </parameter>
      <parameter>
        type=double
        name=price
        description=Цена открытия.
      </parameter>
      <parameter>
        type=int
        name=slippage
        description=Максимально допустимое отклонение цены для рыночных ордеров (ордеров на покупку или продажу).
      </parameter>
      <parameter>
        type=double
        name=stoploss
        description=Цена закрытия позиции при достижении уровня убыточности (0 в случае отсутствия уровня убыточности).
      </parameter>
      <parameter>
        type=double
        name=takeprofit
        description=Цена закрытия позиции при достижении уровня прибыльности (0 в случае отсутствия уровня прибыльности).
      </parameter>
      <parameter>
        type=string
        name=comment
        def_value=NULL
        description=Текст комментария ордера. Последняя часть комментария может быть изменена торговым сервером.
      </parameter>
      <parameter>
        type=int
        name=magic
        def_value=0
        description=Магическое число ордера. Может использоваться как определяемый пользователем идентификатор.
      </parameter>
      <parameter>
        type=datetime
        name=expiration
        def_value=0
        description=Срок истечения отложенного ордера.
      </parameter>
      <parameter>
        type=color
        name=arrow_color
        def_value=CLR_NONE
        <description>
Цвет открывающей стрелки на графике. Если параметр отсутствует или его значение равно CLR_NONE, то открывающая стрелка не отображается на графике.
       </description>
      </parameter>
    </function>

    <function>
      tag=trading_OrdersHistoryTotal
      caption=OrdersHistoryTotal()
      type=int
      <content>
Возвращает количество закрытых позиций и удаленных ордеров в истории текущего счета, загруженной в клиентском терминале. Размер списка истории зависит от
текущих настроек вкладки &quot;История счета&quot; терминала.
      </content>
      <example>
  // retrieving info from trade history
  int i,accTotal=OrdersHistoryTotal();
  for(i=0;i&lt;accTotal;i++)
    {
     //---- check selection result
     if(OrderSelect(i,SELECT_BY_POS,MODE_HISTORY)==false)
       {
        Print(&quot;Ошибка при доступе к исторической базе (&quot;,GetLastError(),&quot;)&quot;);
        break;
       }
     // работа с ордером ...
    }
      </example>
    </function>

    <function>
      tag=trading_OrderStopLoss
      caption=OrderStopLoss()
      type=double
      <content>
Возвращает значение цены закрытия позиции при достижении уровня убыточности (stop loss) для текущего выбранного ордера.<br/>
Ордер должен быть предварительно выбран с помощью функции <a href="help://trading_OrderSelect">OrderSelect()</a>.
      </content>
      <example>
  if(OrderSelect(ticket,SELECT_BY_POS)==true)
    Print(&quot;Stop loss value for the order 10 &quot;, OrderStopLoss());
  else
    Print(&quot;OrderSelect() вернул ошибку - &quot;,GetLastError());
      </example>
    </function>

    <function>
      tag=trading_OrdersTotal
      caption=OrdersTotal()
      type=int
      <content>
Возвращает общее количество открытых и отложенных ордеров.<br/>
      </content>
      <example>
  int handle=FileOpen("OrdersReport.csv",FILE_WRITE|FILE_CSV,"\t");
  if(handle&lt;0) return(0);
  // запишем заголовок в файл
  FileWrite(handle,&quot;#&quot;,&quot;Цена открытия&quot;,&quot;Время открытия&quot;,&quot;Символ&quot;,&quot;Лоты&quot;);
  int total=OrdersTotal();
  // записываем в файл только открытые ордера
  for(int pos=0;pos&lt;total;pos++)
    {
     if(OrderSelect(pos,SELECT_BY_POS,MODE_TRADES)==false) continue;
     FileWrite(handle,OrderTicket(),OrderOpenPrice(),OrderOpenTime(),OrderSymbol(),OrderLots());
    }
  FileClose(handle);
      </example>
    </function>

    <function>
      tag=trading_OrderSwap
      caption=OrderSwap()
      type=double
      <content>
Возвращает значение свопа для текущего выбранного ордера.<br/>
Ордер должен быть предварительно выбран с помощью функции <a href="help://trading_OrderSelect">OrderSelect()</a>.
      </content>
      <example>
  if(OrderSelect(order_id, SELECT_BY_TICKET)==true)
    Print(&quot;Swap for the order #&quot;, order_id, &quot; &quot;,OrderSwap());
  else
    Print(&quot;OrderSelect() вернул ошибку - &quot;,GetLastError());
      </example>
    </function>

    <function>
      tag=trading_OrderSymbol
      caption=OrderSymbol()
      type=string
      <content>
Возвращает наименование финансового инструмента для текущего выбранного ордера.<br/>
Ордер должен быть предварительно выбран с помощью функции <a href="help://trading_OrderSelect">OrderSelect()</a>.
      </content>
      <example>
  if(OrderSelect(12, SELECT_BY_POS)==true)
    Print(&quot;symbol of order #&quot;, OrderTicket(), &quot; is &quot;, OrderSymbol());
  else
    Print(&quot;OrderSelect() вернул ошибку - &quot;,GetLastError());
      </example>
    </function>

    <function>
      tag=trading_OrderTakeProfit
      caption=OrderTakeProfit()
      type=double
      <content>
Возвращает значение цены закрытия позиции при достижении уровня прибыльности (take profit) для текущего выбранного ордера<br/>
Ордер должен быть предварительно выбран с помощью функции <a href="help://trading_OrderSelect">OrderSelect()</a>.
      </content>
      <example>
  if(OrderSelect(12, SELECT_BY_POS)==true)
    Print(&quot;Order #&quot;,OrderTicket(),&quot; profit: &quot;, OrderTakeProfit());
  else
    Print(&quot;OrderSelect() вернул ошибку - &quot;,GetLastError());
      </example>
    </function>

    <function>
      tag=trading_OrderTicket
      caption=OrderTicket()
      type=int
      <content>
Возвращает номер тикета для текущего выбранного ордера.<br/>
Ордер должен быть предварительно выбран с помощью функции <a href="help://trading_OrderSelect">OrderSelect()</a>.
      </content>
      <example>
  if(OrderSelect(12, SELECT_BY_POS)==true)
    Print(&quot;Order #&quot;,OrderTicket(),&quot; profit: &quot;, OrderTakeProfit());
  else
    Print(&quot;OrderSelect() вернул ошибку - &quot;,GetLastError());
      </example>
    </function>

    <function>
      tag=trading_OrderType
      caption=OrderType()
      type=int
      <content>
Возвращает тип операции текущего выбранного ордера. Mожет быть одной из следующих величин:<br/>
OP_BUY - позиция на покупку,<br/>
OP_SELL - позиция на продажу,<br/>
OP_BUYLIMIT - отложенный ордер на покупку по достижении заданного уровня, текущая цена выше уровня,<br/>
OP_BUYSTOP - отложенный ордер на покупку по достижении заданного уровня, текущая цена ниже уровня,<br/>
OP_SELLLIMIT - отложенный ордер на продажу по достижении заданного уровня, текущая цена ниже уровня,<br/>
OP_SELLSTOP - отложенный ордер на продажу по достижении заданного уровня, текущая цена выше уровня.<br/>
Ордер должен быть предварительно выбран с помощью функции <a href="help://trading_OrderSelect">OrderSelect()</a>.
      </content>
      <example>
  int order_type;
  if(OrderSelect(12, SELECT_BY_POS)==true)
    {
     order_type=OrderType();
     // ...
    }
  else
    Print(&quot;OrderSelect() вернул ошибку - &quot;,GetLastError());
      </example>
    </function>
  </group>


  <group>
    tag=windows
    caption=Операции с графиками
    <content>
    Группа функций, предназначенных для работы с окном текущего графика.
    </content>

    <function>
      tag=windows_HideTestIndicators
      caption=HideTestIndicators()
      type=void
      <content>
Функция выставляет флаг скрытия индикаторов, вызываемых экспертом.
При открытии графика после тестирования индикаторы, помеченные флагом скрытия,
не будут выведены на график тестирования.
Перед каждым вызовом индикатор помечается текущим установленным флагом скрытия.<br/>
Необходимо отметить, что на график тестирования могут быть выведены только те индикаторы,
которые непосредственно вызываются из тестируемого эксперта.
      </content>
      <example>
   HideTestIndicators(true);
   MaCurrent=iMA(NULL,0,56,0,MODE_EMA,PRICE_CLOSE,0);
   MaPrevious=iMA(NULL,0,56,0,MODE_EMA,PRICE_CLOSE,1);
   HideTestIndicators(false);
      </example>
      <parameter>
        type=bool
        name=hide
        description=TRUE - если нужно прятать индикаторы, иначе FALSE.
      </parameter>
    </function>

    <function>
      tag=windows_Period
      caption=Period()
      type=int
      <content>
      Возвращает значение числа минут <a href="help://constants_timeframes">периода</a> для текущего графика.
      </content>
      <example>
  Print(&quot;Период &quot;, Period());
      </example>
    </function>

    <function>
      tag=windows_RefreshRates
      caption=RefreshRates()
      type=bool
      <content>
Обновление данных в <a href="help://predefined_variables">предопределенных переменных и массивах-таймсериях</a>.
Эта функция используется, когда эксперт или скрипт производит вычисления в течение долгого времени и нуждается в обновленных данных.
Возвращается TRUE, если данные обновлены, иначе FALSE. Данные могут не обновиться только по той причине, что они соответствуют текущему состоянию клиентского терминала.
Эксперты и скрипты работают с собственной копией исторических данных. Копия данных по текущему инструменту создается при
первоначальном запуске эксперта или скрипта. При каждом следующем запуске эксперта (напомним, что скрипт <a href="help://runtime_start">выполняется</a>
однократно и не зависит от приходящих тиков) первоначально созданная копия обновляется. За то время, пока эксперт или скрипт работает, может прийти
один или несколько новых тиков, поэтому данные могут устареть.
      </content>
      <example>
   int ticket;
   while(true)
     {
      ticket=OrderSend(Symbol(),OP_BUY,1.0,Ask,3,0,0,&quot;комментарий эксперта&quot;,255,0,CLR_NONE);
      if(ticket&lt;=0)
        {
         int error=GetLastError();
         //---- недостаточно денег
         if(error==134) break;
         //---- 10 секунд ожидания
         Sleep(10000);
         //---- обновим ценовые данные
         RefreshRates();
        }
      else
        {
         OrderSelect(ticket,SELECT_BY_TICKET);
         OrderPrint();
         break;
        }
     }
      </example>
    </function>


    <function>
      tag=windows_Symbol
      caption=Symbol()
      type=string
      <content>
      Возвращает текстовую строку с именем текущего финансового инструмента.
      </content>
      <example>
   int total=OrdersTotal();
   for(int pos=0;pos&lt;total;pos++)
     {
      // результат выбора проверки, так как ордер может быть закрыт или удален в это время!
      if(OrderSelect(pos, SELECT_BY_POS)==false) continue;
      if(OrderType()&gt;OP_SELL || OrderSymbol()!=Symbol()) continue;
      // делает некоторую обработку...
     }
      </example>
    </function>

    <function>
      tag=windows_WindowBarsPerChart
      caption=WindowBarsPerChart()
      type=int
      <content>
      Функция возвращает количество баров, помещающихся в окно текущего графика.
      </content>
      <example>
   // обработка видимых баров. 
   int bars_count=WindowBarsPerChart();
   int bar=WindowFirstVisibleBar();
   for(int i=0; i&lt;bars_count; i++,bar--)
     {
      // номера баров уменьшаются, так как нумерация идет в обратном порядке.
      // ...
     }
      </example>
    </function>

    <function>
      tag=windows_WindowExpertName
      caption=WindowExpertName()
      type=string
      <content>
Возвращает имя выполняющегося эксперта, скрипта, пользовательского индикатора или библиотеки, в зависимости от
того, из какой MQL4-программы вызвана данная функция.
      </content>
      <example>
string name=WindowExpertName();
GlobalVariablesDeleteAll(name);
      </example>
    </function>

    <function>
      tag=windows_WindowFind
      caption=WindowFind()
      type=int
      <content>
Возвращает номер подокна графика, содержащего индикатор с указанным именем <i>name</i>, если он найден, иначе возвращается -1.<br/>
WindowFind() возвращает -1, если пользовательский индикатор ищет сам себя в процессе инициализации <i>init()</i>.
      </content>
      example=int win_idx=WindowFind(&quot;MACD(12,26,9)&quot;);
      <parameter>
        type=string
        name=name
        description=Короткое имя индикатора.
      </parameter>
    </function>

    <function>
      tag=windows_WindowFirstVisibleBar
      caption=WindowFirstVisibleBar()
      type=int
      <content>
Функция возвращает номер первого видимого бара в окне текущего графика. Необходимо иметь в виду, что ценовые бары нумеруются задом наперед, от последнего к первому.
Текущий бар, самый последний в ценовом массиве, имеет индекс 0. Самый старый бар имеет индекс <a href="help://predefined_variables_Bars">Bars</a>-1.
Если номер первого видимого бара меньше, чем <a href="help://windows_WindowBarsPerChart">количество видимых баров на графике</a> на 2 и более,
это значит, что окно графика заполнено не до конца и имеется поле справа.
      </content>
      <example>
   // обработка видимых баров. 
   int bars_count=WindowBarsPerChart();
   int bar=WindowFirstVisibleBar();
   for(int i=0; i&lt;bars_count; i++,bar--)
     {
      // номера баров уменьшаются, так как нумерация идет в обратном порядке.
      // ...
     }
      </example>
    </function>

    <function>
      tag=windows_WindowHandle
      caption=WindowHandle()
      type=int
      <content>
Возвращает системный дескриптор окна (window handle), содержащего указанный график.
Если график с <i>symbol</i> и <i>timeframe</i> на момент вызова функции не открыт, то возвращается 0.<br/>
      </content>
      <example>
  int win_handle=WindowHandle("USDX",PERIOD_H1);
  if(win_handle!=0)
     Print(&quot;Окно с USDX,H1 обнаружено. Массив будет скопирован.&quot;);
      </example>
     <parameter>
        type=string
        name=symbol
        description=Символ.
      </parameter>
      <parameter>
        type=int
        name=timeframe
        description=Период. Может быть одним из <a href="help://constants_timeframes">периодов графика</a>.
      </parameter>
    </function>

    <function>
      tag=windows_WindowIsVisible
      caption=WindowIsVisible()
      type=bool
      <content>
      Возвращает TRUE, если подокно графика видимо, иначе возвращает FALSE. Подокно графика может быть скрыто из-за свойств видимости помещенного в него индикатора.
      </content>
      <example>
  int maywin=WindowFind("MyMACD");
  if(maywin&gt;-1 &amp;&amp; WindowIsVisible(maywin)==true)
    Print("окно MyMACD видимое");
  else
    Print("окно MyMACD не обнаружено или не видимое");
      </example>
      <parameter>
        type=int
        name=index
        description=Индекс подокна графика.
      </parameter>
    </function>

    <function>
      tag=windows_WindowOnDropped
      caption=WindowOnDropped()
      type=int
      <content>
Возвращает индекс окна, в которое был брошен эксперт, пользовательский индикатор или скрипт.
Это значение будет верным только в том случае, если эксперты, пользовательские индикаторы и скрипты прикреплены с помощью мыши (технология &quot;drag and drop&quot;).<br/>
Для пользовательских индикаторов, находящихся в процессе инициализации (вызов из функции <i>init()</i>) этот индекс не определен.<br/>
Возвращаемый индекс является номером окна (0-главное окно графика, подокна индикаторов нумеруются с 1), в котором работает пользовательский индикатор.
В процессе инициализации пользовательский индикатор может создать свое собственное новое подокно и его номер будет отличаться от номера окна, на которое
действительно был брошен индикатор.<br/>
<b>См. также</b> <a href="help://windows_WindowXOnDropped">WindowXOnDropped()</a>, <a href="help://windows_WindowYOnDropped">WindowYOnDropped()</a>
      </content>
      <example>
  if(WindowOnDropped()!=0)
    {
     Print("Скрипт MyVisualTrading должен быть брошен на основное окно графика!");
     return(0);
    }
      </example>
    </function>

    <function>
      tag=windows_WindowPriceMax
      caption=WindowPriceMax()
      type=double
      <content>
Возвращает максимальное значение вертикальной шкалы указанного подокна текущего графика
 (0-главное окно графика, подокна индикаторов нумеруются с 1). Если индекс подокна не указан, то
 возвращается максимальное значение ценовой шкалы главного окна графика.<br/>
 <b>См. также</b> <a href="help://windows_WindowPriceMin">WindowPriceMin()</a>, <a href="help://windows_WindowFirstVisibleBar">WindowFirstVisibleBar()</a>, <a href="help://windows_WindowBarsPerChart">WindowBarsPerChart()</a>
     </content>
      <example>
double   top=WindowPriceMax();
double   bottom=WindowPriceMin();
datetime left=Time[WindowFirstVisibleBar()];
int      right_bound=WindowFirstVisibleBar()-WindowBarsPerChart();
if(right_bound&lt;0) right_bound=0;
datetime right=Time[right_bound]+Period()*60;
//----
ObjectCreate(&quot;Padding_rect&quot;,OBJ_RECTANGLE,0,left,top,right,bottom);
ObjectSet(&quot;Padding_rect&quot;,OBJPROP_BACK,true);
ObjectSet(&quot;Padding_rect&quot;,OBJPROP_COLOR,Blue);
WindowRedraw();
      </example>
      <parameter>
        type=int
        name=index
        description=Индекс подокна текущего графика (0 - основной график цены).
        def_value=0
      </parameter>
    </function>

    <function>
      tag=windows_WindowPriceMin
      caption=WindowPriceMin()
      type=double
      <content>
Возвращает минимальное значение вертикальной шкалы указанного подокна текущего графика
 (0-главное окно графика, подокна индикаторов нумеруются с 1). Если индекс подокна не указан, то
 возвращается минимальное значение ценовой шкалы главного окна графика.<br/>
  <b>См. также</b> <a href="help://windows_WindowPriceMax">WindowPriceMax()</a>, <a href="help://windows_WindowFirstVisibleBar">WindowFirstVisibleBar()</a>, <a href="help://windows_WindowBarsPerChart">WindowBarsPerChart()</a>
     </content>
      <example>
double   top=WindowPriceMax();
double   bottom=WindowPriceMin();
datetime left=Time[WindowFirstVisibleBar()];
int      right_bound=WindowFirstVisibleBar()-WindowBarsPerChart();
if(right_bound&lt;0) right_bound=0;
datetime right=Time[right_bound]+Period()*60;
//----
ObjectCreate(&quot;Padding_rect&quot;,OBJ_RECTANGLE,0,left,top,right,bottom);
ObjectSet(&quot;Padding_rect&quot;,OBJPROP_BACK,true);
ObjectSet(&quot;Padding_rect&quot;,OBJPROP_COLOR,Blue);
WindowRedraw();
      </example>
      <parameter>
        type=int
        name=index
        description=Индекс подокна текущего графика (0 - основной график цены).
        def_value=0
      </parameter>
    </function>

    <function>
      tag=windows_WindowPriceOnDropped
      caption=WindowPriceOnDropped()
      type=double
      <content>
Возвращает значение цены в точке графика, на которой был брошен эксперт или скрипт.
Значение будет верным только в случае, если эксперт или скрипт перемещены с помощью мыши (технология &quot;drag and drop&quot;).<br/>
Для пользовательских индикаторов это значение не определено.<br/>
<b>См. также</b> <a href="help://windows_WindowTimeOnDropped">WindowTimeOnDropped()</a>, <a href="help://windows_WindowYOnDropped">WindowYOnDropped()</a>, <a href="help://windows_WindowOnDropped">WindowOnDropped()</a>
      </content>
      <example>
  double   drop_price=WindowPriceOnDropped();
  datetime drop_time=WindowTimeOnDropped();
  //---- может быть неопределенным (нуль)
  if(drop_time&gt;0)
    {
     ObjectCreate(&quot;Уровень цены&quot;, OBJ_HLINE, 0, drop_price);
     ObjectCreate(&quot;Значение времени&quot;, OBJ_VLINE, 0, drop_time);
    }
      </example>
    </function>

    <function>
      tag=windows_WindowRedraw
      caption=WindowRedraw()
      type=void
      <content>
      Принудительно перерисовывает текущий график. Обычно применяется после изменения свойств объектов.
      </content>
      <example>
  //---- установим новые свойства нескольких объектов
  ObjectMove(object_name1, 0, Time[index], price);
  ObjectSet(object_name1, OBJPROP_ANGLE, angle*2);
  ObjectSet(object_name1, OBJPROP_FONTSIZE, fontsize);
  ObjectSet(line_name, OBJPROP_TIME2, time2);
  ObjectSet(line_name, OBJPROP_ANGLE, line_angle);
  //---- теперь все перерисуем
  WindowRedraw();
      </example>
    </function>

    <function>
      tag=windows_WindowScreenShot
      caption=WindowScreenShot()
      type=bool
      <content>
Сохраняет изображение текущего графика в файле формата GIF. В случае неудачи возвращает FALSE. Чтобы получить информацию об ошибке,
необходимо вызвать функцию <a href="help://check_GetLastError">GetLastError()</a>.<br/>
Скриншот сохраняется в папке <em>каталог_терминала\experts\files</em> (<em>каталог_терминала\tester\files</em> в случае тестирования эксперта) или ее подпапках.
      </content>
      <example>
  int lasterror=0;
  //---- тестер закрыл одну или несколько позиций
  if(IsTesting() &amp;&amp; ExtTradesCounter&lt;TradesTotal())
    {
     //---- снимем скриншот для проверки
     if(!WindowScreenShot("shots\\tester"+ExtShotsCounter+".gif",640,480))
        lasterror=GetLastError();
     else ExtShotsCounter++;
     ExtTradesCounter=TradesTotal();
    }
      </example>
      <parameter>    
        type=string
        name=filename
        description=Имя файла для скриншота.
      </parameter>
      <parameter>    
        type=int
        name=size_x
        description=Ширина скриншота в пикселах.
      </parameter>
      <parameter>    
        type=int
        name=size_y
        description=Высота скриншота в пикселах.
      </parameter>
      <parameter>
        type=int
        name=start_bar
        <description>
Номер первого видимого бара на скриншоте. Если указано значение 0, то скриншот снимается с текущего <a href="help://windows_WindowFirstVisibleBar">первого видимого бара</a>.
 Если значение не указано, или указано отрицательное значение, то делается скриншот конца графика с учётом правого отступа.
        </description>
        def_value=-1
      </parameter>
      <parameter>
        type=int
        name=chart_scale
        <description>
Масштаб графика, выводимого на скриншот. Может принимать значение от 0 до 5.
 Если значение не указано, или указано отрицательное значение, то используется текущий масштаб графика.
        </description>
        def_value=-1
      </parameter>
      <parameter>
        type=int
        name=chart_mode
        <description>
Вид отображения графика. Может принимать значения: CHART_BAR (0 - последовательность баров), CHART_CANDLE (1 - японские свечи), CHART_LINE (2 - линия по ценам закрытия).
 Если значение не указано, или указано отрицательное значение, то график выводится в своем текущем виде.
        </description>
        def_value=-1
      </parameter>
    </function>

    <function>
      tag=windows_WindowTimeOnDropped
      caption=WindowTimeOnDropped()
      type=datetime
      <content>
Возвращает значение времени в точке графика, на которой был брошен эксперт или скрипт.
Значение будет верным только в случае, если эксперт или скрипт перемещены с помощью мыши (технология &quot;drag and drop&quot;).<br/>
Для пользовательских индикаторов это значение не определено.<br/>
<b>См. также</b> <a href="help://windows_WindowPriceOnDropped">WindowPriceOnDropped()</a>, <a href="help://windows_WindowXOnDropped">WindowXOnDropped()</a>, <a href="help://windows_WindowOnDropped">WindowOnDropped()</a>
      </content>
      <example>
  double   drop_price=WindowPriceOnDropped();
  datetime drop_time=WindowTimeOnDropped();
  //---- может быть неопределенным (нуль)
  if(drop_time&gt;0)
    {
     ObjectCreate(&quot;Уровень цены&quot;, OBJ_HLINE, 0, drop_price);
     ObjectCreate(&quot;Значение времени&quot;, OBJ_VLINE, 0, drop_time);
    }
      </example>
    </function>

    <function>
      tag=windows_WindowsTotal
      caption=WindowsTotal()
      type=int
      <content>
      Возвращает количество окон индикаторов на графике, включая главное окно графика.
      </content>
      example=Print(&quot;Количество окон = &quot;, WindowsTotal());
    </function>

    <function>
      tag=windows_WindowXOnDropped
      caption=WindowXOnDropped()
      type=int
      <content>
Возвращает значение координаты по оси X в пикселах точки клиентской области окна графика, на которой был брошен эксперт или скрипт.
Значение будет верным только в случае, если эксперт или скрипт перемещены с помощью мыши (технология &quot;drag and drop&quot;).<br/>
<b>См. также</b> <a href="help://windows_WindowYOnDropped">WindowYOnDropped()</a>, <a href="help://windows_WindowTimeOnDropped">WindowTimeOnDropped()</a>, <a href="help://windows_WindowOnDropped">WindowOnDropped()</a>
      </content>
      <example>
  Print("Эксперт был прикреплен к окну в точке с координатами x=",WindowXOnDropped()," y=",WindowYOnDropped());
      </example>
    </function>

    <function>
      tag=windows_WindowYOnDropped
      caption=WindowYOnDropped()
      type=int
      <content>
Возвращает значение координаты по оси Y в пикселах точки клиентской области окна графика, на которой был брошен эксперт или скрипт.
Значение будет верным только в случае, если эксперт или скрипт перемещены с помощью мыши (технология &quot;drag and drop&quot;).<br/>
<b>См. также</b> <a href="help://windows_WindowXOnDropped">WindowXOnDropped()</a>, <a href="help://windows_WindowPriceOnDropped">WindowPriceOnDropped()</a>, <a href="help://windows_WindowOnDropped">WindowOnDropped()</a>
      </content>
      <example>
  Print("Эксперт был прикреплен к окну в точке с координатами x=",WindowXOnDropped()," y=",WindowYOnDropped());
      </example>
    </function>
  </group>

  <group>
    tag=obsolete
    caption=Устаревшие функции
    <content>
      <p>В процессе дальнейшей разработки языка MQL4 в целях систематизации некоторые функции были переименованы
      и перемещены из одной группы в другую. Старые названия функций не подсвечиваются и не связаны со справкой
      MetaEditor. Старые названия функций можно использовать, так как компилятор правильно их воспримет. Однако
      мы настоятельно рекомендуем использовать новые названия.</p>
      <table cellspacing="0" cellpadding="4" border="0" class="docenums">
      <tr><th width="50%">Старое название</th><th width="50%">Новое название</th></tr>
      <tr><td>BarsPerWindow</td><td><a href="help://windows_WindowBarsPerChart">WindowBarsPerChart</a></td></tr>
      <tr><td>ClientTerminalName</td><td><a href="help://terminal_TerminalName">TerminalName</a></td></tr>
      <tr><td>CurTime</td><td><a href="help://dateandtime_TimeCurrent">TimeCurrent</a></td></tr>
      <tr><td>CompanyName</td><td><a href="help://terminal_TerminalCompany">TerminalCompany</a></td></tr>
      <tr><td>FirstVisibleBar</td><td><a href="help://windows_WindowFirstVisibleBar">WindowFirstVisibleBar</a></td></tr>
      <tr><td>Highest</td><td><a href="help://series_iHighest">iHighest</a></td></tr>
      <tr><td>HistoryTotal</td><td><a href="help://trading_OrdersHistoryTotal">OrdersHistoryTotal</a></td></tr>
      <tr><td>LocalTime</td><td><a href="help://dateandtime_TimeLocal">TimeLocal</a></td></tr>
      <tr><td>Lowest</td><td><a href="help://series_iLowest">iLowest</a></td></tr>
      <tr><td>ObjectsRedraw</td><td><a href="help://windows_WindowRedraw">WindowRedraw</a>,</td></tr>
      <tr><td>PriceOnDropped</td><td><a href="help://windows_WindowPriceOnDropped">WindowPriceOnDropped</a></td></tr>
      <tr><td>ScreenShot</td><td><a href="help://windows_WindowScreenShot">WindowScreenShot</a></td></tr>
      <tr><td>ServerAddress</td><td><a href="help://account_AccountServer">AccountServer</a></td></tr>
      <tr><td>TimeOnDropped</td><td><a href="help://windows_WindowTimeOnDropped">WindowTimeOnDropped</a></td></tr>
      </table><br/>
    </content>
  </group>
  <group>
    tag=MQL5_migrate
    caption=Переход на MQL5
    <content>
<p>В 2010 году компания MetaQuotes Software Corp. выпустила новую торгово-информационную платформу <a href="http://www.metatrader5.com/ru" title="MetaTrader 5" target="_blank">MetaTrader 5</a>. При ее разработке было учтено огромное количество пожеланий трейдеров и добавлена возможность торговли биржевыми инструментами. </p>
<p>Клиентский терминала MetaTrader 5 получил новый мультивалютный тестер, который позволяет задействовать при оптимизации  все доступные ядра компьютера. Более того, с помощью подключенных удаленных агентов тестирования время оптимизации эксперта можно сократить в сотни раз. Добавление, удаление и управление удаленными агентами реализовано максимально просто и удобно. </p>
<p>Редактор MetaEditor 5 позволяет проводить отладку программ, имеет встроенную систему автоматического завершения кода и много других улучшений. Новый помощник &quot;<a href="http://www.metatrader5.com/ru/metaeditor/help/MQL5_wizard" title="Мастер MQL5" target="_blank">Мастер MQL5</a>&quot; позволяет в четыре клика мышки создавать собственные торговых роботов без умения программировать. Достаточно выбрать на каждом  шаге тип торговых сигналов, блок управления капиталом, систему Trailing Stop и советник готов для компиляции и запуска.</p>
<p>Но все эти достоинства не были бы полными без нового языка программирования MQL5, в котором реализованы:</p>
<ul>
  <li>объектно-ориентированное программирование (ООП);</li>
  <li>обработка торговых и пользовательских событий; </li>
  <li>большое количество новых графических объектов и свойств;</li>
</ul>

<p>Скорость выполнения программ на MQL5 также многократно возросла и вплотную приблизилась по быстродействию  к языку C++. Разработчикам mql5-программ теперь нет необходимости переносить тяжелые математические вычисления в библиотеки DLL. </p>
<p>Для удобства изучения нового языка  на сайте <a href="http://www.mql5.com/ru" title="www.mql5.com/ru" target="_blank">MQL5-сообщества</a> публикуются новые <a href="http://www.mql5.com/ru/articles" title="Статьи по MQL5" target="_blank">статьи</a> и коды, доступна онлайновая документация и организован сервис <a href="http://www.mql5.com/ru/job" title="Заказ программ на MQL4" target="_blank">Работа</a>, на котором можно заказать программы на MQL4 и MQL5. Запланированы и готовятся новые сервисы: мониторинг счетов, магазин экспертов, продажа сигналов и площадка удаленных агентов тестирования.</p>
<p>Если вы знаете MQL4, то для вас не составит труда изучить новый язык MQL5. Новые возможности того стоят. </p>
    </content>
  </group>
  </group>
</dictionary>