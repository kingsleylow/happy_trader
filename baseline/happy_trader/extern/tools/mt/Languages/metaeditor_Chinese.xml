<?xml version="1.0" encoding='UTF-8'?>
<dictionary>
  tag=MetaQuotesLanguage
  caption=MetaQuotes Language 4  
  charset=UTF-8
  lang_params=参量:
  lang_sample=示例:

  <styles>
  *           { font-family: Tahoma, Verdana, Arial, Helvetica, sans-serif; font-size:1em; }
  body        { margin-top: 3px; margin-bottom: 3px; padding-left: 3px; padding-right: 3px; margin: 3px; padding: 3px; background-color:#fbfbfc; color:#626363; font-size:0.8em; }
  div, p      { margin:0px; padding: 0px; }
  p           { margin-bottom: 12px; }
  ul          { list-style-type: square; }
  a           { color:#42639C; }
  
  td.l_smb    { font: 12pt Wingdings; }
  td.d_smb    { font: 12pt Wingdings;background: #E8E8FF; }
  td.l_code   { border-right: 1px #a8afaa solid; }
  td.d_code   { border-right: 1px #a8afaa solid;background: #e8e8ff; }
  td.d_code_e { background: #e8e8ff; }
  table.symbols{font-family: tahoma; font-size: 8pt; border: thin solid #a8afaa;}
  
  .docmenu    { width:200px; margin-right:15px; border-right:1px solid #DADADA; background-color:#f6f9fd; padding-left:10px; padding-right:10px; margin-bottom:5px; }
  .doctext    { margin-right:15px; padding-left:10px; padding-right:0px; margin-bottom:5px; padding-bottom:10px; padding-top:6px; }
  .docnav     { clear:both; width:100%; text-align:right; padding-top:4px; border-top:1px solid #DADADA; }
  .docfunc    { color: #8A2BE2; }
  .doctable   { border-top:1px solid #DADADA;  }
  .docvar     { font-family: monospace; font-size: 10pt; font-weight:bold; margin-bottom: 4pt; }
  .doctabhdr  { font-weight:bold; padding: 0pt 4pt 0pt 0pt; margin: 8pt 2pt 2pt 2pt;  }
  .docmql4    { font-family: monospace; background-color: #F6F9FC; border: 1px #d8dfea solid; padding: 2pt 2pt 2pt 2pt; margin: 2pt 0pt 2pt 15pt; font-family: monospace; }
  .docparams  { background-color: #F6F9FC; border: 1px #d8dfea solid; font-family: Tahoma; font-size: 9pt; margin-left: 15pt; }
  .docenums    { background-color: #F6F9FC; border-top: 1px #d8dfea solid; border-left: 1px #d8dfea solid; font-family: Tahoma; font-size: 9pt; margin-left: 15pt; width: 95%; }
  .docenums th { vertical-align: top; background-color: #d8dfea; border-bottom: 1px #d8dfea solid; border-right: 1px #d8dfea solid;font-family: Tahoma; font-size: 9pt; }
  .docenums td { vertical-align: top; background-color: #F6F9FC; border-bottom: 1px #d8dfea solid; border-right: 1px #d8dfea solid;font-family: Tahoma; font-size: 9pt; }
  </styles>
<group>
tag=index
caption=MQL4 Reference
<keywords>
;MQL4 Reference;
</keywords>
<content>
          <p>MetaQuotes Language 4 (MQL4) 是一种新的内置型程序用来编写交易策略。 这种语言可以创建你自己的智能交易，使自己的交易策略能够完全自动地执行。而且，MQL4 还能自定义客户指标，脚本和数据库。
</p>
      
      <p>内包含了大量可以分析当前及历史报价所必须的函数，以及一些基本的运算和逻辑操作。并内置了一些基本的指标和操作命令。</p>
      
      <p>MetaEditor 4集合了编写 MQL4 程序代码的各种语句，它能帮助使用者方便地写出规范的代码。 MetaQuotes Language Dictionary 是 MQL4 语言的帮助工具，它包含了我们在使用工程中所有可能用到的函数。

</p>
      
      <p>MetaQuotes Language 4 可以编写不同作用的程序代码:</p>
      <ul><li><p>
          <strong>智能交易</strong> 是一种连接到特定图表的自动交易系统。它能够根据设置的节点自动启动 ，当它开始运行后，它不会同时去处理另一个新的指令(也就是说必须等到当前程序完成)。 这种交易系统能够在提醒用户可以交易的同时，将交易定单自动送到交易服务器。与大多数交易系统一样， 它也能够用历史数据测试交易策略，并在图表上显示出来。
<br/>
          智能交易存储在 <em>terminal_directory\experts</em>。</p></li>
        <li><p><strong>自定义指标</strong> 可用来编写新的技术指标，和内置的指标一样，它不能用来进行自动交易， 只能作为分析数据的工具。<br/>
         自定义指标储存在 <em>terminal_directory\experts\indicators</em>。</p></li>
        <li><p><strong>脚本</strong> 是执行单一功能的一段程序，和 智能交易不同，脚本不能单独执行，只能被调用。<br/>
         脚本存储在 <em>terminal_dictionary\experts\scripts</em>。</p></li>
        <li><p><strong>数据库</strong> 常被使用的自定义函数的集合。数据库不能单独运行。<br/>
         数据库建议存储在<em>terminal_directory\experts\libraries</em>。</p></li>
        <li><p><strong>包含文件</strong> 包含文件常被使用的程序块源代码，这些文件能够被包含在智能交易，脚本，客户指标和数据库 的源代码中。 使用包含文件比调用资料库更灵活快捷。 
<br/>
         包含文件交易储存在 <em>terminal_directory\experts\include</em>。</p></li>
      </ul>

</content>
<group>
tag=basis
caption=Basics
<keywords>
;Basics;
</keywords>
<content>
          <p>MetaQuotes Language 4 (MQL4)是一种新型的交易策略内置语言。用来编写交易策略的程序语言。这种语言可以创建你自己的智能交易， 使自己的交易策略能够完全地自动执行。程序内包含了分析历史报价的必备函数， 以及一些基本的运算法和逻辑操作和一些基本的指标和操作命令。 而且，MQL4 还能自定义自己的客户指标，脚本和数据库。
</p>

</content>
<group>
tag=basis_syntax
caption=Syntax
<keywords>
;Syntax;
</keywords>
<content>
          <p>MQL4 的语法类似于C语言，除了以下这些特点:</p>
      <ul>
                <li>
                  <p>没有运算地址；</p>
                </li>
                <li>
                  <p>没有 do ... while 语句；</p>
                </li>
                <li>
                  <p>没有 goto ... 语句;</p>
                </li>
                <li>
                  <p>没有 [条件][表达式 1]:[表达式 2] 语句；</p>
                </li>
                <li>
                  <p>没有复合数据类型 (结构);</p>
                </li>
                <li>
                  <p>复合负值是不允许的，例如：val1=val2=0; arr[i++]=val; cond=(cnt=OrdersTotal)>0; 等等;</p>
                </li>
                <li>
                  <p>逻辑表达式的计算完成前不可以提前终止。</p></li>
      </ul>

</content>
<text>
tag=basis_syntax_comments
caption=Comments
<keywords>
;Comments;
</keywords>
<content>
            <p>多行注释使用 /* 作为开始到 */ 结束，在这之间不能够嵌套。单行注释使用 // 作为开始到新的一行结束，可以被嵌套到多行注释之中。</p>
        <p class="doctabhdr">示例:</p>
        <pre class="docmql4">
// 单独注解
/*  multi-
    line         // 嵌入单独注解
    comment
*/</pre>

</content>
</text>
<text>
tag=basis_syntax_identifiers
caption=Identifiers
<keywords>
;Identifiers;
</keywords>
<content>
            <p>I标识符用来给变量、函数和数据类型进行命名，长度不能超过31个字节
你可以使用数字0-9、拉丁字母大写A-Z和小写a-z(大小写有区分的)还有下划线(_)。此外首字母不可以是数字，标识符不能和保留字冲突.
</p>
        <p class="doctabhdr">示例:</p>
        <pre class="docmql4">NAME1 namel Total_5 Paper</pre>

</content>
</text>
<text>
tag=basis_syntax_reserved
caption=Reserved words
<keywords>
;Reserved words;
</keywords>
<content>
            <p>下面列出的是固定的保留字。不能使用以下任何保留字进行命名。</p>
        
        <table cellspacing="0" cellpadding="4" border="0" class="docenums">
        <tr><th width="25%">数据类型</th><th width="25%">储存类型</th><th width="25%">操作符</th><th width="25%">其他</th></tr>
        <tr><td>bool</td><td>extern</td><td>break</td><td>false</td></tr>
        <tr><td>color</td><td>static</td><td>case</td><td>true</td></tr>
        <tr><td>datetime</td><td>&nbsp;</td><td>continue</td><td>&nbsp;</td></tr>
        <tr><td>double</td><td>&nbsp;</td><td>default</td><td>&nbsp;</td></tr>
        <tr><td>int</td><td>&nbsp;</td><td>else</td><td>&nbsp;</td></tr>
        <tr><td>string</td><td>&nbsp;</td><td>for</td><td>&nbsp;</td></tr>
        <tr><td>void</td><td>&nbsp;</td><td>if</td><td>&nbsp;</td></tr>
        <tr><td>&nbsp;</td><td>&nbsp;</td><td>return</td><td>&nbsp;</td></tr>
        <tr><td>&nbsp;</td><td>&nbsp;</td><td>switch</td><td>&nbsp;</td></tr>
        <tr><td>&nbsp;</td><td>&nbsp;</td><td>while</td><td>&nbsp;</td></tr>
        </table>

</content>
</text>
</group>
<group>
tag=basis_types
caption=Data types
<keywords>
;Data types;
</keywords>
<content>
          <p>所有的程序都依靠数据来运作，数据因目的不同可以有不同的类型
          。比如，访问数组可以用整型数据，价格可以用双精度的浮点型数据。在 MQL 4 中没有专门用来标记货币值的数据类型。</p>
              <p>不同的数据类型有不同的处理速度，整型数据是最快的。
              双精度的数据处理需要额外的处理器，所以处理浮点型数据比较复杂，
              比处理整型数据慢一些。字符串是处理速度最慢的，因为它要存取动态内存。</p>
              <p>主要的数据类型如下:</p>
              <ul>
                <li><a href="help://basis_types_integer">整型数据 (int)</a></li>
                <li><a href="help://basis_types_double">布尔数据 (bool)</a></li>
                <li><a href="help://basis_types_literal">字符数据 (char)</a></li>
                <li><a href="help://basis_types_string">字符串数据 (string)</a></li>
                <li><a href="help://basis_types_double">浮点型数据 (double)</a></li>
                <li><a href="help://basis_types_color">颜色数据 (color)</a></li>
                <li><a href="help://basis_types_datetime">日期时间数据 (datetime)</a></li>
              </ul>
              <p><EM>color </EM>和 <EM>datetime</EM> 可以使我们更清楚的区分图表中的内容，在 expert advisor 和 indicator
              中经常使用这些数据类型。颜色和日期时间数据用整数来表示。<em>int</em> 和 <em>double</em> 都属于数值（数字）型。</p>
              <p>在<a href="help://basis_operations_expression">表达式</a>运算中使用强制的<a href="help://basis_types_casting">类型转换</a>。</p>

</content>
<text>
tag=basis_types_casting
caption=Type casting
<keywords>
;Type casting;
</keywords>
<content>

          表达式</a>中使用强制的数据转换，转换时类型的优先级如下:</p>
              <pre class="docmql4">
int  (bool,color,datetime);
double;
string;</pre>
              <p>在运算完成之前(除了数据已被定义的)，数据会根据优先级被转换。当定义数据的操作完成前
              ，数据会转换成被定义的数据类型。</p>
              <p class="doctabhdr">示例:</p>
              <pre class="docmql4">
int    i = 1 / 2;     // 没有类型转换，结果为 0
int    i = 1 / 2.0;   // 表达式中有浮点型数据，但会转换成整型数据，结果为 0
double d = 1.0 / 2.0; // 没有类型转换，结果为 0.5
double d = 1 / 2.0;   // 表达式计算的结果是浮点型数据，和定义的类型一样，结果为 0.5
double d = 1 / 2;     // 表达式是整型数据的计算，然后被定义为浮点型数据，结果为 0.0</pre>
              <p>类型转换不但运用在常量中，还被运用在相应的<a href="help://basis_variables">变量</a>中。 </p>

</content>
</text>
<text>
tag=basis_types_integer
caption=Integer constants
<keywords>
;Integer constants;int;
</keywords>
<content>
            <p>十进制: 数字 0 - 9 ，包括负数。</p>
        <p class="doctabhdr">示例:</p>
        <pre class="docmql4">12, 111, -956 1007</pre>
        
        <p>十六进制: 数字 0 - 9 , 字面 a - f 或者 A - F 代表 10 - 15; 以 0x 或者 0X 开头。</p>
        <p class="doctabhdr">示例:</p>
        <pre class="docmql4">0x0A, 0x12, 0X12, 0x2f, 0xA3, 0Xa3, 0X7C7</pre>
        
        <p>整型数据占用 4 字节的空间，其数值范围介于 -2147483648 ～ 2147483647 之间。如果超出这个范围，则视为无效。</p>

</content>
</text>
<text>
tag=basis_types_literal
caption=Literal constants
<keywords>
;Literal constants;
</keywords>
<content>
        <p>任何带单引号的单一字符或者十六进制的 ASCII 码如 '\x10' 都是字符数据。一些特殊的字符如单引号(')、双引号(&quot;)、问号(?)、反斜线(\)和控制符必须以反斜线开头(\)， 组合表达原来的意思，如下表所示：</p>
        <pre class="docmql4">换行             NL (LF)  \n
制表符           HT       \t
回车             CR       \r
反斜线           \        \\
单引号           '        \'
双引号           "        \"
十六进制ASCII    hh       \xhh</pre>
        <p>如果上述字符不使用反斜线，结果将不被定义:</p>
        <pre class="docmql4">int a = 'A';
int b = '$';
int c = '&#xA9;';      // 代码0xA9
int d = '\xAE';   //货币对代码 &#xAE;</pre>
        
        <p>字符数据占用 4 字节的空间。其数值范围介于 0 ～ 255 之间。如果超出这个范围，则视为无效。</p>
</content>
</text>
<text>
tag=basis_types_bool
caption=Boolean constants
<keywords>
;Boolean constants;bool;true;false;
</keywords>
<content>
            <p>Boolean 用来表示 是 和 否, 还可以用数字 1 和 0 进行表示。True和Flase可以忽略大小写。</p>
        <p class="doctabhdr">示例:</p>
        <pre class="docmql4">bool a = true;
bool b = false;
bool c = 1;</pre>
        <p>它的十进制表示一个长度为4-byte的整数值。Boolean 常数可以表示0 或 1值。</p>

</content>
</text>
<text>
tag=basis_types_double
caption=Floating-point number constants (double)
<keywords>
;Floating-point number constants (double);double;
</keywords>
<content>
        <p>浮点型数据由整数部分、小数点(.)和小数部分组成，其中整数部分和小数部分为一系列十进制数字。</p>
        <p class="doctabhdr">示例:</p>
        <pre class="docmql4">double a = 12.111;
double b = -956.1007;
double c = 0.0001;
double d = 16;</pre>
        <p>浮点型数据 (双精度)占用 4 字节的空间。其数值范围介于 -1.7 * e-308 ～ 1.7 * e308 之间。如果超出这个范围，则视为无效。</p>
</content>
</text>
<text>
tag=basis_types_string
caption=String constants
<keywords>
;String constants;string;
</keywords>
<content>
        <p>字符串数据是带有双引号的一连串 ASCII 字符 ，如: &quot;Character constant&quot;。</p>
        
      <p>字符串数据是引号里的一组字符，如果字符串中需要插入一个双引号(&quot;) 必须在它前面使用反斜线(\)。任何<a href="help://basis_types_literal">特殊字符</a>都必须有前置的反斜线(\)才能在字符串中使用。 字符串可以容纳 0 到 255 个字符，如果超过这个长度，右边多余的字符将被忽略，编译器也会有相应的警示。  </p>
        <p class="doctabhdr">示例s:</p>
        <pre class="docmql4">
"This is a character string"
"Copyright symbol \t\xA9"
"this line contains a line feed symbol \n"
"C:\\Program Files\\MetaTrader 4"
"A" "1234567890" "0" "$"
</pre>
  <p>字符串数据占用 8 个字节的空间。其中第一部分为长的整型存储字符串缓冲区分布的长度。第二部分是32位的存储字符串缓冲区的地址。</p>
</content>
</text>
<text>
tag=basis_types_color
caption=Color constants
<keywords>
;Color constants;color;
</keywords>
<content>
<p>颜色数据可以用三种方法表示： 字符数据、整型数据或者是颜色名(只能是 Web colors 中已命名的).</p>
<p>字符数据的表达方法是用三个数字来表示三种主要颜色：红、绿、蓝的比例。 以 C 开头，用单引号括住。数字的值在 0 ～ 255 之间按比例选取。</p>
<p>整数数据的表达方法使用十六进制或十进制数字。十六进制数字如 0x00BBGGRR， 其中 RR 是红色的比例，GG 是绿色的比例，BB 是蓝色的比例。十进制数不能直接体现红绿蓝的比例 ，而是十六进制数字的十进制表示方式。</p>
<p>特殊的颜色名可以参考<a href="help://constants_colors">Web colors set</a>表。</p>
<p class="doctabhdr">示例:</p>
<pre class="docmql4">
// 字符数据
C'128,128,128'    // 灰色
C'0x00,0x00,0xFF' // 蓝色
// 颜色名
Red
Yellow
Black
// 整型数据
0xFFFFFF          // 白色
16777215          // 白色
0x008000          // 绿色
32768             // 绿色
</pre>
<p>颜色数据占用 4 字节的空间。第一个字节一般被忽略，后三个字节包含了红绿蓝的组成信息。</p>
</content>
</text>
<text>
tag=basis_types_datetime
caption=Datetime constants
<keywords>
;Datetime constants;datetime;
</keywords>
<content>
<p>日期时间数据由 6 个部分的字符组成：年、月、日、时、分、秒，以 D 开头， 用单引号括起。日期(年、月、日)或者时间(时、分、秒)甚至两者一起都可以不用填写。 日期时间数据开始于 1. 1. 1970 截止到12.31. 2037 </p>
<p class="doctabhdr">示例:</p>
<pre class="docmql4">
D'2004.01.01 00:00'     // 新年
D'1980.07.19 12:30:27'
D'19.07.1980 12:30:27'
D'19.07.1980 12'        //等于  D'1980.07.19 12:00:00'
D'01.01.2004'           //等于  D'01.01.2004 00:00:00'
D'12:30:27'             //等于 D'[编译日期] 12:30:27'
D''                     //等于 D'[编译日期] 00:00:00'</pre>
      
      <p>日期时间数据占用 4 字节空间长度的整型数值。其值从1970年1月00:00开始以秒的形式显示总数。</p>
</content>
</text>
</group>
<group>
tag=basis_operations
caption=Operations & Expressions
<keywords>
;Operations & Expressions;
</keywords>
<content>
         一些数字和字符的组合是特别重要的，它们被称为运算符，例如:
              <pre class="docmql4">
+ - * / %     算术运算符
&amp;&amp; ||         逻辑运算符
= += *=       负值运算符</pre>
              <p>运算符应用在表达式中实现特定的作用。<br ="/">
                  <br ="/">
        需要特别注意标点符号如圆括号、方括号、逗号、冒号、分号。<br ="/">
        <br ="/">
        运算符、标点符号、空格用来分割语句的不同部分。</p>

</content>
<text>
tag=basis_operations_expression
caption=Expressions
<keywords>
;Expressions;
</keywords>
<content>
    <p>一个表达式可以拥有多个字符和操作符，一个表达式可以写在几行里面。</p>
<p class="doctabhdr">示例:</p>
<pre class="docmql4">
a++; b = 10;
x = (y * z) /
    (w + 2) + 127;</pre>
        <p>一个表达式的最后一个分号(;) 操作符。</p>

</content>
</text>
<text>
tag=basis_operations_math
caption=Arithmetical operations
<keywords>
;Arithmetical operations;+;-;*;/;%;++;--;
</keywords>
<content>
     <p>算术运算符包括加法和乘法运算:</p>
 <pre class="docmql4">
求和                   i = j + 2;
求差                   i = j - 3;
改变运算符             x = - x;
求积                   z = 3 * x;
求商                   i = j / 5;
求模                   minutes = time % 60;
自加1                  i++;
自减1                  k--;
</pre>
<p>添加1的运算符不能使用在表达式中。</p>
<p class="doctabhdr">示例:</p>
<pre class="docmql4">int a=3;
a++;              // 有效表达式
int b=(a++)*3;    // 无效表达式
</pre>

</content>
</text>
<text>
tag=basis_operations_assign
caption=Assignment operation
<keywords>
;Assignment operation;+=;-=;*=;/=;%=;>;>;=;<;<;=;&;=;|=;^=;
</keywords>
<content>
            <p>表达式的值包括左边值给出的赋值运算符。</p>
<pre class="docmql4">把变量 x 的值赋予变量 y                  y = x;</pre><br/>
<p>
下列表达式中赋值运算符结合了算术运算符或位运算符:</p>
<pre class="docmql4">

在 y 值上加上 x                         y += x;
在 y 值上减去 x                         y -= x;
在 y 值上乘以 x                         y *= x;
在 y 值上除以 x                         y /= x;
在 y 值上求 x 的模                      y %= x;
把 y 值向右做 x 位逻辑移位                y &gt;&gt;= x; 
把 y 值向左做 x 位逻辑移位                y &lt;&lt;= x; 
AND 位运算符                            y &amp;= x;
OR 位运算符                             y |= x;
把 x 和 y 按做逻辑异或的操作              y ^= x;
</pre>
<br/>
 <p>表达式中可以只能有一个赋值运算符。 位运算符只能用于整型数据。逻辑移位运算符中 x 值只能是小于 5 位的二进制数，过大的数值将会被拒绝。
所以移动范围只能是 0 到 31 。 用 %= 运算符 ( 用x的模板求y值)，其结果等于余数。</p>

</content>
</text>
<text>
tag=basis_operations_relation
caption=Operations of relation
<keywords>
;Operations of relation;==;!=;<;;>;;<;=;>;=;;>;;<;=;>;=;;<;=;>;=;
</keywords>
<content>
    <p>逻辑值FALSE代表整数零值，逻辑值TRUE 代表不同于零的任何值。<br/>用返回0(False)或1(True)来表示两个量之间的关系。</p>
<pre class="docmql4">
等于b                        a = b;
不等于b                      a != b;
小于b                        a&lt; b;
大于b                        a &gt;b;
小于等于 b                   a &lt;=b;
大于等于 b                   a &gt;= b;
</pre>
<p>2个不规范的浮点型数据不能用 = 或 != 运算符比较，但是我们可以把2者相减， <a href="help://convert_NormalizeDouble">正常化</a>后
和 null进行比较。</p>

</content>
</text>
<text>
tag=basis_operations_bool
caption=Boolean operations
<keywords>
;Boolean operations;||;&;&;;;
</keywords>
<content>
    <p>否定运算符(!),用来表示真假的反面的结果。如果运算值是FALSE (0) 结果为TRUE (1)；如果运算不同于FALSE (0)等于FALSE (0) 。</p>
        <pre class="docmql4">if(!a) Print(&quot;不是 'a'&quot;);</pre><br/>
<p>x和y值的逻辑运算符或OR (||)用来表示两个表达式只要有一个成立即可。如果x和y值为真的，表达式值为TRUE (1)。否则，值为FALSE (0)。逻辑表达式被完全计算。</p>
    <pre class="docmql4">if(x&lt;0 || x&gt;=max_bars) Print(&quot;超出范围&quot;);</pre><br/>
   
<p>x和y值的逻辑运算符AND (&amp;&amp;)。如果x和值都是真实的，表达式值为TRUE (1)。
Otherwise, it is FALSE (0). </p>
<pre class="docmql4">if(p!=x &amp;&amp; p&gt;y) Print(&quot;TRUE&quot;);</pre>

</content>
</text>
<text>
tag=basis_operations_bit
caption=Bitwise operations
<keywords>
;Bitwise operations;&lt;<;;>;>;;~;!;^;&;;|;;>;>;;~;!;^;&;;|;;~;!;^;&;;|;;|;
</keywords>
<content>
    <p>运算符对操作数执行按位求补操作。表达式的数字值中包含1，其中n 包含 0和数字值中包含0 ，其中 n 包含 1。</p>
        <pre class="docmql4">b = ~n;</pre><br/>
      
<p>运算符x 向右移动到数字y 代表二进制代码。向右移动是逻辑运算，即左侧将被零填满。</p>
        <pre class="docmql4">x = x &gt;&gt; y;</pre><br/>
<p>运算符x 向右移动到数字y 代表二进制代码。左侧将被零填满</p>
        <pre class="docmql4">x = x &lt;&lt; y;</pre><br/>
<p>二进制的x 和y代表位逻辑运算符AND 。在所有数组中x和y的值都不含有零表达式的值包含1 (TRUE)；在所有其他数字中包含0 (FALSE)。</p>
        <pre class="docmql4">b = ((x &amp; y) != 0);</pre><br/>
<p>二进制的x 和y代表位逻辑运算符OR。在所有数字中x和y的值都不等于零表达值包含1 并且在所有其他数字中包含0。</p>
        <pre class="docmql4">b = x | y;</pre><br/>
<p>二进制的x 和y代表位逻辑运算符EXCLUSIVE 。在所有数字中x和y的值都不同于二进制值表达值包含1并且在所有其他数字中包含0 。
</p>
        <pre class="docmql4">b = x ^ y;</pre><br/>
        <p>位逻辑运算符只作用于Integers类型。</p>

</content>
</text>
<text>
tag=basis_operations_other
caption=Other operations
<keywords>
;Other operations;
</keywords>
<content>
    <p><b>指数</b><br/>
在数组第一元素的位置，表达式值为i的系列数变量值。
</p>
<p class="doctabhdr">示例:</p>
<pre class="docmql4">array[i] = 3; //数组的3的计算值到第i个元素。</pre><br/>
<p>只有整数能够成为数组指数。四维以下的数组是禁止的。每组的检测是从0 到 <b>测量大小</b>-1。 特定情况下，对于维数组由50 个元素组成，参照的第一个数组将为[0]，这样最后一个数组将是[49]。
</p>
        <p>获取超出数组，将会发生常规错误 <a href="help://constants_errors">ERR_ARRAY_INDEX_OUT_OF_RANGE</a>，
       可以调用 <a href="help://check_GetLastError">GetLastError()</a> 函数。</p>
<p><b>调用x1,x2,...,xn 自变数函数</b><br/>
每一个自变数可以显示一个常数，一个变量和相应类型表达式。自变数的通过必须根据通道命令。<br/><br/>
用此函数返回表达式值。如果返回的表达式值为空，一些函数不能进行中转。请确认表达式x1,x2,...,xn 是按照命令执行的。</p>
<p class="doctabhdr">示例:</p>
        <pre class="docmql4">double SL=Bid-25*Point;
int    ticket=OrderSend(Symbol(),OP_BUY,1,Ask,3,SL,Ask+25*Point,"My comment",123,0,Red);</pre><br/>
 
<p><strong>标点操作符</strong><br/>
从左到右的表达式用标点分开。所有表达式的计算是从左至右的。结果类型和值相互吻合，说明表达式是正确的。参量列表可以作为范例被通过。
</p>
        <p class="doctabhdr">示例:</p>
        <pre class="docmql4">for(i=0,j=99; i&lt;100; i++,j--) Print(数组[i][j]);</pre>

</content>
</text>
<text>
tag=basis_operations_rules
caption=Precedence rules
<keywords>
;Precedence rules;
</keywords>
<content>
<p>下面是从上到下的运算优先规则，优先级高的将先被运算。</p>
<pre class="docmql4">
()     函数调用                     从左到右
[]     数组元素参考
</pre>
<pre class="docmql4">
!      真假运算符                   从右到左
-      改变运算符
++     增量
--     减量
~      位逻辑运算符
</pre>
<pre class="docmql4">
&amp;      位逻辑运算符 AND             从左到右
|      位逻辑运算符 OR
^      位逻辑运算符 OR
&lt;&lt;     左移
&gt;&gt;     右移
</pre>
<pre class="docmql4">
*      乘法                        从左到右
/      除法
%      百分比
</pre>
<pre class="docmql4">
+      加法                        从左到右
-      减法
</pre>
<pre class="docmql4">
&lt;      小于                        从左到右
&lt;=     小于等于
&gt;      大于
&gt;=     大于等于
==     等于
!=     不等于
</pre>
<pre class="docmql4">||     逻辑 OR                      从左到右</pre>
<pre class="docmql4">&amp;&amp;     逻辑 AND                     从左到右</pre>
<pre class="docmql4">
=      值                          从右到左
+=     加法值
-=     减法值
*=     乘法值
/=     除法值
%=     百分比值
&gt;&gt;=    右移值
&lt;&lt;=    左移值
&amp;=     位逻辑运算符 AND值
|=     位逻辑运算符OR值
^=     位逻辑运算符 OR值
</pre>
<pre class="docmql4">,     逗号                         从左到右</pre><br/>
<p>插入语会显示所优先执行的运算<br/>
        <b>注意:</b>在MQL4程序中执行优先运算不同于在C 语言范围内的运算。</p>
</content>
</text>
</group>
<group>
tag=basis_operators
caption=Operators
<keywords>
;Operators;
</keywords>
<content>
    <p>语言操作符必须对执行完成任务的一些运算法操作进行描述。程序本身是这样的序列语句
          。语句逐个随后以分号分离。<br ="/">
              <br ="/">
              一个语句能占领一条或几条线。二个或更多语句可能位于同样线。单独执行命令的语句(if, if-else, switch, while
              and for) 可以相互插入</p>
<p class="doctabhdr">示例:</p>
        <pre class="docmql4">
if(Month() == 12)
  if(Day() == 31) Print("新年快乐!");</pre>

</content>
<text>
tag=basis_operators_compound
caption=Compound operator
<keywords>
;Compound operator;
</keywords>
<content>
    <p>一个复合操作符有一个(一个区段)和由一个或多个任何类型的操作符组成的的附件{}. 每个表达式使用分号作为结束(;)。</p>
        <p class="doctabhdr">示例:</p>
        <pre class="docmql4">if(x==0)
  {
   Print("无效位置 x=",x);
   return;
  }</pre>

</content>
</text>
<text>
tag=basis_operators_expression
caption=Expression operator
<keywords>
;Expression operator;
</keywords>
<content>
           <p>任何以分号(;)结束的表达式都被视为是一个操作符。这里是一些表达式操作符得范例:</p>
       <p><b>称号运算符</b>:</p>
       <pre class="docmql4"><i>Identifier=expression;</i>
x=3;
y=x=3; // 错误</pre>
      <p>称号运算符在表达式操作符中只限一次使用。</p>
      <p><b>函数调用运算符</b>:</p>
      <pre class="docmql4"><i>Function_name(argument1,..., argumentN);</i>
           
  FileClose(file);</pre><br/>
        <p><b>空运算符</b><br/>
        它是由分号(;)组成并且使用在一个检测运算符中。</p>

</content>
</text>
<text>
tag=basis_operators_break
caption=Break operator
<keywords>
;Break operator;break;
</keywords>
<content>
<p>一个<em>嵌入</em> 操作符终止最近外部操作符
<a href="help://basis_operators_switch"><em>switch</em></a>, <a href="help://basis_operators_while"><em>while</em></a>或
<a href="help://basis_operators_for"><em>for</em></a> 的执行。在终止操作符之后给出检测操作符。
这个操作符的目的之一：当中心值指定为变量时，操作符完成循环执行。</p>
<p class="doctabhdr">示例:</p>
<pre class="docmql4">// 搜索第一个零元素
for(i=0;i&lt;array_size;i++)
  if((array[i]==0)
    break;</pre>
</content>
</text>
<text>
tag=basis_operators_continue
caption=Continue operator
<keywords>
;Continue operator;continue;
</keywords>
<content>
<p>一个 <em>继续</em>操作符。 我们将其放在嵌套内的指定位置,用来在指定情况下跳过接下来的运算，直接跳入下一次的循环
<a href="help://basis_operators_while"><em>while</em></a> 或<a href="help://basis_operators_for"><em>for</em></a>操作符。
操作符 <a href="help://basis_operators_break"><em>嵌入</em></a> 位置与此操作符相反。</p>
<p class="doctabhdr">示例:</p>
<pre class="docmql4">//  总结数组非零元素
int func(int array[])
  {
   int array_size=ArraySize(array);
   int sum=0;
   for(int i=0;i&lt;array_size; i++)
     {
      if(a[i]==0) continue;
      sum+=a[i];
     }
   return(sum);
  }</pre>
</content>
</text>
<text>
tag=basis_operators_return
caption=Return operator
<keywords>
;Return operator;return;
</keywords>
<content>
    <p> 一个<em>return</em>将需要返回的结果放在return后面的()中。</p>
<p class="doctabhdr">示例:</p>
<pre class="docmql4">int CalcSum(int x, int y)
  {
   return(x+y);
  }</pre><br/>
  <p>在函数中省缺值类型被返回，此 <em>return</em>操作符必须使用:</p>
        <pre class="docmql4">void SomeFunction()
  {
   Print("Hello!");
   return;    // 这个操作符被删除
  }</pre>
        <p>函数正确的震动表示<em>return</em>操作符执行。</p>

</content>
</text>
<text>
tag=basis_operators_if
caption=Conditional operator if-else
<keywords>
;Conditional operator if-else;else;
</keywords>
<content>
            <p>如果表达式为true，操作符执行并按照操作符2 给出的检测。如果表达式为false，操作符2 执行。</p>
        <pre class="docmql4"><i>if (expression)
     operator1
else
     operator2</i></pre><br/>
        <p> <em>if</em>操作符 <em>else</em>部分可能被忽略。 <em>if</em>操作符忽略 <em>else</em>部分，显示分歧可能会嵌入。这种情况下， <em>else</em> 位置在先前<em>if</em>操作符的最近部位，这样不会出现<em>else</em>部分。</p>
        <p class="doctabhdr">示例:</p>
        <pre class="docmql4">//   else 部分提及到第二个if操作符:
  if(x&gt;1)
  if(y==2) z=5;
  else     z=6;
<br/>
//   else 部分提及到第一个if操作符:
if(x&gt;l)
  {
   if(y==2) z=5;
  }
else        z=6;
<br/>
//  嵌入操作符
if(x=='a')
  {
   y=1;
  }
else if(x=='b')
  {
   y=2;
   z=3;
  }
else if(x=='c')
  {
   y = 4;
  }
else Print(&quot;ERROR&quot;);</pre>

</content>
</text>
<text>
tag=basis_operators_switch
caption=Switch operator
<keywords>
;Switch operator;switch;case;default;
</keywords>
<content>
       <p>在<em>case</em>全部变量和相应表达式值检测的操作符之内比较常数表达式值。每一个<em>case</em>变量会在整数或常数表达式内标注。常数表达式不包含函数变量调用。<em>switch</em>表达式操作符必须是整数类型。 </p>
        <pre class="docmql4"><i>switch(expression)
  {
   case constant: operators
   case constant: operators
     ...
   default: operators
  }</i></pre><br/>
  
<p>如果在<em>case</em>操作符等于表达式值，操作符 <em>default</em>标签连接将会执行。此<em>default</em> 变量无需在最后。如果相应表达式值和 <em>default</em>变量没有获取，不会有任何执行。关键词<em>case</em>和常数被标注，并且if 操作符执行 <em>case</em>变量，程序将执行以下所有操作符直至<a href="help://basis_operators_break"><em>break</em></a>操作符生成。 
</p>
<p>一个常数表达式的计算是在编译期间。在一个<em>switch</em>操作符内部存在两个相同值的常数。 
</p>
<p class="doctabhdr">示例:</p>
<pre class="docmql4">switch(x)
  {
   case 'A':
      Print(&quot;CASE A&quot;);
      break;
   case 'B':
   case 'C':
      Print(&quot;CASE B or C&quot;);
      break;
   default:
      Print(&quot;NOT A, B or C&quot;);
      break;
  }</pre>
</content>
</text>
<text>
tag=basis_operators_while
caption=Cycle operator while
<keywords>
;Cycle operator while;while;
</keywords>
<content>
            <p>如果表达式为true， 操作符执行直至表达式变成false。如果表达式为false，将检测最近操作符。</p>
        <pre class="docmql4"><i>while(expression)
  operator;</i></pre><br/>
        <p>在操作符执行前，一个表达式值已经被指定。不过，如果开始表达式为 false，操作符根本不会执行。</p>
        <p class="doctabhdr">示例:</p>
        <pre class="docmql4">while(k&lt;n)
  {
   y=y*x;
   k++;
  }</pre>

</content>
</text>
<text>
tag=basis_operators_for
caption=Cycle operator for
<keywords>
;Cycle operator for;for;
</keywords>
<content>
            <p>用表达式1<em>Expression</em>来定义初始变量,当表达式2<em>Expression2</em> 为真的时候执行操作运算符,在每次循环结束后执行表达式3 <em>Expression3</em>。如果true, 运算符 <em>for</em> 将被执行。循环重复直至<em>Expression2</em>变为false。如果false，循环将会被中断并且检测运算符文本。稍候执行。</p>
      <pre class="docmql4"><i>for (Expression1; Expression2; Expression3)
   operator;</i></pre><br/>
   
        <p>此 <em>for</em> 运算符下列运算符成功：</p>
        <pre class="docmql4"><i>Expression1;
while(Expression2)
  {
   operator;
   Expression3;
  };</i></pre><br/>
  
        <p>使用<em>for</em>(;)可以造成一个死循环如同<em>while(1)</em>一样.
表达式1和表达式3都可以内嵌多个用逗号(,)分割的表达式。
<</p>
        <p class="doctabhdr">示例:</p>
<pre class="docmql4">for(x=1;x&lt;=7;x++) Print(MathPower(x,2));<br/>
for(;;)
  {
   Print(MathPower(x,2));
   x++;
   if(x>10) break;
  }<br/>
for(i=0,j=n-l;i&lt;n;i++,j--) a[i]=a[j];</pre>

</content>
</text>
</group>
<group>
tag=basis_functions
caption=Functions
<keywords>
;Functions;
</keywords>
<content>
          <p>函数是部分程序的一个名称，它可以在需要时从任何一个部分调用。 它是由定义分类返回值，名称，形式参量和合成运算符组成并执行的。通过的总数被限定在64个字符之内。</p>
      <p class="doctabhdr">示例:</p>
<pre class="docmql4">double                       // 被返回值的类型
linfunc (double x, double a, double b) // 函数名称和参量列表
{
                             // 合成运算符
   return (a + b);           // 返回值
 }</pre>
 
      <p> "返回"运算符可以返回在这个运算符内表达式的值。如果需要，此表达式值可以转换为函数结果类型。函数没有返回的值必定是“省缺” 类型。</p>
      <p class="doctabhdr">示例:</p>
<pre class="docmql4">
void errmesg(string s)
  {
   Print(&quot;错误: &quot;+s);
  }</pre>
        <p>通过函数的参量可能存在由特定类型常数指定的默认值。</p>
        <p class="doctabhdr">示例:</p>
        <pre class="docmql4">
int somefunc(double a, double d=0.0001, int n=5, bool b=true, string s="passed string")
  {
   Print(&quot;需求参量 a=&quot;,a);
   Print(&quot;下列参量被传送: d=&quot;,d,&quot; n=&quot;,n,&quot; b=&quot;,b,&quot; s=&quot;,s);
   return (0);
  }</pre>
        <p>如果此默认值指定一个参量，那么所有的参量也必须存在默认值。</p>
        <p class="doctabhdr">错误范例:</p>
        <pre class="docmql4">
int somefunc(double a, double d=0.0001, int n, bool b, string s="passed string")
  {
  }</pre>

</content>
<text>
tag=basis_functions_call
caption=Function call
<keywords>
;Function call;
</keywords>
<content>
            <p>I如果显示的文件没有描述， 它将考虑上下文的联系作为函数名称。</p>
        <pre class="docmql4"><i>函数名称 (x1, x2,..., xn)</i></pre><br/>
         
        <p>自变数(<a href="help://basis_variables_formal">形式参量</a>) 以值的形式通过。
     计算每一个表达式 <em>xl</em>, . . . , <em>xn</em> 并将其值发送到函数。 表达式计算命令值是被保证的。在执行系统测试数字和自变数类型期间会给出函数。
      这种形式的函数调用被称作调用值。调用函数是一个通过函数返回的表达式的值。
      描述函数类型必须相应类型返回的值。全球范围内程序的任何一个部分函数是被公布或描述的，即其他函数之外。在另外函数里，函数不能被公布或描述。</p>
        <p class="doctabhdr">例如:</p>
        <pre class="docmql4">
int start()
  {
   double some_array[4]={0.3, 1.4, 2.5, 3.6};
   double a=linfunc(some_array, 10.5, 8);
   //...
  }
double linfunc(double x[], double a, double b)
  {
   return (a*x[0] + b);
  }</pre><br/>
        <p>函数的调用是默认参量，通过参量的列表是被限定的，但不是之前的第一默认参量。</p>
        <p class="doctabhdr">例如:</p>
        <pre class="docmql4">void somefunc(double init,double sec=0.0001,int level=10);  // function prototype
        
somefunc();                   // 错误调用, 第一请求参量必须存在。
somefunc(3.14);               // 正确调用
somefunc(3.14, 0.0002);       // 正确调用
somefunc(3.14, 0.0002, 10);   // 正确调用</pre><br/>
        <p>当我们调用一个函数时，不可以忽略参量，存在默认值：</p>
        <pre class="docmql4">somefunc(3.14, , 10);         // 错误调用。第二参量被忽略。
        </pre>

</content>
</text>
<text>
tag=basis_functions_special
caption=Special functions
<keywords>
;Special functions;init;deinit;start;
</keywords>
<content>
            <p>在MQL4中存在三种预定义名称函数:<br/><br/>
        <b>init()</b> 在载入时调用，可以用此函数在开始自定义指标或者自动交易之前做初始化操作。<br/><br/>
        <b>start()</b> 是基本函数。对于智能交易，在下一个替克进入之后被调用。对于客户指标，在指标添加到图表之后，客户端开始(如果指标添加到图表)并且下一个替克进入之后，函数被调用。对于脚本，在脚本被添加到图表之后立即执行并初始化。如果在模板中不存在start()函数，模板 (智能交易，脚本或客户指标) 不能开启。<br/><br/>
        <b>deinit()</b> 当数据变动时触发，对于自定义指标或者自动交易的编程主要依靠此函数进行</p>
        <p>预定义函数需要一些参量。不过，当这些参量被客户端调用时，外部没有参量提供。 <em>start()</em>, <em>init()</em>和
        <em>deinit()</em>函数从模板的任何一点按照常规调用，等于其他函数。</p>
        
        <p>不建议从<em>init()</em>函数调用 <em>start()</em>函数或是执行交易业务，作为图表数据，市场开价格。模板的初始化会出现残缺。这时，<em>init()</em> 和
      <em>deinit()</em> 函数必须尽可能结束运行。在调用<em>start()</em>函数之前，尝试重新全面开启运行。</p>

</content>
</text>
</group>
<group>
tag=basis_variables
caption=Variables
<keywords>
;Variables;
</keywords>
<content>
      <p>可变量必须在公开之前使用。 可变量必须拥有特殊的辨认名。相关可变量的定义描述会显示。</p>
      <p><b>基本类型如下：</b></p>
      <ul>
          <li><a href="help://basis_types_bool">布尔数据</a> -布尔值的<em>true</em> 和 <em>false</em>;</li>
          <li><a href="help://basis_types_string">字串符数据</a> - 特殊字符串;</li>
          <li><a href="help://basis_types_double">双精度数字</a> - 带有浮点双精度数字。</li>
      </ul>
<p class="doctabhdr">示例:</p>
<pre class="docmql4">
string MessageBox;
int    Orders;
double SymbolPrice;
bool   bLog;
</pre><br/>
        <p><b>附加类型:</b></p>
        <ul><li><a href="help://basis_types_color">颜色</a> 为整数代表RGB 颜色;</li>
            <li><a href="help://basis_types_datetime">日期时间</a> 为日期和时间， 起始时间从1979年1月上午0.00开始以秒数计算。</li>
</ul>
        <p>添加数据类型在<a href="help://basis_variables_extern">输入参量</a>的属性窗口方便查看。</p>
        <p class="doctabhdr">示例:</p>
<pre class="docmql4">
datetime tBegin_Data   = D'2004.01.01 00:00';
color    cModify_Color = C'0x44,0xB9,0xE6';
</pre><br/>
        <p><b>数组</b></p>
<p>相同数列数据被标注序列。</p>
        <pre class="docmql4">int    a[50];       // 50整数的一维数组
double m[7][50];    // 7个数组的二维数组
                    //每一个由50 个整数组成。
        </pre><br/>
        <p>唯一整数可以是 <a href="help://basis_operations_other">数组指数</a>。 不允许四唯数列。数组元素开始编号为0 。 一个一维列阵的最后元素是1的数字比列阵大小。这就意味着, 请求数列的最后元素包括50 个整数将出现作为a[49 ] 。 维度被标注从0 到<b>维度大小</b>-1.
        一个二维数组的最后元素从示例将出现作为m[6][49 ] 。</p>
        <p>如果访问超出数列范围, 执行系统将发生错误可能生成错误
        <a href="help://constants_errors">ERR_ARRAY_INDEX_OUT_OF_RANGE</a>，在<a href="help://check_GetLastError">GetLastError()</a>函数中可以得到。</p>
</content>
<text>
tag=basis_variables_local
caption=Local variables
<keywords>
;Local variables;
</keywords>
<content>
           <p>在任意的地方内可变量的公开是局部的。局部变量在公开的部分里是被限定的。
          局部变量可以由任意一个表示结果初始化。
          每次函数的运行只可以初始化一个局部变量。局部变量储存在相应的存储器上。</p>
<p class="doctabhdr">示例:</p>
        <pre class="docmql4">
int somefunc()
  {
   int ret_code=0;
   ....
   return(ret_code);
  }</pre><br/>

</content>
</text>
<text>
tag=basis_variables_formal
caption=Formal parameters
<keywords>
;Formal parameters;
</keywords>
<content>
    <p>通过<a href="help://basis_functions_call">函数</a>的变量
              是局部的。范围是在作用块内。在作用之内正式变量的名称必须不同于其他外部定义变量和函数变量。
              作用块内的正式变量值已经被赋予。</p>
            <p class="doctabhdr">示例:</p>
            <pre class="docmql4">void func(int x[], double y, bool z)
  {
   if(y>0.0 && !z)
      Print(x[0]);
   ...
  }</pre>
            <br ="/"> <p>正式参量可能由常数初始化。在这种情况下, 初始化的值作为缺省值被考虑。参量, 在旁边（intialized） ,
              必须初始化。</p>
            <p class="doctabhdr">示例:</p>
            <pre class="docmql4">void func(int x, double y = 0.0, bool z = true)
  {
   ...
  }</pre> <p>这样作用显现时, 初始化的参量可能被省去, 缺省值会代替它们。</p>
            <p class="doctabhdr">示例:</p>
            <pre class="docmql4">func(123, 0.5);</pre>
            <br ="/"> <p>MQL4 资料库功能在<a href="help://basis_variables_extfunctions">外部函数变量</a>
            模块之内无法有默认值初始化。
              </p>
            <p>参量值通过。在任何情况下，变量里布局的修改将不会显示在功能板块内。
            它是可以通过数列作为参量。但是, 为了数列可以作为变量，需要改变它的数列元素。</p>
            <p>它是还可能通过参量参考。在这种情况下, 修改的这样参量将被显示在对应的变量。
            数组元素无法参考通过。参量可能只在一个模块参考通过,
              数据库不提供。</p>
       <p class="doctabhdr">示例:</p>
       <pre class="docmql4">
void func(int&amp; x, double&amp; y, double&amp; z[])
  {
   double calculated_tp;
   ...
   for(int i=0; i&lt;OrdersTotal(); i++)
     {
      if(i==ArraySize(z))       break;
      if(OrderSelect(i)==false) break;
      z[i]=OrderOpenPrice();
     }
   x=i;
   y=calculated_tp;
  }</pre><br/>
      <p>数组可以通过参考通过， 全部改变会在数列来源内显示。
            不同于简单的参量, 数组可以进入数据库...<br ="/">
              <br ="/">
              以缺省值参量通过无法初始化。<br ="/">
              <br ="/">
              最大参量不可以超过64个。</p>

</content>
</text>
<text>
tag=basis_variables_static
caption=Static variables
<keywords>
;Static variables;static;
</keywords>
<content>
    <p>"静止" 记忆被称作静态变量。在数据类型之前指定成分"静止" 被公开。</p>
            <p class="doctabhdr">示例:</p>
            <pre class="docmql4">int somefunc()
  {
   static int flag=10;
   ....
   return(flag);
  }
  </pre>
            <br ="/">
            <p>静态变量被存放在永久记忆里,在函数退出后静态变量不会丢失。所有在同一板块内（除正式变量作用外），可能作为静止变量定义。
            静态变量可以由相对应的类型常数初始化。
            与局部变量不同。如果没有明确地初始化, 静态变量初始化以零。
              静态变量在"init()"
              函数之前只可应用一次。</p>

</content>
</text>
<text>
tag=basis_variables_global
caption=Global variables
<keywords>
;Global variables;static;
</keywords>
<content>
      <p>整体变量作为函数被定义在相同水平，即，不可以局部使用。</p>
      <p class="doctabhdr">示例:</p>
<pre class="docmql4">int GlobalFlag=10;   // 整体变量
int start()
  {
   ...
  }</pre><br/>
  
        <p>整体变量的范围是整个程序。整体变量在所有程序内是被定义的。 如果它的值没有被定义，初始化值为零。 整体变量只对于相应的常数初始化。 整体变量只可以在init()函数操作之前一次性初始化。</p>
        <p>注解: 变量在整体变量的水平位上不能够与客户端<a href="help://globals"><em>GlobalVariable...()</em></a> 函数混淆。</p>
</content>
</text>
<text>
tag=basis_variables_extern
caption=Defining extern variables
<keywords>
;Defining extern variables;extern;
</keywords>
<content>
            <p>外部定义的可变量。 在数据类型公布之前指定外部变量。 </p>
           
            <p class="doctabhdr">示例:</p>
            <pre class="docmql4">extern double InputParameter1 = 1.0;
extern color  InputParameter2 = red;
int init()
  {
   ...
  }
  </pre>
            确定从外部程序输入的变量， 会直接显现输入数据窗口。数列本身不能作为外部变量。</p>

</content>
</text>
<text>
tag=basis_variables_initialization
caption=Initialization of variables
<keywords>
;Initialization of variables;
</keywords>
<content>
            <p>任何情况定义可变物可以初始化。如果它的原始值未被限定，任何可变物初始化为零(0)。
          整体变量和静态变量的初始化由相应的常数进行。  </p>
            <p>整体变量和静态变量只能一次性初始化。局部变量的初始化与相应的调动进行。</p>
            <p> <br>
            </p>
            <p class="doctabhdr">示例:</p>
            <pre class="docmql4">int    n       = 1;
double p       = MarketInfo(Symbol(),MODE_POINT);
string s       = "hello";
double f[]     = { 0.0, 0.236, 0.382, 0.5, 0.618, 1.0 };
int    a[4][4] = { 1, 1, 1, 1,  2, 2, 2, 2,  3, 3, 3, 3,  4, 4, 4, 4 };
  </pre>
            数组元素值列表必须被附寄在括号内。初始化省去的值被考虑为零。
            如果初始化的数组大小不被定义, 它将由编译器定义
            。多维数组由一个一维序列, 即序列初始化没有另外的括号。所有数列,
             只能以常数初始化。</p>

</content>
</text>
<text>
tag=basis_variables_extfunctions
caption=External functions definition
<keywords>
;External functions definition;import;#import;
</keywords>
<content>
            <p>类型外在作用被定义在程序的其它组分必须明确地被描述。
          缺乏这样定义也许导致错误在程序期间的编辑、联结, 
              或施行。当描述一个外在对象, 主题词进口必须被使用以在模块的参考。</p>
            <p>示例:</p>
            <pre class="docmql4">#import "user32.dll"
  int     MessageBoxA(int hWnd ,string szText,string szCaption,int nType);
  int     SendMessageA(int hWnd,int Msg,int wParam,int lParam);
#import "lib.ex4"
  double  round(double value);
#import
  </pre>
            进口可能被使用容易地描述作用叫从外在DLLs 或编写EX4 图书馆。
            <p>尖对可变物可能通过对进口的dll作用。串类型的数据
            被通过作为尖对对应的记忆块(你应该记住串数据的内部表示法包括二份: 记忆块长度和记忆阻拦尖) 
              。如果有需要通过数据内部或双重型, 那么对应的型的一维一些应该参考通过作为参量。</p>
            <br>
          <p class="doctabhdr">示例:</p>
            <pre class="docmql4">#import "some_lib.dll"
  void    PassIntegerByref(int& OneInt[]);
#import
int start()
  {
   int array[1];
//...
   PassIntegerByref(array);
   Print(array[0]);
//...
  }
</pre>

</content>
</text>
</group>
<group>
tag=basis_preprosessor
caption=Preprocessor
<keywords>
;Preprocessor;
</keywords>
<content>
        预处理程序是一个特殊MQL4的子程序，在程序执行之前预先准备的程序源代码。</p>
            <p>预处理程序会尽可能地读取源代码。代码的结构可能包括MQL4 程序源代码的特殊文件。
            对于读取的代码尽可能地按照具体常数分配储存。</p>
            <p>预处理程序允许MQL4 程序参量指定。</p>
            <p>如果# 标志被使用在程序的第一线, 这条线是预处理程序方针。预处理程序方向末端以换行字符结尾。

</content>
<text>
tag=basis_preprosessor_constant
caption=Constant declaration
<keywords>
;Constant declaration;#define;define;
</keywords>
<content>
            <p>使用<em>#define</em>定义常数可以在程序中指定货币对字串符并且定义货币对名称或货币对常数。 稍候，编辑器会按照相应的字串符名称还原所有显示。事实上，这些名称可以由任意数组文本替换:</p>
        <pre class="docmql4"><i>#define identifier value</i></pre><br/>
        
        <p>此常数识别符符合变量名称的规则
      值可以是以下任意类型:</p>
        <pre class="docmql4">#define ABC          100
#define PI           0.314
#define COMPANY_NAME "MetaQuotes Software Corp."<br/>
...<br/>
void ShowCopyright()
  {
   Print("版权所有 &#169; 2001-2007, ",COMPANY_NAME);
   Print("http://www.metaquotes.net");
  }</pre>

</content>
</text>
<text>
tag=basis_preprosessor_compilation
caption=Controlling compilation
<keywords>
;Controlling compilation;#property;property;link;copyright;stacksize;indicator_chart_window;indicator_separate_window;indicator_buffersindicator_minimum;indicator_maximum;indicator_color1;indicator_color2;indicator_color3;indicator_color4indicator_color5;indicator_color6;indicator_color7;indicator_color8;indicator_level1;indicator_level2indicator_level3;indicator_level4;indicator_level5;indicator_level6;indicator_level7;indicator_level8show_confirm;show_inputs;
</keywords>
<content>
            <p>每个MQL4 程序允添加以<em>#property</em>名称特殊的参量来帮助客户端服务。这是一个内设指标。</p>
        <pre class="docmql4"><i>#property 识别值</i></pre><br/>
        
        <table cellspacing="0" cellpadding="4" border="0" class="docenums" width="95%">
        <tr><th width="15%">常数</th><th width="10%">类型</th><th width="75%">描述</th></tr>
       <tr><td>link</td><td>string</td><td>公司网站的相关连接</td></tr>
        <tr><td>copyright</td><td>string</td><td>公司名称</td></tr>
        <tr><td>stacksize</td><td>int</td><td>栈式储存器大小</td></tr>
        <tr><td>library</td><td>&nbsp;</td><td>资料库;查看任何可出现的功能错误</td></tr>
        <tr><td>indicator_chart_window</td><td>void</td><td>在图表窗口显示指标</td></tr>
        <tr><td>indicator_separate_window</td><td>void</td><td>在指定窗口显示指标</td></tr>
        <tr><td>indicator_buffers</td><td>int</td><td>对于指标计算的数字，最大为 8</td></tr>
        <tr><td>indicator_minimum</td><td>double</td><td>在指标窗口下端</td></tr>
        <tr><td>indicator_maximum</td><td>double</td><td>在指标窗口的上端</td></tr>
        <tr><td>indicator_colorN</td><td>color</td><td>在1和8之间显示线的颜色</td></tr>
        <tr><td>indicator_widthN</td><td>int</td><td>在1和8之间显示线的宽度</td></tr>
        <tr><td>indicator_styleN</td><td>int</td><td>在1和8之间显示线的风格</td></tr>
        <tr><td>indicator_levelN</td><td>double</td><td>在客户指标窗口1和8之间N的水平</td></tr>
        <tr><td>indicator_levelcolor</td><td>color</td><td>水平线颜色</td></tr>
        <tr><td>indicator_levelwidth</td><td>int</td><td>水平线宽度</td></tr>
        <tr><td>indicator_levelstyle</td><td>int</td><td>水平线风格</td></tr>
        <tr><td>show_confirm</td><td>void</td><td>在脚本运行之前显示确认</td></tr>
        <tr><td>show_inputs</td><td>void</td><td>在脚本运行之前显示它的属性和确认</td></tr>
        </table><br/>
        
        <p class="doctabhdr">示例:</p>
        <pre class="docmql4">
#property link        "http://www.metaquotes.net"
#property copyright   "MetaQuotes Software Corp."
#property library
#property stacksize   1024</pre>
        <p>在执行模板设定时，编译器将会写入值。</p>

</content>
</text>
<text>
tag=basis_preprosessor_include
caption=Including of files
<keywords>
;Including of files;include;
</keywords>
<content>
            <p> <em>#include</em> 命令可以放置到程序的任意部分，但是通常所有文件的源代码被统一放置。调用格式；</p>
      <pre class="docmql4"><i>#include &lt;file_name&gt;
#include &quot;file_name&quot;;</i></pre><br/>
        <p class="doctabhdr">示例:</p>
        <pre class="docmql4">
#include &lt;WinUser32.mqh&gt;
#include "mylib.mqh"</pre><br/>
        <p>对于 WinUser32.mqh.文件内容预处理程序还原线。三角括号表示<em>WinUser32.mqh</em>文件将会从默认目录调用(通常默认目录 <em>terminal_directory\experts\include</em>)。不需要搜索当前目录。</p>
        
        <p>如果载开盘价栏内文件名称未锁，搜索将在当前目录中执行(加载的源代码主文件)。 不需要搜索标准目录。</p>

</content>
</text>
<text>
tag=basis_preprosessor_import
caption=Importing of functions
<keywords>
;Importing of functions;import;DLL;EX4;
</keywords>
<content>
            <p>函数从MQL4 编译模板 (*.ex4 文件) 和执行系统文件模板(*.dll文件)通过。模板名称被指定在<em>#import</em>指令中。来自输入函数和通过参量的兵役数据需要带有完整的描述部分。函数描述会立即按照<em>#import &quot;模板&quot;</em>名称执行。新的<em>#import</em> 命令完成引入输入函数描述部分。</p>
        <pre class="docmql4"><i>#import "file_name"
    func1 define;
    func2 define;
    ...
    funcN define;
#import</i></pre><br/>
<p>输入函数必须有自己的名称。相同名称的函数无法从不同的模块同时引入。引入的函数名不能与那些内部函数融合。</p>
<p>因为引入函数是在模块外面被编写, 编译器无法检查通过参量的正确性。这就是为什么, 避免运行错误, 它是必要精确地公开命令的原因。在参量引入函数(从EX4 和从DLL 模块)后， 没有任何值。

</p>
        <p class="doctabhdr">示例:</p>
        <pre class="docmql4">#import "user32.dll"
   int    MessageBoxA(int hWnd, string lpText, string lpCaption, int uType);<br/>
#import "stdlib.ex4"
   string ErrorDescription(int error_code);
   int    RGB(int red_value, int green_value, int blue_value);
   bool   CompareDoubles(double number1, double number2);
   string DoubleToStrMorePrecision(double number, int precision);
   string IntegerToHexString(int integer_number);<br/>
#import "Expert示例.dll"
   int    GetIntValue(int);
   double GetDoubleValue(double);
   string GetStringValue(string);
   double GetArrayItemValue(double arr[], int, int);
   bool   SetArrayItemValue(double&amp; arr[], int,int, double);
   double GetRatesItemValue(double rates[][6], int, int, int);
   int    SortStringArray(string&amp; arr[], int);
   int    ProcessStringArray(string&amp; arr[], int);
#import</pre><br/>
        <p>在mql4 程序执行期间引入输入函数，需要使用<em>稍后安装</em>。
        这就意味着直到调用输入函数，相应模板(ex4 或 dll)将不会进行加载。</p>
        <p>不建议使用<em>Drive:\Directory\FileName.Ext</em>为文件名安装。MQL4 资料库会从 <em>terminal_dir\experts\libraries</em> 文件夹中卸下。如果没有发现资料库，则没有可能从  <em>terminal_dir\experts</em>文件夹中卸下。</p>

</content>
</text>
</group>
</group>
<group>
tag=constants
caption=Standard constants
<keywords>
;Standard constants;
</keywords>
<content>
         <p>为了简化编写程序并使其程序文本更加方便，在MQL4中预定义了标准变量。<br/><br/>
     int类型的标准变量与 <a href="help://basis_preprosessor_constant">macro substitutions</a> 类似 。<br/><br/>
    此变量是按照用途分组的。</p>

</content>
<text>
tag=constants_series
caption=Series arrays
<keywords>
;Series arrays;MODE_OPEN;MODE_LOW;MODE_HIGH;MODE_CLOSE;MODE_TIME;MODE_VOLUME;
</keywords>
<content>
    <p>系列数组识别符在<a href="help://array_ArrayCopySeries">ArrayCopySeries()</a>,
<a href="help://series_iHighest">iHighest()</a> 和<a href="help://series_iLowest">iLowest()</a>函数中使用。<br/>
可以是以下任意值:</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums" width="95%">
        <tr><th width="15%">常数</th><th width="10%">值</th><th width="75%">描述</th></tr>
<tr><td>MODE_OPEN</td><td>0</td><td>开价</td></tr>
<tr><td>MODE_LOW</td><td>1</td><td>最低价</td></tr>
<tr><td>MODE_HIGH</td><td>2</td><td>最高价</td></tr>
<tr><td>MODE_CLOSE</td><td>3</td><td>关单价</td></tr>
<tr><td>MODE_VOLUME</td><td>4</td><td>应用在iLowest()和iHighest()函数中的成交量</td></tr>
<tr><td>MODE_TIME</td><td>5</td><td>应用在ArrayCopySeries()函数中的开柱时间</td></tr>
</table>

</content>
</text>
<text>
tag=constants_timeframes
caption=Timeframes
<keywords>
;Timeframes;PERIOD_M1;PERIOD_M5;PERIOD_M15;PERIOD_H1;PERIOD_H4;PERIOD_D1;PERIOD_W1;PERIOD_MN1;
</keywords>
<content>
    <p>图表的时间周期。可以是以下任意值:</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums" width="95%">
        <tr><th width="15%">常数</th><th width="10%">值</th><th width="75%">描述</th></tr>
<tr><td>PERIOD_M1</td><td>1</td><td>1 分钟</td></tr>
<tr><td>PERIOD_M5</td><td>5</td><td>5分钟</td></tr>
<tr><td>PERIOD_M15</td><td>15</td><td>15 分钟</td></tr>
<tr><td>PERIOD_M30</td><td>30</td><td>30 分钟</td></tr>
<tr><td>PERIOD_H1</td><td>60</td><td>1 小时</td></tr>
<tr><td>PERIOD_H4</td><td>240</td><td>4 小时</td></tr>
<tr><td>PERIOD_D1</td><td>1440</td><td>每天</td></tr>
<tr><td>PERIOD_W1</td><td>10080</td><td>每星期</td></tr>
<tr><td>PERIOD_MN1</td><td>43200</td><td>每月</td></tr>
<tr><td>0 (zero)</td><td>0</td><td>在图表中使用的时间周期.</td></tr>
</table>

</content>
</text>
<text>
tag=constants_trading
caption=Trade operations
<keywords>
;Trade operations;OP_BUY;OP_SELL;OP_BUYLIMIT;OP_SELLLIMIT;OP_BUYSTOP;OP_SELLSTOP;
</keywords>
<content>
    <p>对于<a href="help://trading_OrderSend">OrderSend()</a>函数的交易类型。
可以是以下任意值:</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums" width="95%">
        <tr><th width="15%">常数</th><th width="10%">值</th><th width="75%">描述</th></tr>
<tr><td>OP_BUY</td><td>0</td><td>买仓</td>
</tr>
<tr><td>OP_SELL</td><td>1</td><td>卖仓</td>
</tr>
<tr><td>OP_BUYLIMIT</td><td>2</td><td>买挂单交易</td>
</tr>
<tr><td>OP_SELLLIMIT</td><td>3</td><td>卖挂单交易</td>
</tr>
<tr><td>OP_BUYSTOP</td><td>4</td><td>买停挂单交易</td>
</tr>
<tr><td>OP_SELLSTOP</td><td>5</td><td>卖停挂单交易</td>
</tr>
</table>

</content>
</text>
<text>
tag=constants_prices
caption=Price constants
<keywords>
;Price constants;PRICE_CLOSE;PRICE_OPEN;PRICE_HIGH;PRICE_LOW;PRICE_MEDIAN;PRICE_TYPICAL;PRICE_WEIGHTED;
</keywords>
<content>
    <p>提供的价格常数，它可以是以下的任意值:</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums" width="95%">
        <tr><th width="15%">常数</th><th width="10%">值</th><th width="75%">描述</th></tr>
<tr><td>PRICE_CLOSE</td><td>0</td><td>平仓价</td></tr>
<tr><td>PRICE_OPEN</td><td>1</td><td>开仓价</td></tr>
<tr><td>PRICE_HIGH</td><td>2</td><td>最高价</td></tr>
<tr><td>PRICE_LOW</td><td>3</td><td>最低价</td></tr>
<tr><td>PRICE_MEDIAN</td><td>4</td><td>中间价(high+low)/2.</td></tr>
<tr><td>PRICE_TYPICAL</td><td>5</td><td>典型价格 (high+low+close)/3.</td></tr>
<tr><td>PRICE_WEIGHTED</td><td>6</td><td>价格 (high+low+close+close)/4.</td></tr>
</table>

</content>
</text>
<text>
tag=constants_marketinfo
caption=MarketInfo
<keywords>
;MarketInfo;MODE_BID;MODE_ASK;MODE_POINT;MODE_DIGITS;MODE_SPREAD;MODE_TIME;MODE_LOW;MODE_HIGH;MODE_TIME;MODE_STOPLEVEL;
</keywords>
<content>
    <p>市场信息识别符，使用<a href="help://common_MarketInfo">MarketInfo()</a>函数。<br/>
可以是以下任意值:</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums" width="95%">
        <tr><th width="15%">常数</th><th width="10%">值</th><th width="75%">描述</th></tr>
<tr><td>MODE_LOW</td><td>1</td><td>价格最低日。</td></tr>
<tr><td>MODE_HIGH</td><td>2</td><td>价格最高日。</td></tr>
<tr><td>MODE_TIME</td><td>5</td><td>最后进入替克的时间 (服务器显示时间)。</td></tr>
<tr><td>MODE_BID</td><td>9</td><td>最后进入的买价。对于、当前货币对预定变量存储的  <a href="help://predefined_variables_Bid">买价</a>。</td></tr>
<tr><td>MODE_ASK</td><td>10</td><td>最后进入的卖价。对于、当前货币对预定变量存储的  <a href="help://predefined_variables_Ask">卖价</a>。</td></tr>
<tr><td>MODE_POINT</td><td>11</td><td>当前价位的大小点。对于当前货币对预定变量储存的<a href="help://predefined_variables_Point">点</a>。</td></tr>
<tr><td>MODE_DIGITS</td><td>12</td><td>在货币对值中小数点后的计数点。对于当前货币对预定变量存储的小数点<a href="help://predefined_variables_Digits">计数</a>。</td></tr>
<tr><td>MODE_SPREAD</td><td>13</td><td>差价点。</td></tr>
<tr><td>MODE_STOPLEVEL</td><td>14</td><td>停止水平点。</td></tr>
<tr><td>MODE_LOTSIZE</td><td>15</td><td>基本货币的标准手大小。</td></tr>
<tr><td>MODE_TICK值</td><td>16</td><td>在存款货币中的替克值。</td></tr>
<tr><td>MODE_TICKSIZE</td><td>17</td><td>在当前报价中的替克大小。</td></tr>
<tr><td>MODE_SWAPLONG</td><td>18</td><td>看涨仓位掉期。</td></tr>
<tr><td>MODE_SWAPSHORT</td><td>19</td><td>卖空仓位掉期。</td></tr>
<tr><td>MODE_STARTING</td><td>20</td><td>市场开始日期 (通常用作将来）。</td></tr>
<tr><td>MODE_EXPIRATION</td><td>21</td><td>市场时间周期 (通常用作将来)。</td></tr>
<tr><td>MODE_TRADEALLOWED</td><td>22</td><td>交易允许货币对。</td></tr>
<tr><td>MODE_MINLOT</td><td>23</td><td>最小允许标准手数。</td></tr>
<tr><td>MODE_LOTSTEP</td><td>24</td><td>改变标准手步骤。</td></tr>
<tr><td>MODE_MAXLOT</td><td>25</td><td>最大允许标准手数。</td></tr>
<tr><td>MODE_SWAPTYPE</td><td>26</td><td>掉期计算方法. 0 - 点; 1 -基本货币对; 2 - 兴趣; 3 - 货币保证金。</td></tr>
<tr><td>MODE_PROFITCALCMODE</td><td>27</td><td>赢利计算模式0 - Forex; 1 - CFD; 2 - Futrues。</td></tr>
<tr><td>MODE_MARGINCALCMODE</td><td>28</td><td>保证金计算模式. 0 - Forex; 1 - CFD; 2 - Futrues; 3 - CFD for indices。</td></tr>
<tr><td>MODE_MARGININIT</td><td>29</td><td>对于1各标准手的初始保证金需求。</td></tr>
<tr><td>MODE_MARGINMAINTENANCE</td><td>30</td><td>对于1各标准手开仓的保证金。</td></tr>
<tr><td>MODE_MARGINHEDGED</td><td>31</td><td>对于1标准手的护盘保证金。</td></tr>
<tr><td>MODE_MARGINREQUIRED</td><td>32</td><td>对于购买一个标准手开仓的自由保证金。</td></tr>
<tr><td>MODE_FREEZELEVEL</td><td>33</td><td>冻结定单水平点。如果执行的价格在冻结水平点范围内，定单将会被注销或关闭。</td></tr>
</table>

</content>
</text>
<text>
tag=constants_drawstyles
caption=Drawing styles
<keywords>
;Drawing styles;DRAW_NONE;DRAW_LINE;DRAW_SECTION;DRAW_HISTOGRAM;DRAW_ARROW;STYLE_SOLID;STYLE_DASH;STYLE_DOT;STYLE_DASHDOT;STYLE_DASHDOTDOT;
</keywords>
<content>
    <p><a href="help://customind_SetIndexStyle">SetIndexStyle()</a>函数画线风格的列举。</p>
<p>可以是以下任意值:</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums" width="95%">
        <tr><th width="15%">常数</th><th width="10%">值</th><th width="75%">描述</th></tr>
<tr><td>DRAW_LINE</td><td>0</td><td>画线</td>
</tr>
<tr><td>DRAW_SECTION</td><td>1</td><td>线条</td>
</tr>
<tr><td>DRAW_HISTOGRAM</td><td>2</td><td>画柱状图</td>
</tr>
<tr><td>DRAW_ARROW</td><td>3</td><td>画箭头(货币对)。</td>
</tr>
<tr><td>DRAW_ZIGZAG</td><td>4</td><td>在添加的缓冲器之间画线条</td>
</tr>
<tr><td>DRAW_NONE</td><td>12</td><td>没有画线</td>
</tr>
</table>
<p>画线风格。有效宽度为1.。可以是以下任意值：</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums" width="95%">
        <tr><th width="15%">常数</th><th width="10%">值</th><th width="75%">描述</th></tr>
<tr><td>STYLE_SOLID</td><td>0</td><td>实线</td>
</tr>
<tr><td>STYLE_DASH</td><td>1</td><td>断线</td>
</tr>
<tr><td>STYLE_DOT</td><td>2</td><td>点线</td>
</tr>
<tr><td>STYLE_DASHDOT</td><td>3</td><td>断线与点线交替.</td>
</tr>
<tr><td>STYLE_DASHDOTDOT</td><td>4</td><td>断线与双点线交替</td>
</tr>
</table>

</content>
</text>
<text>
tag=constants_arrows
caption=Arrow codes
<keywords>
;Arrow codes;SYMBOL_LEFTPRICE;SYMBOL_RIGHTPRICE;SYMBOL_THUMBSUP;SYMBOL_THUMBSDOWN;SYMBOL_ARROWUP;SYMBOL_ARROWDOWN;SYMBOL_STOPSIGN;SYMBOL_CHECKSIGN;
</keywords>
<content>
    <p>预定义箭头列举。箭头代码。

 可以是以下的任意值：</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums" width="95%">
        <tr><th width="15%">常数</th><th width="10%">值</th><th width="75%">描述</th></tr>
<tr><td>SYMBOL_THUMBSUP</td><td>67</td><td>大拇指向上 (<span style="font: 12pt Wingdings;">&#67;</span>).</td></tr>
<tr><td>SYMBOL_THUMBSDOWN</td><td>68</td><td>大拇指向下 (<span style="font: 12pt Wingdings;">&#68;</span>).</td></tr>
<tr><td>SYMBOL_ARROWUP</td><td>241</td><td>箭头向上 (<span style="font: 12pt Wingdings;">&#241;</span>).</td></tr>
<tr><td>SYMBOL_ARROWDOWN</td><td>242</td><td>箭头向下  (<span style="font: 12pt Wingdings;">&#242;</span>).</td></tr>
<tr><td>SYMBOL_STOPSIGN</td><td>251</td><td>禁止货币对(<span style="font: 12pt Wingdings;">&#251;</span>).</td></tr>
<tr><td>SYMBOL_CHECKSIGN</td><td>252</td><td>检验货币对 (<span style="font: 12pt Wingdings;">&#252;</span>).</td></tr>
</table>
<p>对于价格和时间的特殊箭头代码。可以是以下任意值:</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums" width="95%">
        <tr><th width="15%">常数</th><th width="10%">值</th><th width="75%">描述</th></tr>
<tr><td>&nbsp;</td><td>1</td><td>右上转箭头 (<span style="font: 12pt Lucida Sans Unicode;">&#8625;</span>).</td></tr>
<tr><td>&nbsp;</td><td>2</td><td>右下转箭头(<span style="font: 12pt Lucida Sans Unicode;">&#8627;</span>).</td></tr>
<tr><td>&nbsp;</td><td>3</td><td>左指向三角 (<span style="font: 12pt Arial;">&#9668;</span>).</td></tr>
<tr><td>&nbsp;</td><td>4</td><td>破折号(&#8211;).</td></tr>
<tr><td>SYMBOL_LEFTPRICE</td><td>5</td><td>价格左侧标签</td></tr>
<tr><td>SYMBOL_RIGHTPRICE</td><td>6</td><td>价格右侧标签</td></tr>
</table>

</content>
</text>
<text>
tag=constants_wingdings
caption=Wingdings
<keywords>
;Wingdings;
</keywords>
<content>
    <p>使用在箭头对象的Wingdings铅字符。</p>
<table border="0" cellspacing="0" cellpadding="2" class="symbols">
<tr><td class="l_smb">&#32;</td><td class="l_code">32</td><td class="l_smb">&#33;</td><td class="l_code">33</td>
<td class="l_smb">&#34;</td><td class="l_code">34</td><td class="l_smb">&#35;</td><td class="l_code">35</td>
<td class="l_smb">&#36;</td><td class="l_code">36</td><td class="l_smb">&#37;</td><td class="l_code">37</td>
<td class="l_smb">&#38;</td><td class="l_code">38</td><td class="l_smb">&#39;</td><td class="l_code">39</td>
<td class="l_smb">&#40;</td><td class="l_code">40</td><td class="l_smb">&#41;</td><td class="l_code">41</td>
<td class="l_smb">&#42;</td><td class="l_code">42</td><td class="l_smb">&#43;</td><td class="l_code">43</td>
<td class="l_smb">&#44;</td><td class="l_code">44</td><td class="l_smb">&#45;</td><td class="l_code">45</td>
<td class="l_smb">&#46;</td><td class="l_code">46</td><td class="l_smb">&#47;</td><td>47</td></tr>
<tr><td class="d_smb">&#48;</td><td class="d_code">48</td><td class="d_smb">&#49;</td><td class="d_code">49</td>
<td class="d_smb">&#50;</td><td class="d_code">50</td><td class="d_smb">&#51;</td><td class="d_code">51</td>
<td class="d_smb">&#52;</td><td class="d_code">52</td><td class="d_smb">&#53;</td><td class="d_code">53</td>
<td class="d_smb">&#54;</td><td class="d_code">54</td><td class="d_smb">&#55;</td><td class="d_code">55</td>
<td class="d_smb">&#56;</td><td class="d_code">56</td><td class="d_smb">&#57;</td><td class="d_code">57</td>
<td class="d_smb">&#58;</td><td class="d_code">58</td><td class="d_smb">&#59;</td><td class="d_code">59</td>
<td class="d_smb">&#60;</td><td class="d_code">60</td><td class="d_smb">&#61;</td><td class="d_code">61</td>
<td class="d_smb">&#62;</td><td class="d_code">62</td><td class="d_smb">&#63;</td><td class="d_code_e">63</td></tr>
<tr><td class="l_smb">&#64;</td><td class="l_code">64</td><td class="l_smb">&#65;</td><td class="l_code">65</td>
<td class="l_smb">&#66;</td><td class="l_code">66</td><td class="l_smb">&#67;</td><td class="l_code">67</td>
<td class="l_smb">&#68;</td><td class="l_code">68</td><td class="l_smb">&#69;</td><td class="l_code">69</td>
<td class="l_smb">&#70;</td><td class="l_code">70</td><td class="l_smb">&#71;</td><td class="l_code">71</td>
<td class="l_smb">&#72;</td><td class="l_code">72</td><td class="l_smb">&#73;</td><td class="l_code">73</td>
<td class="l_smb">&#74;</td><td class="l_code">74</td><td class="l_smb">&#75;</td><td class="l_code">75</td>
<td class="l_smb">&#76;</td><td class="l_code">76</td><td class="l_smb">&#77;</td><td class="l_code">77</td>
<td class="l_smb">&#78;</td><td class="l_code">78</td><td class="l_smb">&#79;</td><td>79</td></tr>
<tr><td class="d_smb">&#80;</td><td class="d_code">80</td><td class="d_smb">&#81;</td><td class="d_code">81</td>
<td class="d_smb">&#82;</td><td class="d_code">82</td><td class="d_smb">&#83;</td><td class="d_code">83</td>
<td class="d_smb">&#84;</td><td class="d_code">84</td><td class="d_smb">&#85;</td><td class="d_code">85</td>
<td class="d_smb">&#86;</td><td class="d_code">86</td><td class="d_smb">&#87;</td><td class="d_code">87</td>
<td class="d_smb">&#88;</td><td class="d_code">88</td><td class="d_smb">&#89;</td><td class="d_code">89</td>
<td class="d_smb">&#90;</td><td class="d_code">90</td><td class="d_smb">&#91;</td><td class="d_code">91</td>
<td class="d_smb">&#92;</td><td class="d_code">92</td><td class="d_smb">&#93;</td><td class="d_code">93</td>
<td class="d_smb">&#94;</td><td class="d_code">94</td><td class="d_smb">&#95;</td><td class="d_code_e">95</td></tr>
<tr><td class="l_smb">&#96;</td><td class="l_code">96</td><td class="l_smb">&#97;</td><td class="l_code">97</td>
<td class="l_smb">&#98;</td><td class="l_code">98</td><td class="l_smb">&#99;</td><td class="l_code">99</td>
<td class="l_smb">&#100;</td><td class="l_code">100</td><td class="l_smb">&#101;</td><td class="l_code">101</td>
<td class="l_smb">&#102;</td><td class="l_code">102</td><td class="l_smb">&#103;</td><td class="l_code">103</td>
<td class="l_smb">&#104;</td><td class="l_code">104</td><td class="l_smb">&#105;</td><td class="l_code">105</td>
<td class="l_smb">&#106;</td><td class="l_code">106</td><td class="l_smb">&#107;</td><td class="l_code">107</td>
<td class="l_smb">&#108;</td><td class="l_code">108</td><td class="l_smb">&#109;</td><td class="l_code">109</td>
<td class="l_smb">&#110;</td><td class="l_code">110</td><td class="l_smb">&#111;</td><td>111</td></tr>
<tr><td class="d_smb">&#112;</td><td class="d_code">112</td><td class="d_smb">&#113;</td><td class="d_code">113</td>
<td class="d_smb">&#114;</td><td class="d_code">114</td><td class="d_smb">&#115;</td><td class="d_code">115</td>
<td class="d_smb">&#116;</td><td class="d_code">116</td><td class="d_smb">&#117;</td><td class="d_code">117</td>
<td class="d_smb">&#118;</td><td class="d_code">118</td><td class="d_smb">&#119;</td><td class="d_code">119</td>
<td class="d_smb">&#120;</td><td class="d_code">120</td><td class="d_smb">&#121;</td><td class="d_code">121</td>
<td class="d_smb">&#122;</td><td class="d_code">122</td><td class="d_smb">&#123;</td><td class="d_code">123</td>
<td class="d_smb">&#124;</td><td class="d_code">124</td><td class="d_smb">&#125;</td><td class="d_code">125</td>
<td class="d_smb">&#126;</td><td class="d_code">126</td><td class="d_smb">&#127;</td><td class="d_code_e">127</td></tr>
<tr><td class="l_smb">&#128;</td><td class="l_code">128</td><td class="l_smb">&#129;</td><td class="l_code">129</td>
<td class="l_smb">&#130;</td><td class="l_code">130</td><td class="l_smb">&#131;</td><td class="l_code">131</td>
<td class="l_smb">&#132;</td><td class="l_code">132</td><td class="l_smb">&#133;</td><td class="l_code">133</td>
<td class="l_smb">&#134;</td><td class="l_code">134</td><td class="l_smb">&#135;</td><td class="l_code">135</td>
<td class="l_smb">&#136;</td><td class="l_code">136</td><td class="l_smb">&#137;</td><td class="l_code">137</td>
<td class="l_smb">&#138;</td><td class="l_code">138</td><td class="l_smb">&#139;</td><td class="l_code">139</td>
<td class="l_smb">&#140;</td><td class="l_code">140</td><td class="l_smb">&#141;</td><td class="l_code">141</td>
<td class="l_smb">&#142;</td><td class="l_code">142</td><td class="l_smb">&#143;</td><td>143</td></tr>
<tr><td class="d_smb">&#144;</td><td class="d_code">144</td><td class="d_smb">&#145;</td><td class="d_code">145</td>
<td class="d_smb">&#146;</td><td class="d_code">146</td><td class="d_smb">&#147;</td><td class="d_code">147</td>
<td class="d_smb">&#148;</td><td class="d_code">148</td><td class="d_smb">&#149;</td><td class="d_code">149</td>
<td class="d_smb">&#150;</td><td class="d_code">150</td><td class="d_smb">&#151;</td><td class="d_code">151</td>
<td class="d_smb">&#152;</td><td class="d_code">152</td><td class="d_smb">&#153;</td><td class="d_code">153</td>
<td class="d_smb">&#154;</td><td class="d_code">154</td><td class="d_smb">&#155;</td><td class="d_code">155</td>
<td class="d_smb">&#156;</td><td class="d_code">156</td><td class="d_smb">&#157;</td><td class="d_code">157</td>
<td class="d_smb">&#158;</td><td class="d_code">158</td><td class="d_smb">&#159;</td><td class="d_code_e">159</td></tr>
<tr><td class="l_smb">&#160;</td><td class="l_code">160</td><td class="l_smb">&#161;</td><td class="l_code">161</td>
<td class="l_smb">&#162;</td><td class="l_code">162</td><td class="l_smb">&#163;</td><td class="l_code">163</td>
<td class="l_smb">&#164;</td><td class="l_code">164</td><td class="l_smb">&#165;</td><td class="l_code">165</td>
<td class="l_smb">&#166;</td><td class="l_code">166</td><td class="l_smb">&#167;</td><td class="l_code">167</td>
<td class="l_smb">&#168;</td><td class="l_code">168</td><td class="l_smb">&#169;</td><td class="l_code">169</td>
<td class="l_smb">&#170;</td><td class="l_code">170</td><td class="l_smb">&#171;</td><td class="l_code">171</td>
<td class="l_smb">&#172;</td><td class="l_code">172</td><td class="l_smb">&#173;</td><td class="l_code">173</td>
<td class="l_smb">&#174;</td><td class="l_code">174</td><td class="l_smb">&#175;</td><td>175</td></tr>
<tr><td class="d_smb">&#176;</td><td class="d_code">176</td><td class="d_smb">&#177;</td><td class="d_code">177</td>
<td class="d_smb">&#178;</td><td class="d_code">178</td><td class="d_smb">&#179;</td><td class="d_code">179</td>
<td class="d_smb">&#180;</td><td class="d_code">180</td><td class="d_smb">&#181;</td><td class="d_code">181</td>
<td class="d_smb">&#182;</td><td class="d_code">182</td><td class="d_smb">&#183;</td><td class="d_code">183</td>
<td class="d_smb">&#184;</td><td class="d_code">184</td><td class="d_smb">&#185;</td><td class="d_code">185</td>
<td class="d_smb">&#186;</td><td class="d_code">186</td><td class="d_smb">&#187;</td><td class="d_code">187</td>
<td class="d_smb">&#188;</td><td class="d_code">188</td><td class="d_smb">&#189;</td><td class="d_code">189</td>
<td class="d_smb">&#190;</td><td class="d_code">190</td><td class="d_smb">&#191;</td><td class="d_code_e">191</td></tr>
<tr><td class="l_smb">&#192;</td><td class="l_code">192</td><td class="l_smb">&#193;</td><td class="l_code">193</td>
<td class="l_smb">&#194;</td><td class="l_code">194</td><td class="l_smb">&#195;</td><td class="l_code">195</td>
<td class="l_smb">&#196;</td><td class="l_code">196</td><td class="l_smb">&#197;</td><td class="l_code">197</td>
<td class="l_smb">&#198;</td><td class="l_code">198</td><td class="l_smb">&#199;</td><td class="l_code">199</td>
<td class="l_smb">&#200;</td><td class="l_code">200</td><td class="l_smb">&#201;</td><td class="l_code">201</td>
<td class="l_smb">&#202;</td><td class="l_code">202</td><td class="l_smb">&#203;</td><td class="l_code">203</td>
<td class="l_smb">&#204;</td><td class="l_code">204</td><td class="l_smb">&#205;</td><td class="l_code">205</td>
<td class="l_smb">&#206;</td><td class="l_code">206</td><td class="l_smb">&#207;</td><td>207</td></tr>
<tr><td class="d_smb">&#208;</td><td class="d_code">208</td><td class="d_smb">&#209;</td><td class="d_code">209</td>
<td class="d_smb">&#210;</td><td class="d_code">210</td><td class="d_smb">&#211;</td><td class="d_code">211</td>
<td class="d_smb">&#212;</td><td class="d_code">212</td><td class="d_smb">&#213;</td><td class="d_code">213</td>
<td class="d_smb">&#214;</td><td class="d_code">214</td><td class="d_smb">&#215;</td><td class="d_code">215</td>
<td class="d_smb">&#216;</td><td class="d_code">216</td><td class="d_smb">&#217;</td><td class="d_code">217</td>
<td class="d_smb">&#218;</td><td class="d_code">218</td><td class="d_smb">&#219;</td><td class="d_code">219</td>
<td class="d_smb">&#220;</td><td class="d_code">220</td><td class="d_smb">&#221;</td><td class="d_code">221</td>
<td class="d_smb">&#222;</td><td class="d_code">222</td><td class="d_smb">&#223;</td><td class="d_code_e">223</td></tr>
<tr><td class="l_smb">&#224;</td><td class="l_code">224</td><td class="l_smb">&#225;</td><td class="l_code">225</td>
<td class="l_smb">&#226;</td><td class="l_code">226</td><td class="l_smb">&#227;</td><td class="l_code">227</td>
<td class="l_smb">&#228;</td><td class="l_code">228</td><td class="l_smb">&#229;</td><td class="l_code">229</td>
<td class="l_smb">&#230;</td><td class="l_code">230</td><td class="l_smb">&#231;</td><td class="l_code">231</td>
<td class="l_smb">&#232;</td><td class="l_code">232</td><td class="l_smb">&#233;</td><td class="l_code">233</td>
<td class="l_smb">&#234;</td><td class="l_code">234</td><td class="l_smb">&#235;</td><td class="l_code">235</td>
<td class="l_smb">&#236;</td><td class="l_code">236</td><td class="l_smb">&#237;</td><td class="l_code">237</td>
<td class="l_smb">&#238;</td><td class="l_code">238</td><td class="l_smb">&#239;</td><td>239</td></tr>
<tr><td class="d_smb">&#240;</td><td class="d_code">240</td><td class="d_smb">&#241;</td><td class="d_code">241</td>
<td class="d_smb">&#242;</td><td class="d_code">242</td><td class="d_smb">&#243;</td><td class="d_code">243</td>
<td class="d_smb">&#244;</td><td class="d_code">244</td><td class="d_smb">&#245;</td><td class="d_code">245</td>
<td class="d_smb">&#246;</td><td class="d_code">246</td><td class="d_smb">&#247;</td><td class="d_code">247</td>
<td class="d_smb">&#248;</td><td class="d_code">248</td><td class="d_smb">&#249;</td><td class="d_code">249</td>
<td class="d_smb">&#250;</td><td class="d_code">250</td><td class="d_smb">&#251;</td><td class="d_code">251</td>
<td class="d_smb">&#252;</td><td class="d_code">252</td><td class="d_smb">&#253;</td><td class="d_code">253</td>
<td class="d_smb">&#254;</td><td class="d_code">254</td><td class="d_smb">&#255;</td><td class="d_code_e">255</td></tr>
</table>

</content>
</text>
<text>
tag=constants_colors
caption=Web colors
<keywords>
;Black;DarkGreen;DarkSlateGray;Olive;Green;Teal;Navy;Purple;Maroon;Indigo;MidnightBlue;DarkBlueDarkOliveGreen;SaddleBrown;ForestGreen;OliveDrab;SeaGreen;DarkGoldenrod;DarkSlateBlue;Sienna;MediumBlueBrown;DarkTurquoise;DimGray;LightSeaGreen;DarkViolet;FireBrick;MediumVioletRed;MediumSeaGreenChocolate;Crimson;SteelBlue;Goldenrod;MediumSpringGreen;LawnGreen;CadetBlue;DarkOrchid;YellowGreenLimeGreen;OrangeRed;DarkOrange;Orange;Gold;Yellow;Chartreuse;Lime;SpringGreen;Aqua;DeepSkyBlue;BlueMagenta;Red;Gray;SlateGray;Peru;BlueViolet;LightSlateGray;DeepPink;MediumTurquoise;DodgerBlueTurquoise;RoyalBlue;SlateBlue;DarkKhaki;IndianRed;MediumOrchid;GreenYellow;MediumAquamarineDarkSeaGreen;Tomato;RosyBrown;Orchid;MediumPurple;PaleVioletRed;Coral;CornflowerBlue;DarkGraySandyBrown;MediumSlateBlue;Tan;DarkSalmon;BurlyWood;HotPink;Salmon;Violet;LightCoral;SkyBlueLightSalmon;Plum;Khaki;LightGreen;Aquamarine;Silver;LightSkyBlue;LightSteelBlue;LightBluePaleGreen;Thistle;PowderBlue;PaleGoldenrod;PaleTurquoise;LightGray;Wheat;NavajoWhite;Moccasin;LightPinkGainsboro;PeachPuff;Pink;Bisque;LightGoldenrod;;;;;;;;;;;;;;;;;;;;
</keywords>
<content>
         建议颜色常数类型。
        <table style="FONT-SIZE: 8pt; FONT-FAMILY: Tahoma" cellspacing="1" cellpadding="2" bgcolor="#c0c0c0" border="0" width="96%">
        <tr align="center">
          <td style="background: black; color: white;" width="12.5%">Black</td>
          <td style="background: darkgreen; color: white" width="12.5%">DarkGreen</td>
          <td style="background: darkslategray; color: white" width="12.5%">DarkSlateGray</td>
          <td style="background: olive; color: white" width="12.5%">Olive</td>
          <td style="background: green; color: white" width="12.5%">Green</td>
          <td style="background: teal; color: white" width="12.5%">Teal</td>
          <td style="background: navy; color: white" width="12.5%">Navy</td>
          <td style="background: purple; color: white" width="12.5%">Purple</td></tr>
        <tr align="center">
          <td style="background: maroon; color: white">Maroon</td>
          <td style="background: indigo; color: white">Indigo</td>
          <td style="background: midnightblue; color: white">MidnightBlue</td>
          <td style="background: darkblue; color: white">DarkBlue</td>
          <td style="background: darkolivegreen; color: white">DarkOliveGreen</td>
          <td style="background: saddlebrown; color: white">SaddleBrown</td>
          <td style="background: forestgreen; color: white">ForestGreen</td>
          <td style="background: olivedrab; color: white">OliveDrab</td></tr>
        <tr align="center">
          <td style="background: seagreen; color: white">SeaGreen</td>
          <td style="background: darkgoldenrod; color: white">DarkGoldenrod</td>
          <td style="background: darkslateblue; color: white">DarkSlateBlue</td>
          <td style="background: sienna; color: white">Sienna</td>
          <td style="background: mediumblue; color: white">MediumBlue</td>
          <td style="background: brown; color: white">Brown</td>
          <td style="background: darkturquoise">DarkTurquoise</td>
          <td style="background: dimgray; color: white">DimGray</td></tr>
        <tr align="center">
          <td style="background: lightseagreen">LightSeaGreen</td>
          <td style="background: darkviolet; color: white">DarkViolet</td>
          <td style="background: firebrick; color: white">FireBrick</td>
          <td style="background: mediumvioletred; color: white">MediumVioletRed</td>
          <td style="background: mediumseagreen; color: white">MediumSeaGreen</td>
          <td style="background: chocolate; color: white">Chocolate</td>
          <td style="background: crimson; color: white">Crimson</td>
          <td style="background: steelblue; color: white">SteelBlue</td></tr>
        <tr align="center">
          <td style="background: goldenrod">Goldenrod</td>
          <td style="background: mediumspringgreen; color: black">MediumSpringGreen</td>
          <td style="background: lawngreen; color: black">LawnGreen</td>
          <td style="background: cadetblue; color: white">CadetBlue</td>
          <td style="background: darkorchid; color: white">DarkOrchid</td>
          <td style="background: yellowgreen; color: white">YellowGreen</td>
          <td style="background: limegreen; color: white">LimeGreen</td>
          <td style="background: orangered; color: white">OrangeRed</td></tr>
        <tr align="center">
          <td style="background: darkorange; color: white">DarkOrange</td>
          <td style="background: orange">Orange</td>
          <td style="background: gold">Gold</td>
          <td style="background: yellow">Yellow</td>
          <td style="background: chartreuse; color: black">Chartreuse</td>
          <td style="background: lime; color: black">Lime</td>
          <td style="background: springgreen; color: black">SpringGreen</td>
          <td style="background: aqua">Aqua</td></tr>
        <tr align="center">
          <td style="background: deepskyblue">DeepSkyBlue</td>
          <td style="background: blue; color: white">Blue</td>
          <td style="background: magenta">Magenta</td>
          <td style="background: red; color: white">Red</td>
          <td style="background: gray; color: white">Gray</td>
          <td style="background: slategray; color: white">SlateGray</td>
          <td style="background: peru; color: white">Peru</td>
          <td style="background: blueviolet; color: white">BlueViolet</td></tr>
        <tr align="center">
          <td style="background: lightslategray; color: white">LightSlateGray</td>
          <td style="background: deeppink; color: white">DeepPink</td>
          <td style="background: mediumturquoise">MediumTurquoise</td>
          <td style="background: dodgerblue; color: white">DodgerBlue</td>
          <td style="background: turquoise">Turquoise</td>
          <td style="background: royalblue; color: white">RoyalBlue</td>
          <td style="background: slateblue; color: white">SlateBlue</td>
          <td style="background: darkkhaki">DarkKhaki</td></tr>
        <tr align="center">
          <td style="background: indianred; color: white">IndianRed</td>
          <td style="background: mediumorchid">MediumOrchid</td>
          <td style="background: greenyellow">GreenYellow</td>
          <td style="background: mediumaquamarine">MediumAquamarine</td>
          <td style="background: darkseagreen; color: white">DarkSeaGreen</td>
          <td style="background: tomato; color: white">Tomato</td>
          <td style="background: rosybrown; color: white">RosyBrown</td>
          <td style="background: orchid">Orchid</td></tr>
        <tr align="center">
          <td style="background: mediumpurple; color: white">MediumPurple</td>
          <td style="background: palevioletred; color: white">PaleVioletRed</td>
          <td style="background: coral; color: white">Coral</td>
          <td style="background: cornflowerblue; color: white">CornflowerBlue</td>
          <td style="background: darkgray">DarkGray</td>
          <td style="background: sandybrown">SandyBrown</td>
          <td style="background: mediumslateblue; color: white">MediumSlateBlue</td>
          <td style="background: tan">Tan</td></tr>
        <tr align="center">
          <td style="background: darksalmon; color: white">DarkSalmon</td>
          <td style="background: burlywood">BurlyWood</td>
          <td style="background: hotpink">HotPink</td>
          <td style="background: salmon; color: white">Salmon</td>
          <td style="background: violet">Violet</td>
          <td style="background: lightcoral; color: white">LightCoral</td>
          <td style="background: skyblue">SkyBlue</td>
          <td style="background: lightsalmon">LightSalmon</td></tr>
        <tr align="center">
          <td style="background: plum">Plum</td>
          <td style="background: khaki">Khaki</td>
          <td style="background: lightgreen; color: black">LightGreen</td>
          <td style="background: aquamarine">Aquamarine</td>
          <td style="background: silver">Silver</td>
          <td style="background: lightskyblue">LightSkyBlue</td>
          <td style="background: lightsteelblue">LightSteelBlue</td>
          <td style="background: lightblue">LightBlue</td></tr>
        <tr align="center">
          <td style="background: palegreen; color: black">PaleGreen</td>
          <td style="background: thistle">Thistle</td>
          <td style="background: powderblue">PowderBlue</td>
          <td style="background: palegoldenrod">PaleGoldenrod</td>
          <td style="background: paleturquoise">PaleTurquoise</td>
          <td style="background: f0f8ff">LightGray</td>
          <td style="background: wheat">Wheat</td>
          <td style="background: navajowhite">NavajoWhite</td></tr>
        <tr align="center">
          <td style="background: moccasin">Moccasin</td>
          <td style="background: lightpink">LightPink</td>
          <td style="background: gainsboro">Gainsboro</td>
          <td style="background: peachpuff">PeachPuff</td>
          <td style="background: pink">Pink</td>
          <td style="background: bisque">Bisque</td>
          <td style="background: eedc82">LightGoldenrod</td>
          <td style="background: blanchedalmond">BlanchedAlmond</td></tr>
        <tr align="center">
          <td style="background: lemonchiffon">LemonChiffon</td>
          <td style="background: beige">Beige</td>
          <td style="background: antiquewhite">AntiqueWhite</td>
          <td style="background: papayawhip">PapayaWhip</td>
          <td style="background: cornsilk">Cornsilk</td>
          <td style="background: lightyellow">LightYellow</td>
          <td style="background: lightcyan">LightCyan</td>
          <td style="background: linen">Linen</td></tr>
        <tr align="center">
          <td style="background: lavender">Lavender</td>
          <td style="background: mistyrose">MistyRose</td>
          <td style="background: oldlace">OldLace</td>
          <td style="background: whitesmoke">WhiteSmoke</td>
          <td style="background: seashell">Seashell</td>
          <td style="background: ivory">Ivory</td>
          <td style="background: honeydew">Honeydew</td>
          <td style="background: aliceblue">AliceBlue</td></tr>
        <tr align="center">
          <td style="background: lavenderblush">LavenderBlush</td>
          <td style="background: mintcream">MintCream</td>
          <td style="background: snow">Snow</td>
          <td style="background: white">White</td>
          <td style="background: white"></td>
          <td style="background: white"></td>
          <td style="background: white"></td>
          <td style="background: white"></td></tr>
        </table>

</content>
</text>
<text>
tag=constants_lines
caption=Indicator lines
<keywords>
;Indicator lines;MODE_MAIN;MODE_PLUSDI;MODE_MINUSDI;MODE_SIGNAL;MODE_UPPER;MODE_LOWER;
</keywords>
<content>
    <p>指标线识别在<a href="help://indicators_iMACD">iMACD()</a>, <a href="help://indicators_iRVI">iRVI()</a>
和<a href="help://indicators_iStochastic">iStochastic()</a> 指标中使用。<br/>
可以是以下的任意值:</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums" width="95%">
        <tr><th width="15%">常数</th><th width="10%">值</th><th width="75%">描述</th></tr>
<tr><td>MODE_MAIN</td><td>0</td>
<td>基本指标线。</td>
</tr>
<tr><td>MODE_SIGNAL</td><td>1</td>
<td>信号线。</td>
</tr>
</table>
<p>指标线识别符在<a href="help://indicators_iADX">iADX()</a>指标中使用。</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums" width="95%">
        <tr><th width="15%">常数</th><th width="10%">值</th><th width="75%">描述</th></tr>
<tr><td>MODE_MAIN</td><td>0</td>
<td>基本指标线。</td>
</tr>
<tr><td>MODE_PLUSDI</td><td>1</td>
<td>+DI 指标线。</td>
</tr>
<tr><td>MODE_MINUSDI</td><td>2</td>
<td>-DI 指标线。</td>
</tr>
</table>
<p>指标线识别符在 <a href="help://indicators_iBands">iBands()</a>,
<a href="help://indicators_iEnvelopes">iEnvelopes()</a>, <a href="help://indicators_iEnvelopesOnArray">iEnvelopesOnArray()</a>, <a href="help://indicators_iFractals">iFractals()</a>
和 <a href="help://indicators_iGator">iGator()</a> 指标中使用。</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums" width="95%">
        <tr><th width="15%">常数</th><th width="10%">值</th><th width="75%">描述</th></tr>
<tr><td>MODE_UPPER</td><td>1</td>
<td>上面线。</td>
</tr>
<tr><td>MODE_LOWER</td><td>2</td>
<td>下面线。</td>
</tr>
</table>

</content>
</text>
<text>
tag=constants_ichimoku
caption=Ichimoku Kinko Hyo
<keywords>
;Ichimoku Kinko Hyo;MODE_TENKANSEN;MODE_KIJUNSEN;MODE_SENKOUSPANA;MODE_SENKOUSPANB;MODE_CHINKOUSPAN;
</keywords>
<content>
    <p>Ichimoku Kinko Hyo识别符使用在<a href="help://indicators_iIchimoku">iIchimoku()</a> 指标中作为请求数据代码调用。<br/>
可以为以下任意值:</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums" width="95%">
        <tr><th width="15%">常数</th><th width="10%">值</th><th width="75%">描述</th></tr>
<tr><td>MODE_TENKANSEN</td><td>1</td><td>Tenkan-sen.</td></tr>
<tr><td>MODE_KIJUNSEN</td><td>2</td><td>Kijun-sen.</td></tr>
<tr><td>MODE_SENKOUSPANA</td><td>3</td><td>Senkou Span A.</td></tr>
<tr><td>MODE_SENKOUSPANB</td><td>4</td><td>Senkou Span B.</td></tr>
<tr><td>MODE_CHINKOUSPAN</td><td>5</td><td>Chinkou Span.</td></tr>
</table>

</content>
</text>
<text>
tag=constants_movings
caption=Moving Average methods
<keywords>
;Moving Average methods;MODE_SMA;MODE_EMA;MODE_SMMA;MODE_LWMA;
</keywords>
<content>
    <p>移动平均计算在<a href="help://indicators_iAlligator">iAlligator()</a>,
<a href="help://indicators_iEnvelopes">iEnvelopes()</a>, <a href="help://indicators_iEnvelopesOnArray">iEnvelopesOnArray</a>,
<a href="help://indicators_iForce">iForce()</a>, <a href="help://indicators_iGator">iGator()</a>,
<a href="help://indicators_iMA">iMA()</a>, <a href="help://indicators_iMAOnArray">iMAOnArray()</a>,
<a href="help://indicators_iStdDev">iStdDev()</a>, <a href="help://indicators_iStdDevOnArray">iStdDevOnArray()</a>,
<a href="help://indicators_iStochastic">iStochastic()</a>指标中使用。<br/>
可以使以下任意值:</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums" width="95%">
        <tr><th width="15%">常数</th><th width="10%">值</th><th width="75%">描述</th></tr>
<tr><td>MODE_SMA</td><td>0</td><td>简单移动平均数</td>
</tr>
<tr><td>MODE_EMA</td><td>1</td><td>指数移动平均数</td>
</tr>
<tr><td>MODE_SMMA</td><td>2</td><td>平滑移动平均数</td>
</tr>
<tr><td>MODE_LWMA</td><td>3</td><td>线性移动平均数</td>
</tr>
</table>

</content>
</text>
<text>
tag=constants_messagebox
caption=MessageBox
<keywords>
;MessageBox;IDOK;IDCANCEL;IDABORT;IDRETRY;IDIGNORE;IDYES;IDNO;IDTRYAGAIN;IDCONTINUEMB_OK;MB_OKCANCEL;MB_ABORTRETRYIGNORE;MB_YESNOCANCEL;MB_YESNO;MB_CANCELTRYCONTINUEMB_ICONSTOP;MB_ICONERROR;MB_ICONHAND;MB_ICONQUESTION;MB_ICONEXCLAMATION;MB_ICONWARNINGMB_ICONINFORMATION;MB_ICONASTERISK;MB_DEFBUTTON1;MB_DEFBUTTON2;MB_DEFBUTTON3;MB_DEFBUTTON4;
</keywords>
<content>
<p>The <a href="help://common_MessageBox">MessageBox()</a> function return codes.<br/>
如果选择信箱中<b>Cancel</b>按键或是ESC取消选择，函数返回 IDCANCEL 值 。 如果信箱中不存在<b>取消</b>按键，按ESC无效。<br/>
注解：消息框返回的代码在 WinUser32.mqh文件中。</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums" width="95%">
        <tr><th width="15%">常数</th><th width="10%">值</th><th width="75%">描述</th></tr>
<tr><td>IDOK</td><td>1</td><td>选择<b>确定</b> 按钮.</td></tr>
<tr><td>IDCANCEL</td><td>2</td><td>选择<b>取消</b>按钮.</td></tr>
<tr><td>IDABORT</td><td>3</td><td>选择<b>中止</b>按钮.</td></tr>
<tr><td>IDRETRY</td><td>4</td><td>选择<b>重试</b> 按钮.</td></tr>
<tr><td>IDIGNORE</td><td>5</td><td>选择<b>忽略</b> 按钮.</td></tr>
<tr><td>IDYES</td><td>6</td><td>选择<b>是</b> 按钮.</td></tr>
<tr><td>IDNO</td><td>7</td><td>选择<b>否</b> 按钮.</td></tr>
<tr><td>IDTRYAGAIN</td><td>10</td><td>选择<b>再次尝试</b>按钮.</td></tr>
<tr><td>IDCONTINUE</td><td>11</td><td>选择<b>继续</b> 按钮.</td></tr>
</table><br/>
<p><a href="help://common_MessageBox">MessageBox</a> 函数是一个具有特殊功能的对话框。可以和以下值结合并用。<br/>
<br/>
在邮箱中按键显示的意义。</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums" width="95%">
        <tr><th width="15%">常数</th><th width="10%">值</th><th width="75%">描述</th></tr>
<tr><td>MB_OK</td><td>0x00000000</td><td>消息框中包含的一个按钮: 确定 这是默认值.</td></tr>
<tr><td>MB_OKCANCEL</td><td>0x00000001</td><td>消息框中包含的两个按钮: 确定和取消.</td></tr>
<tr><td>MB_ABORTRETRYIGNORE</td><td>0x00000002</td><td>消息框中包含的三个按钮: 中止, 重试和忽略.</td></tr>
<tr><td>MB_YESNOCANCEL</td><td>0x00000003</td><td>消息框中包含的三个按钮: 是，否和取消</td></tr>
<tr><td>MB_YESNO</td><td>0x00000004</td><td>消息框中包含的两个按钮: 是和否</td></tr><tr><td>MB_RETRYCANCEL</td><td>0x00000005</td><td>消息框中包含的两个按钮: 重试和取消</td></tr>
<tr><td>MB_CANCELTRYCONTINUE</td><td>0x00000006</td><td>Windows 2000: 消息框中包含的三个按钮: 取消, 重试, 继续. 使用这个消息框类型代替</td></tr>
</table>
<p>To display an icon in the message box, specify one of the following values.</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums" width="95%">
        <tr><th width="15%">常数</th><th width="10%">值</th><th width="75%">描述</th></tr>
<tr><td>MB_ICONSTOP, MB_ICONERROR, MB_ICONHAND</td><td>0x00000010</td><td>禁止消息图标在邮箱内显示.</td></tr>
<tr><td>MB_ICONQUESTION</td><td>0x00000020</td><td>	问号图标出现在消息框内.</td></tr>
<tr><td>MB_ICONEXCLAMATION, MB_ICONWARNING</td><td>0x00000030</td><td>感叹号图标出现在消息框内.</td></tr>
<tr><td>MB_ICONINFORMATION, MB_ICONASTERISK</td><td>0x00000040</td><td>图标组成的短信息显示在消息框内.</td></tr>
</table>
<p>在消息框内显示的图标是以下值之一。</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums" width="95%">
        <tr><th width="15%">常数</th><th width="10%">值</th><th width="75%">描述</th></tr>
<tr><td>MB_DEFBUTTON1</td><td>0x00000000</td><td>第一个按钮为默认。 MB_DEFBUTTON1是默认的，MB_DEFBUTTON2, MB_DEFBUTTON3, MB_DEFBUTTON4 是指定的.</td></tr>
<tr><td>MB_DEFBUTTON2</td><td>0x00000100</td><td>第二个按钮为默认.</td></tr>
<tr><td>MB_DEFBUTTON3</td><td>0x00000200</td><td>第三个按钮为默认.</td></tr>
<tr><td>MB_DEFBUTTON4</td><td>0x00000300</td><td>第四个按钮为默认.</td></tr>
</table>
        <p>MessageBox() 功能被指定在<em>WinUser32.mqh</em>文件内， 这就是为什么这个文件程序必须通过<em>#include &lt;WinUser32.mqh&gt;</em>。不是所有的都可以在列表中列出。详细细节请参阅Win32 API。</p>
</content>
</text>
<text>
tag=constants_objects
caption=Object types
<keywords>
;Object types;OBJ_HLINE;OBJ_VLINE;OBJ_TREND;OBJ_TRENDBYANGLE;OBJ_REGRESSIONOBJ_CHANNEL;OBJ_STDDEVCHANNEL;OBJ_GANNLINE;OBJ_GANNFAN;OBJ_GANNGRID;OBJ_FIBOOBJ_FIBOTIMES;OBJ_FIBOFAN;OBJ_FIBOARC;OBJ_EXPANSION;OBJ_FIBOCHANNEL;OBJ_RECTANGLEOBJ_TRIANGLE;OBJ_ELLIPSE;OBJ_PITCHFORK;OBJ_CYCLES;OBJ_TEXT;OBJ_ARROW;OBJ_LABEL;
</keywords>
<content>
    <p>定单类型常数在<a href="help://objects_ObjectCreate">ObjectCreate()</a>,
<a href="help://objects_ObjectsDeleteAll">ObjectsDeleteAll()</a>
和 <a href="help://objects_ObjectType">ObjectType()</a> 函数中使用。
可以使以下任意值:<br/>
对象可能有1-3 个坐标。
</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums" width="95%">
        <tr><th width="15%">常数</th><th width="10%">值</th><th width="75%">描述</th></tr>
<tr><td>OBJ_VLINE</td><td>0</td><td>垂直线。使用第一坐标部分时间。</td></tr>
<tr><td>OBJ_HLINE</td><td>1</td><td>水平线。使用第一坐标部分价格。</td></tr>
<tr><td>OBJ_TREND</td><td>2</td><td>趋势线。 应用2个坐标。</td></tr>
<tr><td>OBJ_TRENDBYANGLE</td><td>3</td><td>趋势角度。应用1 个坐标。应用<a href="help://objects_ObjectSet">ObjectSet()</a> 功能设置线的角度。</td></tr>
<tr><td>OBJ_REGRESSION</td><td>4</td><td>回归。应用头两个坐标的时间部分。</td></tr>
<tr><td>OBJ_CHANNEL</td><td>5</td><td>通道。应用3个坐标。</td></tr>
<tr><td>OBJ_STDDEVCHANNEL</td><td>6</td><td>标准偏离通道。应用头两个坐标的时间部分。</td></tr>
<tr><td>OBJ_GANNLINE</td><td>7</td><td>甘氏线。应用 2个坐标，但第二个坐标的价格部分。</td></tr>
<tr><td>OBJ_GANNFAN</td><td>8</td><td>甘氏扇形线。应用 2个坐标，但第二个坐标的价格部分。</td></tr>
<tr><td>OBJ_GANNGRID</td><td>9</td><td>甘氏网格线。应用 2个坐标，但第二个坐标的价格部分</td></tr>
<tr><td>OBJ_FIBO</td><td>10</td><td>斐波纳契撤回。应用2个坐标。</td></tr>
<tr><td>OBJ_FIBOTIMES</td><td>11</td><td>斐波纳契时间周期线。应用2个坐标。</td></tr>
<tr><td>OBJ_FIBOFAN</td><td>12</td><td>斐波纳契扇形线。应用2个坐标。</td></tr>
<tr><td>OBJ_FIBOARC</td><td>13</td><td>斐波纳契弧线。应用2个坐标。</td></tr>
<tr><td>OBJ_EXPANSION</td><td>14</td><td>斐波纳契扩展。应用3个坐标。</td></tr>
<tr><td>OBJ_FIBOCHANNEL</td><td>15</td><td>斐波纳契通道。应用3个坐标。</td></tr>
<tr><td>OBJ_RECTANGLE</td><td>16</td><td>矩形。应用2个坐标。</td></tr>
<tr><td>OBJ_TRIANGLE</td><td>17</td><td>三角形。应用3个坐标。</td></tr>
<tr><td>OBJ_ELLIPSE</td><td>18</td><td>椭圆形。应用2个坐标。</td></tr>
<tr><td>OBJ_PITCHFORK</td><td>19</td><td>安德鲁分叉线。应用3个坐标。</td></tr>
<tr><td>OBJ_CYCLES</td><td>20</td><td>周期。应用2个坐标。</td></tr>
<tr><td>OBJ_TEXT</td><td>21</td><td>文本。应用1 坐标。</td></tr>
<tr><td>OBJ_ARROW</td><td>22</td><td>字行。应用1个坐标。</td></tr>
<tr><td>OBJ_LABEL</td><td>23</td><td>文本标签。应用1个坐标。</td></tr>
</table>


</content>
</text>
<text>
tag=constants_objects_properties
caption=Object properties
<keywords>
;Object properties;OBJPROP_TIME1;OBJPROP_PRICE1;OBJPROP_TIME2;OBJPROP_PRICE2;OBJPROP_TIME3;OBJPROP_PRICE3;OBJPROP_COLOR;OBJPROP_DEVIATIONOBJPROP_STYLE;OBJPROP_WIDTH;OBJPROP_BACK;OBJPROP_RAY;OBJPROP_ELLIPSE;OBJPROP_SCALE;OBJPROP_ANGLE;OBJPROP_TIMEFRAMESOBJPROP_ARROWCODE;OBJPROP_FONTSIZE;OBJPROP_CORNER;OBJPROP_XDISTANCE;OBJPROP_YDISTANCE;OBJPROP_FIBOLEVEL;OBJPROP_FIRSTLEVEL;
</keywords>
<content>
<p>对象值函数同<a href="help://objects_ObjectGet">ObjectGet()</a> 和  <a href="help://objects_ObjectSet">ObjectSet()</a> 功能一起使用。它可能是以下的任意值:</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums" width="95%">
        <tr>
          <th width="15%">常数</th>
          <th width="7%">值</th>
          <th width="8%">类型</th>
          <th width="70%">描述</th>
        </tr>
<tr><td>OBJPROP_TIME1</td><td>0</td><td>datetime</td><td>日期时间值设置为第一协调时间部分。</td></tr>
<tr><td>OBJPROP_PRICE1</td><td>1</td><td>double</td><td>双重值设置为第一协调价格部分。</td></tr>
<tr><td>OBJPROP_TIME2</td><td>2</td><td>datetime</td><td>日期时间值设置为第二协调时间部分。</td></tr>
<tr><td>OBJPROP_PRICE2</td><td>3</td><td>double</td><td>双重值设置为第二协调价格部分。</td></tr>
<tr><td>OBJPROP_TIME3</td><td>4</td><td>datetime</td><td>日期时间值设置为第三协调时间部分。</td></tr>
<tr><td>OBJPROP_PRICE3</td><td>5</td><td>double</td><td>双重值设置为第三协调价格部分。</td></tr>
<tr><td>OBJPROP_COLOR</td><td>6</td><td>color</td><td>颜色值设置对象颜色。</td></tr>
<tr><td>OBJPROP_STYLE</td><td>7</td><td>int</td><td>STYLE_SOLID, STYLE_DASH, STYLE_DOT, STYLE_DASHDOT, STYLE_DASHDOTDOT 常数中的一个设置为对象线风格。</td></tr>
<tr><td>OBJPROP_WIDTH</td><td>8</td><td>int</td><td>设置对象线宽度的整数值。可以从1到5。</td></tr>
<tr><td>OBJPROP_BACK</td><td>9</td><td>bool</td><td>设定对象背景的布尔值。</td></tr>
<tr><td>OBJPROP_RAY</td><td>10</td><td>bool</td><td> 	设定对象射线的布尔值。</td></tr>
<tr><td>OBJPROP_ELLIPSE</td><td>11</td><td>bool</td><td>设置椭圆状的弧形布尔值。</td></tr>
<tr><td>OBJPROP_SCALE</td><td>12</td><td>double</td><td>设置对象属性的双重值。</td></tr>
<tr><td>OBJPROP_ANGLE</td><td>13</td><td>double</td><td>在级别上设置对象属性的双重值。</td></tr>
<tr><td>OBJPROP_ARROWCODE</td><td>14</td><td>int</td><td>设置对象属性箭头代码的整数值和<a href="help://constants_arrows">箭头计数</a> 。</td></tr>
<tr><td>OBJPROP_TIMEFRAMES</td><td>15</td><td>int</td><td> 	设置对象属性的时间范围一个值或者<a href="help://constants_objects_visible">可见性对象常数</a> 的组合值。</td></tr>
<tr><td>OBJPROP_DEVIATION</td><td>16</td><td>double</td><td>为标准离差对象设定双重值的离差属性。</td></tr>
<tr><td>OBJPROP_FONTSIZE</td><td>100</td><td>int</td><td> 	对于对象文本字体大小设定整数值。</td></tr>
<tr><td>OBJPROP_CORNER</td><td>101</td><td>int</td><td>对标记对象设定整数值的固定装置角。必须是从0-3。</td></tr>
<tr><td>OBJPROP_XDISTANCE</td><td>102</td><td>int</td><td>在像点设定整数值固定装置X间隔对象。</td></tr>
<tr><td>OBJPROP_YDISTANCE</td><td>103</td><td>int</td><td>在像点设定整数值固定装置Y间隔对象。</td></tr>
<tr><td>OBJPROP_FIBOLEVELS</td><td>200</td><td>int</td><td>设置斐波纳契对象水平数为整数值。可以从0 到32 。</td></tr>
<tr><td>OBJPROP_LEVELCOLOR</td><td>201</td><td>color</td><td>设置对象水平颜色线的颜色值。</td></tr>
<tr><td>OBJPROP_LEVELSTYLE</td><td>202</td><td>int</td><td> 	STYLE_SOLID, STYLE_DASH, STYLE_DOT, STYLE_DASHDOT, STYLE_DASHDOTDOT 常数中的一个设置为对象线风格。</td></tr>
<tr><td>OBJPROP_LEVELWIDTH</td><td>203</td><td>int</td><td>设置对象线宽度的整数值。可以从1到5。</td></tr>
<tr><td>OBJPROP_FIRSTLEVEL+<i>n</i></td><td>210+n</td><td>int</td><td>斐波纳契水平函数是设置n的水平函数。可以是从0 到31 。</td></tr>
</table>
</content>
</text>
<text>
tag=constants_objects_visible
caption=Object visibility
<keywords>
;Object visibility;OBJ_PERIOD_M1;OBJ_PERIOD_M5;OBJ_PERIOD_M15;OBJ_PERIOD_M30;OBJ_PERIOD_H1;OBJ_PERIOD_H4OBJ_PERIOD_D1;OBJ_PERIOD_W1;OBJ_PERIOD_MN1;OBJ_ALL_PERIODS;
</keywords>
<content>
<p>时间范围将在货币对处显示。在<a href="help://objects_ObjectSet">ObjectSet()</a>应用函数中设置OBJPROP_TIMEFRAMES 属性。 
</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums" width="95%">
        <tr><th width="15%">常数</th><th width="10%">值</th><th width="75%">描述。</th></tr>
<tr><td>OBJ_PERIOD_M1</td><td>0x0001</td><td>对象只在1分钟图表中显示。</td></tr>
<tr><td>OBJ_PERIOD_M5</td><td>0x0002</td><td>对象只在5分钟图表中显示。。</td></tr>
<tr><td>OBJ_PERIOD_M15</td><td>0x0004</td><td>对象只在15分钟图表中显示。</td></tr>
<tr><td>OBJ_PERIOD_M30</td><td>0x0008</td><td>对象只在30分钟图表中显示。</td></tr>
<tr><td>OBJ_PERIOD_H1</td><td>0x0010</td><td>对象只在1小时图表中显示。</td></tr>
<tr><td>OBJ_PERIOD_H4</td><td>0x0020</td><td>对象只在4小时图表中显示。</td></tr>
<tr><td>OBJ_PERIOD_D1</td><td>0x0040</td><td>对象只在天图表中显示。</td></tr>
<tr><td>OBJ_PERIOD_W1</td><td>0x0080</td><td>对象只在星期图表中显示。</td></tr>
<tr><td>OBJ_PERIOD_MN1</td><td>0x0100</td><td>对象只在月图表中显示。</td></tr>
<tr><td>OBJ_ALL_PERIODS</td><td>0x01FF</td><td>对象在所有时间周期图表中显示。</td></tr>
<tr><td>NULL</td><td>0</td><td>对象在所有时间周期图表中显示。</td></tr>
<tr><td>EMPTY</td><td>-1</td><td>在所有时间周期图表中显示。</td></tr>
</table>
</content>
</text>
<text>
tag=constants_uninit
caption=Uninitialize reason codes
<keywords>
;Uninitialize reason codes;REASON_REMOVE;REASON_RECOMPILE;REASON_CHARTCHANGE;REASON_CHARTCLOSE;REASON_PARAMETERS;REASON_ACCOUNT;
</keywords>
<content>
    <p>使用<a href="help://check_UninitializeReason">UninitializeReason()</a> 函数返回初始化代码。可以是以下任意值:</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums" width="95%">
        <tr><th width="15%">常数</th><th width="10%">值</th><th width="75%">描述</th></tr>
<tr><td>&nbsp;</td><td>0</td><td>脚本独立执行完成</td></tr>
<tr><td>REASON_REMOVE</td><td>1</td><td>从图表中删除。</td></tr>
<tr><td>REASON_RECOMPILE</td><td>2</td><td>重新编译交易。</td></tr>
<tr><td>REASON_CHARTCHANGE</td><td>3</td><td>在图表上改变货币对和时间周期。</td></tr>
<tr><td>REASON_CHARTCLOSE</td><td>4</td><td>关闭图表</td></tr>
<tr><td>REASON_PARAMETERS</td><td>5</td><td>用户改变了输入参量</td></tr>
<tr><td>REASON_ACCOUNT</td><td>6</td><td>其他账户已激活</td></tr>
</table>

</content>
</text>
<text>
tag=constants_special
caption=Special constants
<keywords>
;Special constants;NULL;EMPTY_VALUE;CLR_NONE;EMPTY;
</keywords>
<content>
    <p>特别常数使用于指定参量和变量状态。
可以是以下任意值:</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums" width="95%">
        <tr><th width="15%">常数</th><th width="10%">值</th><th width="75%">描述</th></tr>
<tr><td>NULL</td><td>0</td><td>指示空状态的字行。</td>
</tr>
<tr><td>EMPTY</td><td>-1</td><td>指示空状态的参量。</td>
</tr>
<tr><td>EMPTY_值</td><td>0x7FFFFFFF</td><td>指示自定义空值。</td>
</tr>
<tr><td>CLR_NONE</td><td>0xFFFFFFFF</td><td>指示空状态的颜色。</td>
</tr>
<tr><td>WHOLE_ARRAY</td><td>0</td><td>应用数组功能。指示数组将被处理。</td>
</tr>
</table>

</content>
</text>
<text>
tag=constants_errors
caption=Error codes
<keywords>
;Error codes;ERR_NO_ERROR;ERR_NO_RESULT;ERR_COMMON_ERROR;ERR_INVALID_TRADE_PARAMETERS;ERR_SERVER_BUSYERR_OLD_VERSION;ERR_NO_CONNECTION;ERR_NOT_ENOUGH_RIGHTS;ERR_TOO_FREQUENT_REQUESTS;ERR_MALFUNCTIONAL_TRADEERR_ACCOUNT_DISABLED;ERR_INVALID_ACCOUNT;ERR_TRADE_TIMEOUT;ERR_INVALID_PRICE;ERR_INVALID_STOPSERR_INVALID_TRADE_VOLUME;ERR_MARKET_CLOSED;ERR_TRADE_DISABLED;ERR_NOT_ENOUGH_MONEY;ERR_PRICE_CHANGEDERR_OFF_QUOTES;ERR_BROKER_BUSY;ERR_REQUOTE;ERR_ORDER_LOCKED;ERR_LONG_POSITIONS_ONLY_ALLOWEDERR_TOO_MANY_REQUESTS;ERR_NO_MQLERROR;ERR_WRONG_FUNCTION_POINTER;ERR_ARRAY_INDEX_OUT_OF_RANGEERR_NO_MEMORY_FOR_FUNCTION_CALL_STACK;ERR_RECURSIVE_STACK_OVERFLOW;ERR_NOT_ENOUGH_STACK_FOR_PARAMETERERR_NO_MEMORY_FOR_PARAMETER_STRING;ERR_NO_MEMORY_FOR_TEMP_STRING;ERR_NOT_INITIALIZED_STRINGERR_NOT_INITIALIZED_ARRAYSTRING;ERR_NO_MEMORY_FOR_ARRAYSTRING;ERR_TOO_LONG_STRING;ERR_REMAINDER_FROM_ZERO_DIVIDEERR_ZERO_DIVIDE;ERR_UNKNOWN_COMMAND;ERR_WRONG_JUMP;ERR_NOT_INITIALIZED_ARRAY;ERR_DLL_CALLS_NOT_ALLOWEDERR_CANNOT_LOAD_LIBRARY;ERR_CANNOT_CALL_FUNCTION;ERR_EXTERNAL_EXPERT_CALLS_NOT_ALLOWEDERR_NOT_ENOUGH_MEMORY_FOR_RETURNED_STRING;ERR_SYSTEM_BUSY;ERR_INVALID_FUNCTION_PARAMETERS_COUNTERR_INVALID_FUNCTION_PARAMETER_VALUE;ERR_STRING_FUNCTION_INTERNAL_ERROR;ERR_SOME_ARRAY_ERRORERR_INCORRECT_SERIES_ARRAY_USING;ERR_CUSTOM_INDICATOR_ERROR;ERR_INCOMPATIBLE_ARRAYSERR_GLOBAL_VARIABLES_PROCESSING_ERROR;ERR_GLOBAL_VARIABLE_NOT_FOUND;ERR_FUNCTION_NOT_ALLOWED_IN_TESTING_MODEERR_FUNCTION_NOT_CONFIRMED;ERR_SEND_MAIL_ERROR;ERR_STRING_PARAMETER_EXPECTED;ERR_INTEGER_PARAMETER_EXPECTEDERR_DOUBLE_PARAMETER_EXPECTED;ERR_ARRAY_AS_PARAMETER_EXPECTED;ERR_END_OF_FILE;ERR_SOME_FILE_ERRORERR_WRONG_FILE_NAME;ERR_TOO_MANY_OPENED_FILES;ERR_CANNOT_OPEN_FILE;ERR_INCOMPATIBLE_ACCESS_TO_FILEERR_NO_ORDER_SELECTED;ERR_UNKNOWN_SYMBOL;ERR_INVALID_PRICE_PARAM;ERR_INVALID_TICKET;ERR_TRADE_NOT_ALLOWEDERR_LONGS__NOT_ALLOWED;ERR_SHORTS_NOT_ALLOWED;ERR_OBJECT_ALREADY_EXISTS;ERR_UNKNOWN_OBJECT_PROPERTYERR_OBJECT_DOES_NOT_EXIST;ERR_UNKNOWN_OBJECT_TYPE;ERR_NO_OBJECT_NAME;ERR_OBJECT_COORDINATES_ERRORERR_NO_SPECIFIED_SUBWINDOW;ERR_TRADE_MODIFY_DENIED;ERR_TRADE_CONTEXT_BUSY;ERR_TRADE_EXPIRATION_DENIEDERR_SOME_OBJECT_ERROR,ERR_TRADE_ERROR,;
</keywords>
<content>
    <p>此<a href="help://check_GetLastError">GetLastError()</a>函数返回代码。错误代码被指定在<b>stderror.mqh</b>文件里。
打印文本信息使用在<b>stdlib.mqh</b>文件中指定<i>错误描述()</i>函数。</p>
<pre class="docmql4">
#include &lt;stderror.mqh&gt;
#include &lt;stdlib.mqh&gt;
void SendMyMessage(string text)
  {
   int check;
   SendMail(&quot;some subject&quot;, text);
   check=GetLastError();
   if(check!=ERR_NO_ERROR) Print(&quot;Cannot send message, error: &quot;,Error描述(check));
  }
</pre><br/>
<p>从服务器返回的错误代码</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums" width="95%">
        <tr><th width="15%">常数</th><th width="10%">值</th><th width="75%">描述</th></tr>
<tr><td>ERR_NO_ERROR</td><td>0</td><td>没有错误返回。</td></tr>
<tr><td>ERR_NO_RESULT</td><td>1</td><td>没有错误返回但结果不明。</td></tr>
<tr><td>ERR_COMMON_ERROR</td><td>2</td><td>一般错误。</td></tr>
<tr><td>ERR_INVALID_TRADE_PARAMETERS</td><td>3</td><td>无效交易参量。</td></tr>
<tr><td>ERR_SERVER_BUSY</td><td>4</td><td>交易服务器繁忙。</td></tr>
<tr><td>ERR_OLD_VERSION</td><td>5</td><td>客户终端旧版本。</td></tr>
<tr><td>ERR_NO_CONNECTION</td><td>6</td><td>没有连接服务器。</td></tr>
<tr><td>ERR_NOT_ENOUGH_RIGHTS</td><td>7</td><td>没有权限。</td></tr>
<tr><td>ERR_TOO_FREQUENT_REQUESTS</td><td>8</td><td>请求过于频繁。</td></tr>
<tr><td>ERR_MALFUNCTIONAL_TRADE</td><td>9</td><td>交易运行故障。</td></tr>
<tr><td>ERR_ACCOUNT_DISABLED</td><td>64</td><td>账户禁止。</td></tr>
<tr><td>ERR_INVALID_ACCOUNT</td><td>65</td><td>无效账户</td></tr>
<tr><td>ERR_TRADE_TIMEOUT</td><td>128</td><td>交易超时。</td></tr>
<tr><td>ERR_INVALID_PRICE</td><td>129</td><td>无效价格。</td></tr>
<tr><td>ERR_INVALID_STOPS</td><td>130</td><td>无效停止。</td></tr>
<tr><td>ERR_INVALID_TRADE_VOLUME</td><td>131</td><td>无效交易量。</td></tr>
<tr><td>ERR_MARKET_CLOSED</td><td>132</td><td>市场关闭。</td></tr>
<tr><td>ERR_TRADE_DISABLED</td><td>133</td><td>交易被禁止。</td></tr>
<tr><td>ERR_NOT_ENOUGH_MONEY</td><td>134</td><td>资金不足。</td></tr>
<tr><td>ERR_PRICE_CHANGED</td><td>135</td><td>价格改变。</td></tr>
<tr><td>ERR_OFF_QUOTES</td><td>136</td><td>开价。</td></tr>
<tr><td>ERR_BROKER_BUSY</td><td>137</td><td>经纪繁忙。</td></tr>
<tr><td>ERR_REQUOTE</td><td>138</td><td>重新开价。</td></tr>
<tr><td>ERR_ORDER_LOCKED</td><td>139</td><td>定单被锁定。</td></tr>
<tr><td>ERR_LONG_POSITIONS_ONLY_ALLOWED</td><td>140</td><td>只允许看涨仓位。</td></tr>
<tr><td>ERR_TOO_MANY_REQUESTS</td><td>141</td><td>过多请求。</td></tr>
<tr><td>ERR_TRADE_MODIFY_DENIED</td><td>145</td><td>因为过于接近市场，修改否定。</td></tr>
<tr><td>ERR_TRADE_CONTEXT_BUSY</td><td>146</td><td>交易文本已满。</td></tr>
<tr><td>ERR_TRADE_EXPIRATION_DENIED</td><td>147</td><td>时间周期被经纪否定。</td></tr>
<tr><td>ERR_TRADE_TOO_MANY_ORDERS</td><td>148</td><td>开单和挂单总数已被经纪限定。</td></tr>
<tr><td>ERR_TRADE_HEDGE_PROHIBITED</td><td>149</td><td>当对冲备拒绝时,打开相对于现有的一个单置。</td></tr>
<tr><td>ERR_TRADE_PROHIBITED_BY_FIFO</td><td>150</td><td>把为反FIFO规定的单子平掉。</td></tr>
</table><br/>
<p>MQL4 运行错误代码</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums" width="95%">
        <tr><th width="15%">常数</th><th width="10%">值</th><th width="75%">描述</th></tr>
<tr><td>ERR_NO_MQLERROR</td><td>4000</td><td>没有错误。</td></tr>
<tr><td>ERR_WRONG_FUNCTION_POINTER</td><td>4001</td><td>错误函数指示。</td></tr>
<tr><td>ERR_ARRAY_INDEX_OUT_OF_RANGE</td><td>4002</td><td>数组索引超出范围。</td></tr>
<tr><td>ERR_NO_MEMORY_FOR_CALL_STACK</td><td>4003</td><td>对于调用堆栈储存器函数没有足够内存。</td></tr>
<tr><td>ERR_RECURSIVE_STACK_OVERFLOW</td><td>4004</td><td>循环堆栈储存器溢出。</td></tr>
<tr><td>ERR_NOT_ENOUGH_STACK_FOR_PARAM</td><td>4005</td><td>对于堆栈储存器参量没有内存。</td></tr>
<tr><td>ERR_NO_MEMORY_FOR_PARAM_STRING</td><td>4006</td><td>对于字行参量没有足够内存。</td></tr>
<tr><td>ERR_NO_MEMORY_FOR_TEMP_STRING</td><td>4007</td><td>对于字行没有足够内存。</td></tr>
<tr><td>ERR_NOT_INITIALIZED_STRING</td><td>4008</td><td>没有初始字行。</td></tr>
<tr><td>ERR_NOT_INITIALIZED_ARRAYSTRING</td><td>4009</td><td>在数组中没有初始字串符。</td></tr>
<tr><td>ERR_NO_MEMORY_FOR_ARRAYSTRING</td><td>4010</td><td>对于数组没有内存。</td></tr>
<tr><td>ERR_TOO_LONG_STRING</td><td>4011</td><td>字行过长。</td></tr>
<tr><td>ERR_REMAINDER_FROM_ZERO_DIVIDE</td><td>4012</td><td>余数划分为零。</td></tr>
<tr><td>ERR_ZERO_DIVIDE</td><td>4013</td><td>零划分。</td></tr>
<tr><td>ERR_UNKNOWN_COMMAND</td><td>4014</td><td>不明命令。</td></tr>
<tr><td>ERR_WRONG_JUMP</td><td>4015</td><td>错误转换(没有常规错误)。</td></tr>
<tr><td>ERR_NOT_INITIALIZED_ARRAY</td><td>4016</td><td>没有初始数组。</td></tr>
<tr><td>ERR_DLL_CALLS_NOT_ALLOWED</td><td>4017</td><td>禁止调用DLL 。</td></tr>
<tr><td>ERR_CANNOT_LOAD_LIBRARY</td><td>4018</td><td>数据库不能下载。</td></tr>
<tr><td>ERR_CANNOT_CALL_FUNCTION</td><td>4019</td><td>不能调用函数。</td></tr>
<tr><td>ERR_EXTERNAL_CALLS_NOT_ALLOWED</td><td>4020</td><td>禁止调用智能交易函数。</td></tr>
<tr><td>ERR_NO_MEMORY_FOR_RETURNED_STR</td><td>4021</td><td>对于来自函数的字行没有足够内存。</td></tr>
<tr><td>ERR_SYSTEM_BUSY</td><td>4022</td><td>系统繁忙 (没有常规错误)。</td></tr>
<tr><td>ERR_INVALID_FUNCTION_PARAMSCNT</td><td>4050</td><td>无效计数参量函数。</td></tr>
<tr><td>ERR_INVALID_FUNCTION_PARAM值</td><td>4051</td><td>无效参量值函数。</td></tr>
<tr><td>ERR_STRING_FUNCTION_INTERNAL</td><td>4052</td><td>字行函数内部错误。</td></tr>
<tr><td>ERR_SOME_ARRAY_ERROR</td><td>4053</td><td>一些数组错误。</td></tr>
<tr><td>ERR_INCORRECT_SERIESARRAY_USING</td><td>4054</td><td>应用不正确数组。</td></tr>
<tr><td>ERR_CUSTOM_INDICATOR_ERROR</td><td>4055</td><td>自定义指标错误。</td></tr>
<tr><td>ERR_INCOMPATIBLE_ARRAYS</td><td>4056</td><td>不协调数组。</td></tr>
<tr><td>ERR_GLOBAL_VARIABLES_PROCESSING</td><td>4057</td><td>整体变量过程错误。</td></tr>
<tr><td>ERR_GLOBAL_VARIABLE_NOT_FOUND</td><td>4058</td><td>整体变量未找到。</td></tr>
<tr><td>ERR_FUNC_NOT_ALLOWED_IN_TESTING</td><td>4059</td><td>测试模式函数禁止。</td></tr>
<tr><td>ERR_FUNCTION_NOT_CONFIRMED</td><td>4060</td><td>没有确认函数</td></tr>
<tr><td>ERR_SEND_MAIL_ERROR</td><td>4061</td><td>发送邮件错误。</td></tr>
<tr><td>ERR_STRING_PARAMETER_EXPECTED</td><td>4062</td><td>字行预计参量。</td></tr>
<tr><td>ERR_INTEGER_PARAMETER_EXPECTED</td><td>4063</td><td>整数预计参量。</td></tr>
<tr><td>ERR_DOUBLE_PARAMETER_EXPECTED</td><td>4064</td><td>双预计参量。</td></tr>
<tr><td>ERR_ARRAY_AS_PARAMETER_EXPECTED</td><td>4065</td><td>数组作为预计参量。</td></tr>
<tr><td>ERR_HISTORY_WILL_UPDATED</td><td>4066</td><td>刷新状态请求历史数据。</td></tr>
<tr><td>ERR_TRADE_ERROR</td><td>4067</td><td>交易函数错误。</td></tr>
<tr><td>ERR_END_OF_FILE</td><td>4099</td><td>文件结束。</td></tr>
<tr><td>ERR_SOME_FILE_ERROR</td><td>4100</td><td>一些文件错误。</td></tr>
<tr><td>ERR_WRONG_FILE_NAME</td><td>4101</td><td>错误文件名称。</td></tr>
<tr><td>ERR_TOO_MANY_OPENED_FILES</td><td>4102</td><td>打开文件过多。</td></tr>
<tr><td>ERR_CANNOT_OPEN_FILE</td><td>4103</td><td>不能打开文件。</td></tr>
<tr><td>ERR_INCOMPATIBLE_FILEACCESS</td><td>4104</td><td>不协调文件。</td></tr>
<tr><td>ERR_NO_ORDER_SELECTED</td><td>4105</td><td>没有选择定单。</td></tr>
<tr><td>ERR_UNKNOWN_SYMBOL</td><td>4106</td><td>不明货币对。</td></tr>
<tr><td>ERR_INVALID_PRICE_PARAM</td><td>4107</td><td>无效价格。</td></tr>
<tr><td>ERR_INVALID_TICKET</td><td>4108</td><td>无效定单编码。</td></tr>
<tr><td>ERR_TRADE_NOT_ALLOWED</td><td>4109</td><td>不允许交易。</td></tr>
<tr><td>ERR_LONGS_NOT_ALLOWED</td><td>4110</td><td>不允许长期。</td></tr>
<tr><td>ERR_SHORTS_NOT_ALLOWED</td><td>4111</td><td>不允许短期。</td></tr>
<tr><td>ERR_OBJECT_ALREADY_EXISTS</td><td>4200</td><td>定单已经存在。</td></tr>
<tr><td>ERR_UNKNOWN_OBJECT_PROPERTY</td><td>4201</td><td>不明定单属性。</td></tr>
<tr><td>ERR_OBJECT_DOES_NOT_EXIST</td><td>4202</td><td>定单不存在。</td></tr>
<tr><td>ERR_UNKNOWN_OBJECT_TYPE</td><td>4203</td><td>不明定单类型。</td></tr>
<tr><td>ERR_NO_OBJECT_NAME</td><td>4204</td><td>没有定单名称。</td></tr>
<tr><td>ERR_OBJECT_COORDINATES_ERROR</td><td>4205</td><td>定单坐标错误。</td></tr>
<tr><td>ERR_NO_SPECIFIED_SUBWINDOW</td><td>4206</td><td>没有指定子窗口。</td></tr>
<tr><td>ERR_SOME_OBJECT_ERROR</td><td>4207</td><td>定单一些函数错误。</td></tr>
<tr><td>ERR_NOTIFICATION_SEND_ERROR</td><td>4250</td><td>错误设定发送通知到队列中</td></tr>
<tr><td>ERR_NOTIFICATION_WRONG_PARAMETER</td><td>4251</td><td>无效参量- 空字符串传递到SendNotification()函数</td></tr>
<tr><td>ERR_NOTIFICATION_WRONG_SETTINGS</td><td>4252</td><td>无效设置发送通知(未指定ID或未启用通知)</td></tr>
<tr><td>ERR_NOTIFICATION_TOO_FREQUENT</td><td>4253</td><td>通知发送过于频繁</td></tr>
</table>

</content>
</text>
</group>
<group>
tag=predefined_variables
caption=Predefined variables
<keywords>
;Predefined variables;
</keywords>
<content>
        对于每个执行的MQL4程序,一定数量的变量设定可以轻松应对图表中的价格状态：智能交易，脚本或者是客户指标。.<br/><br/>
   资料应用到可变量的模型中来。<br/><br/>
    可以由预定义的变量分开处理。 这些数据会在开启后应用
    <a href="help://windows_RefreshRates">RefreshRates()</a>函数更新。

</content>
<variable>
tag=predefined_variables_ask
caption=Ask
<keywords>
;Ask;
</keywords>
type=double
<content>
     对于当前货币对的最新卖价格。使用<a href="help://windows_RefreshRates">RefreshRates()</a>函数更新。<br/>
      <b>参见</b> <a href="help://common_MarketInfo">MarketInfo()</a>.
</content>
<example>
  if(iRSI(NULL,0,14,PRICE_CLOSE,0)&lt;25)
    {
     OrderSend(Symbol(),OP_BUY,Lots,Ask,3,Bid-StopLoss*Point,Ask+TakeProfit*Point,
               &quot;My order #2&quot;,3,D'2005.10.10 12:30',Red);
     return;
    }
</example>
</variable>
<variable>
tag=predefined_variables_bars
caption=Bars
<keywords>
;Bars;
</keywords>
type=int
<content>
    返回图表中的柱数。<br/>
      <b>参见</b> <a href="help://series_iBars">iBars()</a>.
</content>
<example>
  int counter=1;
  for(int i=1; i&lt;=Bars; i++)
    {
     Print(关闭[i-1]);
    }
</example>
</variable>
<variable>
tag=predefined_variables_bid
caption=Bid
<keywords>
;Bid;
</keywords>
type=double
<content>
     对于当前货币对的最新买价格。使用<a href="help://windows_RefreshRates">RefreshRates()</a>函数更新。<br/>
      <b>参见</b> <a href="help://common_MarketInfo">MarketInfo()</a>.
</content>
<example>
  if(iRSI(NULL,0,14,PRICE_CLOSE,0)&gt;75)
    {
     OrderSend(&quot;EURUSD&quot;,OP_SELL,Lots,Bid,3,Ask+StopLoss*Point,Bid-TakeProfit*Point,
               &quot;My Order #2&quot;,3,D'2005.10.10 12:30',Red);
     return(0);
    }
</example>
</variable>
<variable>
tag=predefined_variables_close
caption=Close[]
<keywords>
;Close[];Close;
</keywords>
type=double
<content>
系列数组包含当前图表每个柱的收盘价格。<br/><br/>
系列数组元素被索引入倒序的定单，即从最后一个到第一个。.
当前最后一个柱在数组中的索引为0。图表中的第一个柱的索引为<a href="help://predefined_variables_Bars">Bars</a>-1.<br/><br/>
<b>参见</b> <a href="help://series_iClose">iClose()</a>.
</content>
<example>
  int handle = FileOpen(&quot;file.csv&quot;, FILE_CSV|FILE_WRITE, &quot;;&quot;);
  if(handle&gt;0)
    {
     // 表格栏标题记录
     FileWrite(handle, &quot;Time;Open;High;Low;Close;Volume&quot;);
     // 数据记录
     for(int i=0; i&lt;Bars; i++)
       FileWrite(handle, Time[i], Open[i], High[i], Low[i], Close[i], Volume[i]);
     FileClose(handle);
    }
</example>
</variable>
<variable>
tag=predefined_variables_digits
caption=Digits
<keywords>
;Digits;
</keywords>
type=int
<content>
    返回当前货币对的汇率小数位<br/>
      <b>参见</b> <a href="help://common_MarketInfo">MarketInfo()</a>.
</content>
<example>
Print(DoubleToStr(Close[0], 小数位));
</example>
</variable>
<variable>
tag=predefined_variables_high
caption=High[]
<keywords>
;High[];High;
</keywords>
type=double
<content>
系列数组包含当前图表每个柱的最高价格。<br/><br/>
系列数组元素被索引入倒序的定单，即从最后一个到第一个。.
当前最后一个柱在数组中的索引为0。图表中的第一个柱的索引为 <a href="help://predefined_variables_Bars">Bars</a>-1.<br/><br/>
<b>参见</b> <a href="help://series_iHigh">iHigh()</a>.
</content>
<example>
//---- 最大值
   i=Bars-KPeriod;
   if(counted_bars>KPeriod) i=Bars-counted_bars-1;
   while(i>=0)
     {
      double max=-1000000;
      k = i + KPeriod-1;
      while(k>=i)
        {
         price=High[k];
         if(max&lt;price) max=price;
         k--;
        }
      HighesBuffer[i]=max;
      i--;
     }
//----
</example>
</variable>
<variable>
tag=predefined_variables_low
caption=Low[]
<keywords>
;Low[];Low;
</keywords>
type=double
<content>
系列数组包含当前图表每个柱的最低价格。<br/><br/>
系列数组元素被索引入倒序的定单，即从最后一个到第一个。.
当前最后一个柱在数组中的索引为0。图表中的第一个柱的索引为 <a href="help://predefined_variables_Bars">Bars</a>-1.<br/><br/>
<b>参见</b> <a href="help://series_iLow">iLow()</a>.
</content>
<example>
//---- 最小值
   i=Bars-KPeriod;
   if(counted_bars>KPeriod) i=Bars-counted_bars-1;
   while(i>=0)
     {
      double min=1000000;
      k = i + KPeriod-1;
      while(k>=i)
        {
         price=Low[k];
         if(min>price) min=price;
         k--;
        }
      LowesBuffer[i]=min;
      i--;
     }
//----
</example>
</variable>
<variable>
tag=predefined_variables_open
caption=Open[]
<keywords>
;Open[];Open;
</keywords>
type=double
<content>
系列数组包含当前图表每个柱的开盘价格。<br/><br/>
系列数组元素被索引入倒序的定单，即从最后一个到第一个。.
当前最后一个柱在数组中的索引为0。图表中的第一个柱的索引为<a href="help://predefined_variables_Bars">Bars</a>-1.<br/><br/>
<b>参见</b> <a href="help://series_iOpen">iOpen()</a>.
</content>
<example>
   i = Bars - counted_bars - 1;
   while(i>=0)
     {
      double high  = High[i];
      double low   = Low[i];
      double open  = Open[i];
      double close = Close[i];
      AccumulationBuffer[i] = (close-low) - (high-close);
      if(AccumulationBuffer[i] != 0)
        {
         double diff = high - low;
         if(0==diff)
            AccumulationBuffer[i] = 0;
         else
           {
            AccumulationBuffer[i] /= diff;
            AccumulationBuffer[i] *= Volume[i];
           }
        }
      if(i&lt;Bars-1) AccumulationBuffer[i] += AccumulationBuffer[i+1];
      i--;
     }
</example>
</variable>
<variable>
tag=predefined_variables_point
caption=Point
<keywords>
;Point;
</keywords>
type=double
<content>
     返回当前图表的点值<br/>
      <b>参见</b> <a href="help://common_MarketInfo">MarketInfo()</a>.
</content>
<example>
OrderSend(Symbol(),OP_BUY,Lots,Ask,3,0,Ask+TakeProfit*Point);
</example>
</variable>
<variable>
tag=predefined_variables_time
caption=Time[]
<keywords>
;Time[];Time;
</keywords>
type=datetime
<content>
系列数组包含当前图表的每个柱开盘时间。数据像日期时间一样呈现时间，从1979年1月1日零点开始以秒计算。
<br/><br/>
系列数组元素被索引入倒序的定单，即从最后一个到第一个。
当前最后一个柱在数组中的索引为0。图表中的第一个柱的索引为 <a href="help://predefined_variables_Bars">Bars</a>-1.<br/><br/>
<b>参见</b> <a href="help://series_iTime">iTime()</a>.
</content>
<example>
   for(i=Bars-2; i>=0; i--)
     {
      if(High[i+1] > LastHigh) LastHigh = High[i+1];
      if(Low[i+1] &lt; LastLow)   LastLow  = Low[i+1];
      //----
      if(TimeDay(Time[i]) != TimeDay(Time[i+1]))
        {
         P = (LastHigh + LastLow + Close[i+1])/3;
         R1 = P*2 - LastLow;
         S1 = P*2 - LastHigh;
         R2 = P + LastHigh - LastLow;
         S2 = P - (LastHigh - LastLow);
         R3 = P*2 + LastHigh - LastLow*2;
         S3 = P*2 - (LastHigh*2 - LastLow);
         LastLow  = Open[i];
         LastHigh = Open[i];
        }
      //----
      PBuffer[i]  = P;
      S1Buffer[i] = S1;
      R1Buffer[i] = R1;
      S2Buffer[i] = S2;
      R2Buffer[i] = R2;
      S3Buffer[i] = S3;
      R3Buffer[i] = R3;
     }
</example>
</variable>
<variable>
tag=predefined_variables_volume
caption=Volume[]
<keywords>
;Volume[];Volume;
</keywords>
type=double
<content>
系列数组包含当前图表每个柱替克成交量。<br/><br/>
系列数组元素被索引入倒序的定单，即从最后一个到第一个。.
当前最后一个柱在数组中的索引为0。图表中的第一个柱的索引为 <a href="help://predefined_variables_Bars">Bars</a>-1.<br/><br/>
<b>参见</b> <a href="help://series_iVolume">iVolume()</a>.
</content>
<example>
      if(i==0 &amp;&amp; time0&lt;i_time+periodseconds)
        {
         d_volume += Volume[0];
         if(Low[0]&lt;d_low)   d_low = Low[0];
         if(High[0]>d_high) d_high = High[0];
         d_close = Close[0];
        }
      last_fpos = FileTell(ExtHandle);
      last_volume = Volume[i];
      FileWriteInteger(ExtHandle, i_time, LONG_VALUE);
      FileWriteDouble(ExtHandle, d_open, DOUBLE_VALUE);
      FileWriteDouble(ExtHandle, d_low, DOUBLE_VALUE);
      FileWriteDouble(ExtHandle, d_high, DOUBLE_VALUE);
      FileWriteDouble(ExtHandle, d_close, DOUBLE_VALUE);
      FileWriteDouble(ExtHandle, d_volume, DOUBLE_VALUE);
</example>
</variable>
</group>
<group>
tag=runtime
caption=Program Run
<keywords>
;Program Run;
</keywords>
<content>
       使MQL4程序运行，必须进行编写("编写" 按钮或F5) 。编写过程中不允许出现任何错误。
              必须在<em>terminal_dir\experts</em>、 <em>terminal_dir\experts\indicators</em>,
              或 <em>terminal_dir\experts\scripts</em>, 有相同名称和引伸EX4的文件中创建。这样可以开启这个文件。<br ="/">
              <br ="/">
             智能交易,客户指标和脚本的相应图表(Drag'n'Drop 技术)需要从客户端内的导航窗口打开.
             MQL4程序只有在客户端开启的基础上运行. <br ="/">
              <br ="/">
             使智能交易停止运行,必须从图表使用的菜单中删除它。"智能交易开启"的状态栏将会直接影响智能交易的运行.<br ="/">
              <br ="/">
              使客户指标停止运行,必须将它从图表中删除.<br ="/">
              <br ="/">
              客户指标和智能交易在图表中的管理直到被删除.关于附属在客户指标和智能交易的信息将储存于客户端内.
              脚本在完成执行一次任务后或者当前图表发生改变/关闭时,再或者客户端中断,脚本被自动删除.相应的附属信息不被保存.<br ="/">
              <br ="/">
              在同一个图表内,智能交易,脚本和更多数量的指标可以同时运行.

</content>
<text>
tag=runtime_start
caption=Program Run
<keywords>
;Program Run;init;deinit;start;
</keywords>
<content>
        <p>
       程序在附加图表之后，它开始应用init()作用运行。在客户端开始和历史数据加载，图表周期改变，由MetaEditor编译程序，
       智能和客户指标的输入数据设定后，附加到图表上的智能交易和客户指标将会运行。
        在账户发生改变后交易将会初始化。<br ="/"><br ="/">
        
        每一个附加到图表上的交易必须在deinit()的作用协助下工作。 deinit()作用运行在客户端内停止，在图表中关闭
        在商品或图表周期改变之前，成功重新编译程序，改变输入数据或改变账户。
        在deinit()函数执行中,您可以使用
        <a href="help://check_UninitializeReason">UninitializeReason()</a>函数查看原因.deinit()函数必须在2.5 秒内执行.
        如果函数没有在指定的时间段内执行,它将强制完成.脚本除外,它的运行不取决于任何外界的命令.
        如果脚本工作时间过长, 可以应用外部命令结束运行
        (从图表的菜单中删除脚本,在原有的图表上添加新的脚本,改变图表的商品或图表周期).在这种情况下,deinit()函数限制在2.5秒内.<br ="/"><br ="/">
        
        新报价格的输入,start()函数将会添加到智能交易和客户指标上执行.当新报价格进入时如果start()函数没有开启运行,新的报价格会被忽略. function launched at the preceding quote was running when a new quote came,
         随后,只有当新报价格进入后start()函数才会运行.
        对于客户指标,由于新报价格的输入当前图表商品或期限发生改变, start()函数将会开启重新计算.在交易属性窗口打开时start()函数
        停止运行.迟些在交易执行中不会打开.<br ="/"><br ="/">
        
        从图表中拆卸程序, 改变商品或图表周期,改变账户,关闭图表,客户端的改变将会中断程序的执行.如果start()函数在给出停止命令的时刻执行 , 时间限制在2.5 秒.
        程序能够尝试关闭
         <a href="help://check_IsStopped">IsStopped()</a>函数并结束.<br ="/"><br ="/">
        
        脚本的执行不取决于报价格的输入.在商品或图表周期发生改变时,脚本将停止运行并且中断从客户端上下载.<br ="/">
       脚本和交易的运行在自己的界面.客户指标则是在主界面上运行.
        如果客户指标中出现 <a href="help://indicators_iCustom">iCustom()</a> 函数,
       这个指标的运行是在程序中显示的.
        资料库函数在程序界面.</p>
</content>
</text>
<text>
tag=runtime_imports
caption=Imported functions call
<keywords>
;Imported functions call;init;deinit;start;
</keywords>
<content>
            <p>
         <a href="help://basis_preprosessor_import">输入函数</a>在mql4 程序中执行，即所谓的约束应用。这就意味着，直到输入函数被应用，相应的模板(ex4 or dll)将不会加载。 MQL4和DLL 资料在模板的命令下被调用。<br/><br/>
        
这里不推荐使用模板被加载的</em> 全名Drive:\Directory\FileName.Ext</em> 。 MQL4 资料是</em> 从terminal_dir\experts\libraries</em> 文件夹中下载。如果资料中未找到，将会接受来自</em> terminal_dir\experts</em> 文件夹的下载。 <br/><br/>
        资料系统(DLLs)按照以下规则运行。如果资料已经被下载 (从其他智能交易。例如，从其他相同时间开启的客户端下载)，资料下在以满。会按照以下规则命令执行:<br/>
        1. <em>terminal_dir\experts\libraries</em>目录 。<br/>
        2. 从<em>terminal_dir</em>客户端被开启的目录。<br/>
        3. 当前目录。<br/>
        4.<em>windows_dir\SYSTEM32</em> 的目录系统 (或是对于<em>windows_dir\SYSTEM</em> for Win98)。<br/>
        5. 在 <em>windows_dir</em>执行系统中安装的目录。<br/>
        6. 录中列出的PATH 环境系统变量。<br/><br/>
       如果DLL 应用另一个DLL 运行，在后者省缺的情况下前者不会加载。<br/><br/>
       与资料系统不同，客户资料(MQL4)加载是对于每个分开模板，独立地从模板上加载。举例来说，ex4 模板可以从lib1.ex4 和 lib2.ex4 资料中调用。反过来lib1.ex4 资料可以从lib2.ex4 资料中调用函数。在这种情况下，需要复制一份 lib1.ex4 资料和两分lib2.ex4资料，所有来自相同caller.ex4 模板的资料。
<br/><br/>
        从DLL转入到mql4程序的输入函数必须提供接受Windows API函数。 提供这样公约，关键词 __stdcall对于微软（r）公司的编译器，在编写的C 或 C++ 语言中源代码中使用。上述公约有以下特点:<br/>
         - 呼叫函数(这种情况下，是mql4 程序) 必须"参见"(来自DLL输入函数)适应参量；<br/>
         - 呼叫函数(这种情况下，是mql4 程序) 在反向命令中放置参量等等，从左到右；它是在读输入函数参量通过的命令；<br/>
         - 参量根据他们的价格值通过，除了一些直接的界限(存在一些界限)；<br/>
         - 参量通过，输入函数本身将会变大。<br/><br/>
        在描述输入<a href="help://basis_functions">函数</a> 模型时，基本不使用参量默认值。因为所有的默认值必须直接通过输入函数。<br/><br/>
         如果调用输入函数失败(智能交易设置不允许DLL 输入，或相关的资料由于一些原因不能下载)，智能交易会停止运行并在“停止运行”处提出相关信息。另外，智能交易只有在重新初始化之后才会开启。智能交易的初始化由于需要重新编译或开启属性可以按确定键。
        </p>

</content>
</text>
<text>
tag=runtime_errors
caption=Runtime errors
<keywords>
;Runtime errors;ERR_NO_ERROR;ERR_NO_RESULT;ERR_COMMON_ERROR;ERR_INVALID_TRADE_PARAMETERS;ERR_SERVER_BUSYERR_OLD_VERSION;ERR_NO_CONNECTION;ERR_NOT_ENOUGH_RIGHTS;ERR_TOO_FREQUENT_REQUESTS;ERR_MALFUNCTIONAL_TRADEERR_ACCOUNT_DISABLED;ERR_INVALID_ACCOUNT;ERR_TRADE_TIMEOUT;ERR_INVALID_PRICE;ERR_INVALID_STOPSERR_INVALID_TRADE_VOLUME;ERR_MARKET_CLOSED;ERR_TRADE_DISABLED;ERR_NOT_ENOUGH_MONEY;ERR_PRICE_CHANGEDERR_OFF_QUOTES;ERR_BROKER_BUSY;ERR_REQUOTE;ERR_ORDER_LOCKED;ERR_LONG_POSITIONS_ONLY_ALLOWEDERR_TOO_MANY_REQUESTS;ERR_NO_MQLERROR;ERR_WRONG_FUNCTION_POINTER;ERR_ARRAY_INDEX_OUT_OF_RANGEERR_NO_MEMORY_FOR_FUNCTION_CALL_STACK;ERR_RECURSIVE_STACK_OVERFLOW;ERR_NOT_ENOUGH_STACK_FOR_PARAMETERERR_NO_MEMORY_FOR_PARAMETER_STRING;ERR_NO_MEMORY_FOR_TEMP_STRING;ERR_NOT_INITIALIZED_STRINGERR_NOT_INITIALIZED_ARRAYSTRING;ERR_NO_MEMORY_FOR_ARRAYSTRING;ERR_TOO_LONG_STRING;ERR_REMAINDER_FROM_ZERO_DIVIDEERR_ZERO_DIVIDE;ERR_UNKNOWN_COMMAND;ERR_WRONG_JUMP;ERR_NOT_INITIALIZED_ARRAY;ERR_DLL_CALLS_NOT_ALLOWEDERR_CANNOT_LOAD_LIBRARY;ERR_CANNOT_CALL_FUNCTION;ERR_EXTERNAL_EXPERT_CALLS_NOT_ALLOWEDERR_NOT_ENOUGH_MEMORY_FOR_RETURNED_STRING;ERR_SYSTEM_BUSY;ERR_INVALID_FUNCTION_PARAMETERS_COUNTERR_INVALID_FUNCTION_PARAMETER_VALUE;ERR_STRING_FUNCTION_INTERNAL_ERROR;ERR_SOME_ARRAY_ERRORERR_INCORRECT_SERIES_ARRAY_USING;ERR_CUSTOM_INDICATOR_ERROR;ERR_INCOMPATIBLE_ARRAYSERR_GLOBAL_VARIABLES_PROCESSING_ERROR;ERR_GLOBAL_VARIABLE_NOT_FOUND;ERR_FUNCTION_NOT_ALLOWED_IN_TESTING_MODEERR_FUNCTION_NOT_CONFIRMED;ERR_SEND_MAIL_ERROR;ERR_STRING_PARAMETER_EXPECTED;ERR_INTEGER_PARAMETER_EXPECTEDERR_DOUBLE_PARAMETER_EXPECTED;ERR_ARRAY_AS_PARAMETER_EXPECTED;ERR_END_OF_FILE;ERR_SOME_FILE_ERRORERR_WRONG_FILE_NAME;ERR_TOO_MANY_OPENED_FILES;ERR_CANNOT_OPEN_FILE;ERR_INCOMPATIBLE_ACCESS_TO_FILEERR_NO_ORDER_SELECTED;ERR_UNKNOWN_SYMBOL;ERR_INVALID_PRICE_PARAM;ERR_INVALID_TICKET;ERR_TRADE_NOT_ALLOWEDERR_LONGS__NOT_ALLOWED;ERR_SHORTS_NOT_ALLOWED;ERR_OBJECT_ALREADY_EXISTS;ERR_UNKNOWN_OBJECT_PROPERTYERR_OBJECT_DOES_NOT_EXIST;ERR_UNKNOWN_OBJECT_TYPE;ERR_NO_OBJECT_NAME;ERR_OBJECT_COORDINATES_ERRORERR_NO_SPECIFIED_SUBWINDOW;ERR_TRADE_MODIFY_DENIED;ERR_TRADE_CONTEXT_BUSY;ERR_TRADE_EXPIRATION_DENIEDERR_SOME_OBJECT_ERROR,ERR_TRADE_ERROR,;
</keywords>
<content>
            <p>
         如果是由于一个关键错误停止了程序的运行，这个错误代码可以在下次开启时使用 GetLastError () 函数。 在未开启之前，错误变量不会归零。 在客户终端执行子系统时，其发生在mql4程序执行错误代码可以储存 。
对于每一个mql4程序执行，存在一个特殊的<i>last_error</i>。 
在init函数运行之前，<i>last_error</i>变量必须归零。如果在计算过程中或内建函数时发生错误，last_error变量会给出相应的<a href="help://constants_errors">错误代码</a>。
存储在这个变量中的值可以应用 <a href="help://check_GetLastError">GetLastError</a> 函数。
        另外，<i>last_error</i> 变量将归零。
        </p>
        <p>
         存在一些智能或客户指标执行直接导致的关键错误， 在智能或客户指标未被重新初始化后不会开启使用。:</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums" width="95%">
        <tr><th width="15%">常数</th><th width="10%">值</th><th width="75%">描述</th></tr>
        <tr><td>ERR_WRONG_FUNCTION_POINTER</td><td>4001</td><td>在调用内部函数时，发现错误指示物</td></tr>
        <tr><td>ERR_NO_MEMORY_FOR_CALL_STACK</td><td>4003</td><td>在调用内部函数时，可能出现储存器</td></tr>
        <tr><td>ERR_RECURSIVE_STACK_OVERFLOW</td><td>4004</td><td>在调用循环函数时，数据存储器溢出</td></tr>
        <tr><td>ERR_NO_MEMORY_FOR_PARAM_STRING</td><td>4006</td><td>在调用内部函数时，可能作为功参量被分配</td></tr>
        <tr><td>ERR_NO_MEMORY_FOR_TEMP_STRING</td><td>4007</td><td>不能分配临时缓冲字符</td></tr>
        <tr><td>ERR_NO_MEMORY_FOR_ARRAYSTRING</td><td>4010</td><td>在转让时，数组不能重新记忆</td></tr>
        <tr><td>ERR_TOO_LONG_STRING</td><td>4011</td><td>在转让时，字串符过长可能导致被送到服务器缓冲（不能再次发送到服务器缓冲处理）</td></tr>
        <tr><td>ERR_REMAINDER_FROM_ZERO_DIVIDE</td><td>4012</td><td>用剩余的部分除以0</td></tr>
        <tr><td>ERR_ZERO_DIVIDE</td><td>4013</td><td>除以 0</td></tr>
        <tr><td>ERR_UNKNOWN_COMMAND</td><td>4014</td><td>无效指令</td></tr>
        </table>
        <p>
        如果在错误生成时程序停止工作，这些错误代码可能被下一个开启的程序读取。应用 <a href="help://check_GetLastError">GetLastError()</a>函数。 在程序开始之前<i>last_error</i>变量不会归零。
        </p>
        <p><br/>
         存在一些相关 <a href="help://runtime_imports">输入函数调用</a> 的错误会立即停止智能交易或客户指标的起初执行直至被初始化。
        </p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums" width="95%">
        <tr><th width="15%">常数</th><th width="10%">值</th><th width="75%">描述</th></tr>
        <tr><td>ERR_CANNOT_LOAD_LIBRARY</td><td>4018</td><td>输入数据时，生成dll 或 ex4 l错误</td></tr>
        <tr><td>ERR_CANNOT_CALL_FUNCTION</td><td>4019</td><td>输入数据时, dll或 ex4 不包含调用功能</td></tr>
        <tr><td>ERR_DLL_CALLS_NOT_ALLOWED</td><td>4017</td><td>输入数据时，dll 数据禁止</td></tr>
        <tr><td>ERR_EXTERNAL_CALLS_NOT_ALLOWED</td><td>4020</td><td>输入数据时，ex4 数据禁止</td></tr>
        </table>
        <p><br/>
       其他错误，不中断程序执行。</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums" width="95%">
        <tr><th width="15%">常数</th><th width="10%">值</th><th width="75%">描述</th></tr>
        <tr><td>ERR_ARRAY_INDEX_OUT_OF_RANGE</td><td>4002</td><td>企图获取数组项目，其中一些是出于数组范围</td></tr>
        <tr><td>ERR_NOT_INITIALIZED_STRING</td><td>4008</td><td>没有初始化字符;没有值被分配到字符作为运算中的表达</td></tr>
        <tr><td>ERR_NOT_INITIALIZED_ARRAYSTRING</td><td>4009</td><td>没有初始化字符;没有值被分配到字符作为运算中的表达</td></tr>
        <tr><td>ERR_NO_MEMORY_FOR_RETURNED_STR</td><td>4021</td><td>不可能重新记忆字符</td></tr>
        </table>
        <p><br/>
        The ERR_NO_MQLERROR (4000) 代码不会生成。 
        <p>
        有一些错误可能只是由于软件或硬件故障。如果一些错误文本反复出现，应与开发商联络。</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums" width="95%">
        <tr><th width="15%">常数</th><th width="10%">值</th><th width="75%">描述</th></tr>
        <tr><td>ERR_WRONG_FUNCTION_POINTER</td><td>4001</td><td>在调用一个内部函数时，发现错误指示物</td></tr>
        <tr><td>ERR_UNKNOWN_COMMAND</td><td>4014</td><td>无效指令</td></tr>
        <tr><td>ERR_NOT_INITIALIZED_ARRAY</td><td>4016</td><td>数组没有初始化</td></tr>
        <tr><td>ERR_INVALID_FUNCTION_PARAMSCNT</td><td>4050</td><td>无效参量</td></tr>
        <tr><td>ERR_STRING_FUNCTION_INTERNAL</td><td>4052</td><td>字串符函数内部错误</td></tr>
        <tr><td>ERR_TRADE_ERROR</td><td>4067</td><td>交易函数内部错误</td></tr>
        <tr><td>ERR_SOME_OBJECT_ERROR</td><td>4207</td><td>窗体函数内部错误</td></tr>
        </table>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums" width="95%">
          <tr>
            <th width="15%">函数</th>
            <th width="85%">错误代码</th>
          </tr>
          <tr>
            <td><a href="help://account_AccountFreeMarginCheck">AccountFreeMarginCheck</a></td>
            <td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_INTEGER_PARAMETER_EXPECTED (4063), ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_UNKNOWN_SYMBOL (4106), ERR_NOT_ENOUGH_MONEY (134)</td>
          </tr>
          <tr>
            <td><a href="help://trading_OrderSend">OrderSend</a></td>
            <td>ERR_CUSTOM_INDICATOR_ERROR (4055), ERR_STRING_PARAMETER_EXPECTED (4062), ERR_INTEGER_PARAMETER_EXPECTED (4063), ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_INVALID_PRICE_PARAM (4107), ERR_UNKNOWN_SYMBOL (4106), ERR_TRADE_NOT_ALLOWED (4109), ERR_LONGS_NOT_ALLOWED (4110), ERR_SHORTS_NOT_ALLOWED (4111), <a href="help://trading_errors">用交易服务器返回源代码</a></td>
          </tr>
          <tr>
            <td><a href="help://trading_OrderClose">OrderClose</a></td>
            <td>ERR_CUSTOM_INDICATOR_ERROR (4055), ERR_INTEGER_PARAMETER_EXPECTED (4063), ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_INVALID_PRICE_PARAM (4107), ERR_INVALID_TICKET (4108), ERR_UNKNOWN_SYMBOL (4106), ERR_TRADE_NOT_ALLOWED (4109), <a href="help://trading_errors">用交易服务器返回源代码</a></td>
          </tr>
          <tr>
            <td><a href="help://trading_OrderCloseBy">OrderCloseBy</a></td>
            <td>ERR_CUSTOM_INDICATOR_ERROR (4055), ERR_INTEGER_PARAMETER_EXPECTED (4063), ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_INVALID_TICKET (4108), ERR_UNKNOWN_SYMBOL (4106), ERR_TRADE_NOT_ALLOWED (4109), <a href="help://trading_errors">用交易服务器返回源代码</a></td>
          </tr>
          <tr>
            <td><a href="help://trading_OrderDelete">OrderDelete</a></td>
            <td>ERR_CUSTOM_INDICATOR_ERROR (4055), ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_INVALID_TICKET (4108), ERR_UNKNOWN_SYMBOL (4106), ERR_TRADE_NOT_ALLOWED (4109), <a href="help://trading_errors">用交易服务器返回源代码</a></td>
          </tr>
          <tr>
            <td><a href="help://trading_OrderModify">OrderModify</a></td>
            <td>ERR_CUSTOM_INDICATOR_ERROR (4055), ERR_INTEGER_PARAMETER_EXPECTED (4063), ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_INVALID_PRICE_PARAM (4107), ERR_INVALID_TICKET (4108), ERR_UNKNOWN_SYMBOL (4106), ERR_TRADE_NOT_ALLOWED (4109), <a href="help://trading_errors">用交易服务器返回源代码</a></td>
          </tr>
          <tr>
            <td><a href="help://check_GetLastError">GetLastError</a></td>
            <td>ERR_NO_ERROR (0)</td>
          </tr>
        </table>
        <p><br/>
          <i>last_error</i>变量的一些功能的价格值改变只能产生一种错误。
        
        <table cellspacing="0" cellpadding="4" border="0" class="docenums" width="95%">
        <tr><th width="15%">函数</th><th width="85%">错误代码</th></tr>
        <tr><td><a href="help://array_ArrayBsearch">ArrayBsearch</a></td><td>ERR_ARRAY_AS_PARAMETER_EXPECTED (4065), ERR_SOME_ARRAY_ERROR (4053), ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://array_ArrayCopy">ArrayCopy</a></td><td>ERR_ARRAY_AS_PARAMETER_EXPECTED (4065), ERR_SOME_ARRAY_ERROR (4053), ERR_INCOMPATIBLE_ARRAYS (4056), ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://array_ArrayCopyRates">ArrayCopyRates</a></td><td>ERR_ARRAY_AS_PARAMETER_EXPECTED (4065), ERR_SOME_ARRAY_ERROR (4053), ERR_INCOMPATIBLE_ARRAYS (4056), ERR_STRING_PARAMETER_EXPECTED (4062),</td></tr>
        <tr><td><a href="help://array_ArrayCopySeries">ArrayCopySeries</a></td><td>ERR_ARRAY_AS_PARAMETER_EXPECTED (4065), ERR_SOME_ARRAY_ERROR (4053), ERR_INCORRECT_SERIESARRAY_USING (4054), ERR_INCOMPATIBLE_ARRAYS (4056), ERR_STRING_PARAMETER_EXPECTED (4062), ERR_HISTORY_WILL_UPDATED (4066), ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://array_ArrayDimension">ArrayDimension</a></td><td>ERR_ARRAY_AS_PARAMETER_EXPECTED (4065), ERR_SOME_ARRAY_ERROR (4053)</td></tr>
        <tr><td><a href="help://array_ArrayGetAsSeries">ArrayGetAsSeries</a></td><td>ERR_ARRAY_AS_PARAMETER_EXPECTED (4065), ERR_SOME_ARRAY_ERROR (4053)</td></tr>
        <tr><td><a href="help://array_ArrayInitialize">ArrayInitialize</a></td><td>ERR_ARRAY_AS_PARAMETER_EXPECTED (4065), ERR_SOME_ARRAY_ERROR (4053), ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://array_ArrayIsSeries">ArrayIsSeries</a></td><td>ERR_ARRAY_AS_PARAMETER_EXPECTED (4065), ERR_SOME_ARRAY_ERROR (4053)</td></tr>
        <tr><td><a href="help://array_ArrayMaximum">ArrayMaximum</a></td><td>ERR_ARRAY_AS_PARAMETER_EXPECTED (4065), ERR_SOME_ARRAY_ERROR (4053), ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://array_ArrayMinimum">ArrayMinimum</a></td><td>ERR_ARRAY_AS_PARAMETER_EXPECTED (4065), ERR_SOME_ARRAY_ERROR (4053), ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://array_ArrayRange">ArrayRange</a></td><td>ERR_ARRAY_AS_PARAMETER_EXPECTED (4065), ERR_SOME_ARRAY_ERROR (4053), ERR_INTEGER_PARAMETER_EXPECTED (4063), ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://array_ArrayResize">ArrayResize</a></td><td>ERR_ARRAY_AS_PARAMETER_EXPECTED (4065), ERR_SOME_ARRAY_ERROR (4053), ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://array_ArraySetAsSeries">ArraySetAsSeries</a></td><td>ERR_ARRAY_AS_PARAMETER_EXPECTED (4065), ERR_SOME_ARRAY_ERROR (4053)</td></tr>
        <tr><td><a href="help://array_ArraySize">ArraySize</a></td><td>ERR_ARRAY_AS_PARAMETER_EXPECTED (4065), ERR_SOME_ARRAY_ERROR (4053)</td></tr>
        <tr><td><a href="help://array_ArraySort">ArraySort</a></td><td>ERR_ARRAY_AS_PARAMETER_EXPECTED (4065), ERR_SOME_ARRAY_ERROR (4053), ERR_INCORRECT_SERIESARRAY_USING (4054), ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://files_FileClose">FileClose</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://files_FileDelete">FileDelete</a></td><td>ERR_WRONG_FILE_NAME (4101), ERR_SOME_FILE_ERROR (4100)</td></tr>
        <tr><td><a href="help://files_FileFlush">FileFlush</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://files_FileIsEnding">FileIsEnding</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://files_FileIsLineEnding">FileIsLineEnding</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://files_FileOpen">FileOpen</a></td><td>ERR_TOO_MANY_OPENED_FILES (4102), ERR_WRONG_FILE_NAME (4101), ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_SOME_FILE_ERROR (4100), ERR_CANNOT_OPEN_FILE (4103)</td></tr>
        <tr><td><a href="help://files_FileOpenHistory">FileOpenHistory</a></td><td>ERR_TOO_MANY_OPENED_FILES (4102), ERR_WRONG_FILE_NAME (4101), ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_SOME_FILE_ERROR (4100), ERR_CANNOT_OPEN_FILE (4103)</td></tr>
        <tr><td><a href="help://files_FileReadArray">FileReadArray</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_INCOMPATIBLE_FILEACCESS (4104), ERR_SOME_ARRAY_ERROR (4053), ERR_SOME_FILE_ERROR (4100), ERR_END_OF_FILE (4099)</td></tr>
        <tr><td><a href="help://files_FileReadDouble">FileReadDouble</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_INCOMPATIBLE_FILEACCESS (4104), ERR_END_OF_FILE (4099)</td></tr>
        <tr><td><a href="help://files_FileReadInteger">FileReadInteger</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_INCOMPATIBLE_FILEACCESS (4104), ERR_END_OF_FILE (4099)</td></tr>
        <tr><td><a href="help://files_FileReadNumber">FileReadNumber</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_INCOMPATIBLE_FILEACCESS (4104), ERR_SOME_FILE_ERROR (4100), ERR_END_OF_FILE (4099)</td></tr>
        <tr><td><a href="help://files_FileReadString">FileReadString</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_INCOMPATIBLE_FILEACCESS (4104), ERR_SOME_FILE_ERROR (4100), ERR_TOO_LONG_STRING (4011), ERR_END_OF_FILE (4099)</td></tr>
        <tr><td><a href="help://files_FileSeek">FileSeek</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://files_FileSize">FileSize</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://files_FileTell">FileTell</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://files_FileWrite">FileWrite</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_SOME_FILE_ERROR (4100)</td></tr>
        <tr><td><a href="help://files_FileWriteDouble">FileWriteDouble</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_INCOMPATIBLE_FILEACCESS (4104), ERR_SOME_FILE_ERROR (4100)</td></tr>
        <tr><td><a href="help://files_FileWriteInteger">FileWriteInteger</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_INCOMPATIBLE_FILEACCESS (4104), ERR_SOME_FILE_ERROR (4100)</td></tr>
        <tr><td><a href="help://files_FileWriteString">FileWriteString</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_INCOMPATIBLE_FILEACCESS (4104), ERR_SOME_FILE_ERROR (4100), ERR_STRING_PARAMETER_EXPECTED (4062)</td></tr>
        <tr><td><a href="help://files_FileWriteArray">FileWriteArray</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_INCOMPATIBLE_FILEACCESS (4104), ERR_SOME_FILE_ERROR (4100),</td></tr>
        <tr><td><a href="help://globals_GlobalVariableCheck">GlobalVariableCheck</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062)</td></tr>
        <tr><td><a href="help://globals_GlobalVariableDel">GlobalVariableDel</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_GLOBAL_VARIABLES_PROCESSING (4057)</td></tr>
        <tr><td><a href="help://globals_GlobalVariableGet">GlobalVariableGet</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_GLOBAL_VARIABLE_NOT_FOUND (4058)</td></tr>
        <tr><td><a href="help://globals_GlobalVariablesDeleteAll">GlobalVariablesDeleteAll</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_GLOBAL_VARIABLES_PROCESSING (4057)</td></tr>
        <tr><td><a href="help://globals_GlobalVariableSet">GlobalVariableSet</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_GLOBAL_VARIABLES_PROCESSING (4057), ERR_GLOBAL_VARIABLE_NOT_FOUND (4058)</td></tr>
        <tr><td><a href="help://globals_GlobalVariableSetOnCondition">GlobalVariableSetOnCondition</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_GLOBAL_VARIABLE_NOT_FOUND (4058)</td></tr>
        <tr><td><a href="help://indicators_iCustom">iCustom</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://indicators">technical indicators</a>, <a href="help://series">series access functions</a></td><td>ERR_HISTORY_WILL_UPDATED (4066)</td></tr>
        <tr><td><a href="help://indicators">technical indicators OnArray</a></td><td>ERR_ARRAY_AS_PARAMETER_EXPECTED (4065), ERR_SOME_ARRAY_ERROR (4053)</td></tr>
        <tr><td><a href="help://customind_IndicatorBuffers">IndicatorBuffers</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://customind_IndicatorDigits">IndicatorDigits</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://customind_IndicatorShortName">IndicatorShortName</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://common_MarketInfo">MarketInfo</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_FUNC_NOT_ALLOWED_IN_TESTING (4059), ERR_UNKNOWN_SYMBOL (4106), ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://math_MathArccos">MathArccos</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://math_MathArcsin">MathArcsin</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://math_MathMod">MathMod</a></td><td>ERR_ZERO_DIVIDE (4013)</td></tr>
        <tr><td><a href="help://math_MathSqrt">MathSqrt</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://common_MessageBox">MessageBox</a></td><td>ERR_FUNC_NOT_ALLOWED_IN_TESTING (4059), ERR_CUSTOM_INDICATOR_ERROR (4055), ERR_STRING_PARAMETER_EXPECTED (4062)</td></tr>
        <tr><td><a href="help://objects_ObjectCreate">ObjectCreate</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_NO_OBJECT_NAME (4204), ERR_UNKNOWN_OBJECT_TYPE (4203), ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_OBJECT_ALREADY_EXISTS (4200), ERR_NO_SPECIFIED_SUBWINDOW (4206)</td></tr>
        <tr><td><a href="help://objects_ObjectDelete">ObjectDelete</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_NO_OBJECT_NAME (4204), ERR_OBJECT_DOES_NOT_EXIST (4202)</td></tr>
        <tr><td><a href="help://objects_ObjectDescription">ObjectDescription</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_NO_OBJECT_NAME (4204), ERR_OBJECT_DOES_NOT_EXIST (4202)</td></tr>
        <tr><td><a href="help://objects_ObjectFind">ObjectFind</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_NO_OBJECT_NAME (4204)</td></tr>
        <tr><td><a href="help://objects_ObjectGet">ObjectGet</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_NO_OBJECT_NAME (4204), ERR_OBJECT_DOES_NOT_EXIST (4202), ERR_UNKNOWN_OBJECT_PROPERTY (4201)</td></tr>
        <tr><td><a href="help://objects_ObjectGetFiboDescription">ObjectGetFiboDescription</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_NO_OBJECT_NAME (4204), ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_OBJECT_DOES_NOT_EXIST (4202), ERR_UNKNOWN_OBJECT_TYPE (4203), ERR_UNKNOWN_OBJECT_PROPERTY (4201)</td></tr>
        <tr><td><a href="help://objects_ObjectGetShiftByValue">ObjectGetShiftByValue</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_NO_OBJECT_NAME (4204), ERR_OBJECT_DOES_NOT_EXIST (4202), ERR_OBJECT_COORDINATES_ERROR (4205)</td></tr>
        <tr><td><a href="help://objects_ObjectGetValueByShift">ObjectGetValueByShift</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_NO_OBJECT_NAME (4204), ERR_OBJECT_DOES_NOT_EXIST (4202), ERR_OBJECT_COORDINATES_ERROR (4205)</td></tr>
        <tr><td><a href="help://objects_ObjectMove">ObjectMove</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_NO_OBJECT_NAME (4204), ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_OBJECT_DOES_NOT_EXIST (4202)</td></tr>
        <tr><td><a href="help://objects_ObjectName">ObjectName</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_ARRAY_INDEX_OUT_OF_RANGE (4002)</td></tr>
        <tr><td><a href="help://objects_ObjectSet">ObjectSet</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_NO_OBJECT_NAME (4204), ERR_OBJECT_DOES_NOT_EXIST (4202), ERR_UNKNOWN_OBJECT_PROPERTY (4201)</td></tr>
        <tr><td><a href="help://objects_ObjectSetText">ObjectSetText</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_NO_OBJECT_NAME (4204), ERR_OBJECT_DOES_NOT_EXIST (4202)</td></tr>
        <tr><td><a href="help://objects_ObjectSetFiboDescription">ObjectSetFiboDescription</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_NO_OBJECT_NAME (4204), ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_STRING_PARAMETER_EXPECTED (4062), ERR_OBJECT_DOES_NOT_EXIST (4202), ERR_UNKNOWN_OBJECT_TYPE (4203), ERR_UNKNOWN_OBJECT_PROPERTY (4201)</td></tr>
        <tr><td><a href="help://objects_ObjectType">ObjectType</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_NO_OBJECT_NAME (4204), ERR_OBJECT_DOES_NOT_EXIST (4202)</td></tr>
        <tr><td><a href="help://trading_OrderClosePrice">OrderClosePrice</a></td><td>ERR_NO_ORDER_SELECTED (4105)</td></tr>
        <tr><td><a href="help://trading_OrderCloseTime">OrderCloseTime</a></td><td>ERR_NO_ORDER_SELECTED (4105)</td></tr>
        <tr><td><a href="help://trading_OrderComment">OrderComment</a></td><td>ERR_NO_ORDER_SELECTED (4105)</td></tr>
        <tr><td><a href="help://trading_OrderCommission">OrderCommission</a></td><td>ERR_NO_ORDER_SELECTED (4105)</td></tr>
        <tr><td><a href="help://trading_OrderExpiration">OrderExpiration</a></td><td>ERR_NO_ORDER_SELECTED (4105)</td></tr>
        <tr><td><a href="help://trading_OrderLots">OrderLots</a></td><td>ERR_NO_ORDER_SELECTED (4105)</td></tr>
        <tr><td><a href="help://trading_OrderMagicNumber">OrderMagicNumber</a></td><td>ERR_NO_ORDER_SELECTED (4105)</td></tr>
        <tr><td><a href="help://trading_OrderOpenPrice">OrderOpenPrice</a></td><td>ERR_NO_ORDER_SELECTED (4105)</td></tr>
        <tr><td><a href="help://trading_OrderOpenTime">OrderOpenTime</a></td><td>ERR_NO_ORDER_SELECTED (4105)</td></tr>
        <tr><td><a href="help://trading_OrderPrint">OrderPrint</a></td><td>ERR_NO_ORDER_SELECTED (4105)</td></tr>
        <tr><td><a href="help://trading_OrderProfit">OrderProfit</a></td><td>ERR_NO_ORDER_SELECTED (4105)</td></tr>
        <tr><td><a href="help://trading_OrderStopLoss">OrderStopLoss</a></td><td>ERR_NO_ORDER_SELECTED (4105)</td></tr>
        <tr><td><a href="help://trading_OrderSwap">OrderSwap</a></td><td>ERR_NO_ORDER_SELECTED (4105)</td></tr>
        <tr><td><a href="help://trading_OrderSymbol">OrderSymbol</a></td><td>ERR_NO_ORDER_SELECTED (4105)</td></tr>
        <tr><td><a href="help://trading_OrderTakeProfit">OrderTakeProfit</a></td><td>ERR_NO_ORDER_SELECTED (4105)</td></tr>
        <tr><td><a href="help://trading_OrderTicket">OrderTicket</a></td><td>ERR_NO_ORDER_SELECTED (4105)</td></tr>
        <tr><td><a href="help://trading_OrderType">OrderType</a></td><td>ERR_NO_ORDER_SELECTED (4105)</td></tr>
        <tr><td><a href="help://common_PlaySound">PlaySound</a></td><td>ERR_WRONG_FILE_NAME (4101)</td></tr>
        <tr><td><a href="help://common_SendFTP">SendFTP</a></td><td>ERR_FUNC_NOT_ALLOWED_IN_TESTING (4059), ERR_CUSTOM_INDICATOR_ERROR (4055), ERR_STRING_PARAMETER_EXPECTED (4062)</td></tr>
        <tr><td><a href="help://common_SendMail">SendMail</a></td><td>ERR_FUNC_NOT_ALLOWED_IN_TESTING (4059), ERR_STRING_PARAMETER_EXPECTED (4062), ERR_FUNCTION_NOT_CONFIRMED (4060), ERR_SEND_MAIL_ERROR (4061)</td></tr>
		<tr><td><a href="help://common_SendNotification">SendNotification</a></td><td>ERR_FUNC_NOT_ALLOWED_IN_TESTING (4059), ERR_STRING_PARAMETER_EXPECTED (4062), ERR_NOTIFICATION_SEND_ERROR (4250), ERR_NOTIFICATION_WRONG_PARAMETER (4251), ERR_NOTIFICATION_WRONG_SETTINGS (4252), ERR_NOTIFICATION_TOO_FREQUENT (4253)</td></tr>
        <tr><td><a href="help://customind_SetIndexArrow">SetIndexArrow</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://customind_SetIndexBuffer">SetIndexBuffer</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_INCORRECT_SERIESARRAY_USING (4054), ERR_INCOMPATIBLE_ARRAYS (4056)</td></tr>
        <tr><td><a href="help://customind_SetIndexDrawBegin">SetIndexDrawBegin</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://customind_SetIndexEmptyValue">SetIndexEmptyValue</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://customind_SetIndexLabel">SetIndexLabel</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_STRING_PARAMETER_EXPECTED (4062)</td></tr>
        <tr><td><a href="help://customind_SetIndexShift">SetIndexShift</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://customind_SetIndexStyle">SetIndexStyle</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://customind_SetLevelValue">SetLevelValue</a></td><td>ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        <tr><td><a href="help://common_Sleep">Sleep</a></td><td>ERR_CUSTOM_INDICATOR_ERROR (4055)</td></tr>
        <tr><td><a href="help://strings_StringFind">StringFind</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062)</td></tr>
        <tr><td><a href="help://strings_StringGetChar">StringGetChar</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_NOT_INITIALIZED_STRING (4008), ERR_ARRAY_INDEX_OUT_OF_RANGE (4002)</td></tr>
        <tr><td><a href="help://strings_StringLen">StringLen</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062)</td></tr>
        <tr><td><a href="help://strings_StringSetChar">StringSetChar</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_INVALID_FUNCTION_PARAMVALUE (4051), ERR_NOT_INITIALIZED_STRING (4008), ERR_TOO_LONG_STRING (4011), ERR_ARRAY_INDEX_OUT_OF_RANGE (4002)</td></tr>
        <tr><td><a href="help://strings_StringSubstr">StringSubstr</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062), ERR_TOO_LONG_STRING (4011)</td></tr>
        <tr><td><a href="help://strings_StringTrimLeft">StringTrimLeft</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062)</td></tr>
        <tr><td><a href="help://strings_StringTrimRight">StringTrimRight</a></td><td>ERR_STRING_PARAMETER_EXPECTED (4062)</td></tr>
        <tr><td><a href="help://windows_WindowIsVisible">WindowIsVisible</a></td><td>ERR_FUNC_NOT_ALLOWED_IN_TESTING (4059)</td></tr>
        <tr><td><a href="help://windows_WindowFind">WindowFind</a></td><td>ERR_FUNC_NOT_ALLOWED_IN_TESTING (4059), ERR_STRING_PARAMETER_EXPECTED (4062), ERR_NOT_INITIALIZED_STRING (4008)</td></tr>
        <tr><td><a href="help://windows_WindowHandle">WindowHandle</a></td><td>ERR_FUNC_NOT_ALLOWED_IN_TESTING (4059), ERR_STRING_PARAMETER_EXPECTED (4062), ERR_NOT_INITIALIZED_STRING (4008)</td></tr>
        <tr><td><a href="help://windows_WindowScreenShot">WindowScreenShot</a></td><td>ERR_WRONG_FILE_NAME (4101), ERR_INVALID_FUNCTION_PARAMVALUE (4051)</td></tr>
        </table>
        <p><br/>
         其他函数在<i>last_error</i> 可变物价格值下不会改变。<br/>
         <a href="help://account_AccountBalance">AccountBalance</a>,
         <a href="help://account_AccountCompany">AccountCompany</a>,
         <a href="help://account_AccountCredit">AccountCredit</a>,
         <a href="help://account_AccountCurrency">AccountCurrency</a>,
         <a href="help://account_AccountEquity">AccountEquity</a>,
         <a href="help://account_AccountFreeMargin">AccountFreeMargin</a>,
         <a href="help://account_AccountLeverage">AccountLeverage</a>,
         <a href="help://account_AccountMargin">AccountMargin</a>,
         <a href="help://account_AccountName">AccountName</a>,
         <a href="help://account_AccountNumber">AccountNumber</a>,
         <a href="help://account_AccountProfit">AccountProfit</a>,
         <a href="help://account_AccountServer">AccountServer</a>,
         <a href="help://common_Alert">Alert</a>,
         <a href="help://convert_CharToStr">CharToStr</a>,
         <a href="help://common_Comment">Comment</a>,
         <a href="help://dateandtime_Day">Day</a>,
         <a href="help://dateandtime_DayOfWeek">DayOfWeek</a>,
         <a href="help://dateandtime_DayOfYear">DayOfYear</a>,
         <a href="help://convert_DoubleToStr">DoubleToStr</a>,
         <a href="help://common_GetTickCount">GetTickCount</a>,
         <a href="help://windows_HideTestIndicators">HideTestIndicators</a>,
         <a href="help://dateandtime_Hour">Hour</a>,
         <a href="help://customind_IndicatorCounted">IndicatorCounted</a>,
         <a href="help://check_IsConnected">IsConnected</a>,
         <a href="help://check_IsDemo">IsDemo</a>,
         <a href="help://check_IsDllsAllowed">IsDllsAllowed</a>,
         <a href="help://check_IsExpertEnabled">IsExpertEnabled</a>,
         <a href="help://check_IsLibrariesAllowed">IsLibrariesAllowed</a>,
         <a href="help://check_IsOptimization">IsOptimization</a>,
         <a href="help://check_IsStopped">IsStopped</a>,
         <a href="help://check_IsTesting">IsTesting</a>,
         <a href="help://check_IsTradeAllowed">IsTradeAllowed</a>,
         <a href="help://check_IsTradeContextBusy">IsTradeContextBusy</a>,
         <a href="help://check_IsVisualMode">IsVisualMode</a>,
         <a href="help://math_MathAbs">MathAbs</a>,
         <a href="help://math_MathArctan">MathArctan</a>,
         <a href="help://math_MathCeil">MathCeil</a>,
         <a href="help://math_MathCos">MathCos</a>,
         <a href="help://math_MathExp">MathExp</a>,
         <a href="help://math_MathFloor">MathFloor</a>,
         <a href="help://math_MathLog">MathLog</a>,
         <a href="help://math_MathMax">MathMax</a>,
         <a href="help://math_MathMin">MathMin</a>,
         <a href="help://math_MathPow">MathPow</a>,
         <a href="help://math_MathRand">MathRand</a>,
         <a href="help://math_MathRound">MathRound</a>,
         <a href="help://math_MathSin">MathSin</a>,
         <a href="help://math_MathSrand">MathSrand</a>,
         <a href="help://math_MathTan">MathTan</a>,
         <a href="help://dateandtime_Minute">Minute</a>,
         <a href="help://dateandtime_Month">Month</a>,
         <a href="help://convert_NormalizeDouble">NormalizeDouble</a>,
         <a href="help://objects_ObjectsDeleteAll">ObjectsDeleteAll</a>,
         <a href="help://objects_ObjectsTotal">ObjectsTotal</a>,
         <a href="help://trading_OrderSelect">OrderSelect</a>,
         <a href="help://trading_OrdersHistoryTotal">OrdersHistoryTotal</a>,
         <a href="help://windows_Period">Period</a>,
         <a href="help://common_Print">Print</a>,
         <a href="help://windows_RefreshRates">RefreshRates</a>,
         <a href="help://dateandtime_Seconds">Seconds</a>,
         <a href="help://customind_SetLevelStyle">SetLevelStyle</a>,
         <a href="help://strings_StringConcatenate">StringConcatenate</a>,
         <a href="help://convert_StrToTime">StrToTime</a>,
         <a href="help://convert_StrToDouble">StrToDouble</a>,
         <a href="help://windows_Symbol">Symbol</a>,
         <a href="help://terminal_TerminalCompany">TerminalCompany</a>,
         <a href="help://terminal_TerminalName">TerminalName</a>,
         <a href="help://terminal_TerminalPath">TerminalPath</a>,
         <a href="help://dateandtime_TimeCurrent">TimeCurrent</a>,
         <a href="help://dateandtime_TimeDay">TimeDay</a>,
         <a href="help://dateandtime_TimeDayOfWeek">TimeDayOfWeek</a>,
         <a href="help://dateandtime_TimeDayOfYear">TimeDayOfYear</a>,
         <a href="help://dateandtime_TimeHour">TimeHour</a>,
         <a href="help://dateandtime_TimeLocal">TimeLocal</a>,
         <a href="help://dateandtime_TimeMinute">TimeMinute</a>,
         <a href="help://dateandtime_TimeMonth">TimeMonth</a>,
         <a href="help://dateandtime_TimeSeconds">TimeSeconds</a>,
         <a href="help://convert_TimeToStr">TimeToStr</a>,
         <a href="help://dateandtime_TimeYear">TimeYear</a>,
         <a href="help://check_UninitializeReason">UninitializeReason</a>,
         <a href="help://windows_WindowBarsPerChart">WindowBarsPerChart</a>,
         <a href="help://windows_WindowFirstVisibleBar">WindowFirstVisibleBar</a>,
         <a href="help://windows_WindowPriceOnDropped">WindowPriceOnDropped</a>,
         <a href="help://windows_WindowRedraw">WindowRedraw</a>,
         <a href="help://windows_WindowTimeOnDropped">WindowTimeOnDropped</a>,
         <a href="help://windows_WindowsTotal">WindowsTotal</a>,
         <a href="help://windows_WindowOnDropped">WindowOnDropped</a>,
         <a href="help://windows_WindowXOnDropped">WindowXOnDropped</a>,
         <a href="help://windows_WindowYOnDropped">WindowYOnDropped</a>,
         <a href="help://dateandtime_Year">Year</a>
        </p>

</content>
</text>
</group>
<group>
tag=account
caption=Account information
<keywords>
;Account information;
</keywords>
<content>
        激活账户信息的一组函数。

</content>
<function>
tag=account_AccountBalance
caption=AccountBalance()
type=double
<keywords>
;AccountBalance();AccountBalance();AccountBalance;
</keywords>
<content>
     返回账户余额(账户中相当数量的价格值金钱) .
</content>
<example>
Print(&quot;账户余额= &quot;,AccountBalance());
</example>
</function>
<function>
tag=account_AccountCredit
caption=AccountCredit()
type=double
<keywords>
;AccountCredit();AccountCredit;
</keywords>
<content>
     返回账户信用点数. 
</content>
<example>
Print(&quot;账户点数 &quot;, AccountCredit());
</example>
</function>
<function>
tag=account_AccountCompany
caption=AccountCompany()
type=string
<keywords>
;AccountCompany();
</keywords>
<content>
    返回账户公司名。 
</content>
<example>
Print(&quot;账户公司名&quot;, AccountCompany());
</example>
</function>
<function>
tag=account_AccountCurrency
caption=AccountCurrency()
type=string
<keywords>
;AccountCurrency();AccountCurrency;
</keywords>
<content>
   返回账户所用的通货名称。
</content>
<example>
Print(&quot;账户货币对&quot;, AccountCurrency());
</example>
</function>
<function>
tag=account_AccountEquity
caption=AccountEquity()
type=double
<keywords>
;AccountEquity();AccountEquity;
</keywords>
<content>
      对于当前账户返回资产净值。资产净值取决于交易服务器的设置。 
</content>
<example>
Print(&quot;账户净值 = &quot;,AccountEquity());
</example>
</function>
<function>
tag=account_AccountFreeMargin
caption=AccountFreeMargin()
type=double
<keywords>
;AccountFreeMargin();AccountFreeMargin;
</keywords>
<content>
      返回当前帐户的免费保证金价格值。
</content>
<example>
Print(&quot;账户免费保证金 = &quot;,AccountFreeMargin());
</example>
</function>
<function>
tag=account_AccountFreeMarginCheck
caption=AccountFreeMarginCheck()
type=double
<keywords>
;AccountFreeMarginCheck();AccountFreeMarginCheck;
</keywords>
<content>
    当前账户的当前价格上在指定开仓的仓位返回自由保证金。如果免费保证金不够，将会生成<a href="help://constants_errors">错误</a>134(ERR_NOT_ENOUGH_MONEY) 。
</content>
<example>
if(AccountFreeMarginCheck(Symbol(),OP_BUY,Lots)&lt;=0 || GetLastError()==134) return;
</example>
<parameter>
type=string
name=symbol
description=交易业务货币对。
</parameter>
<parameter>
type=int
name=cmd
description=交易类型。可能是<a href="help://constants_trading">OP_BUY</a>或者  <a href="help://constants_trading">OP_SELL</a>。
</parameter>
<parameter>
type=double
name=volume
description=份额数。
</parameter>
</function>
<function>
tag=account_AccountFreeMarginMode
caption=AccountFreeMarginMode()
type=double
<keywords>
;AccountFreeMarginMode();AccountFreeMarginMode;
</keywords>
<content>
   在当前开仓位置的账户上计算免费保证金的模式。计算方式可能采取以下价格值:<br/><br/>
      0 - 浮动profit/loss 不使用<br/>
      1 - 两个浮动赢利和损失在开仓位置上使用计算自由保证金;<br/>
      2 - 只有赢利值被使用计算，不考虑当前开仓的亏损;<br/>
      3 - 只有亏损值被使用计算, 不考虑当前开仓的亏损。
</content>
<example>
if(AccountFreeMarginMode()==0)
   Print(&quot;浮点盈利/亏损不使用。&quot;);
</example>
</function>
<function>
tag=account_AccountLeverage
caption=AccountLeverage()
type=int
<keywords>
;AccountLeverage();AccountLeverage;
</keywords>
<content>
     返回当前账户杠杆比率。
</content>
<example>
Print(&quot;账户#&quot;,AccountNumber(), &quot; 杠杆比率&quot;, AccountLeverage());
</example>
</function>
<function>
tag=account_AccountMargin
caption=AccountMargin()
type=double
<keywords>
;AccountMargin();
</keywords>
<content>
返回当前帐户的保证金。
</content>
<example>
Print(&quot;账户保证金 &quot;, AccountMargin());
</example>
</function>
<function>
tag=account_AccountName
caption=AccountName()
type=string
<keywords>
;AccountName();
</keywords>
<content>
     返回当前帐户名称。
</content>
<example>
Print(&quot;账户名称&quot;, AccountName());
</example>
</function>
<function>
tag=account_AccountNumber
caption=AccountNumber()
type=int
<keywords>
;AccountNumber();
</keywords>
<content>
      返回当前帐户的数字。
</content>
<example>
Print(&quot;账户数字&quot;, AccountNumber());
</example>
</function>
<function>
tag=account_AccountProfit
caption=AccountProfit()
type=double
<keywords>
;AccountProfit();
</keywords>
<content>
     返回账户利润。
</content>
<example>
Print(&quot;账户利润&quot;, AccountProfit());
</example>
</function>
<function>
tag=account_AccountServer
caption=AccountServer()
type=string
<keywords>
;AccountServer();
</keywords>
<content>
      返回连接服务器的名称。
</content>
<example>
Print(&quot;服务器名称&quot;, AccountServer());
</example>
</function>
<function>
tag=account_AccountStopoutLevel
caption=AccountStopoutLevel()
type=int
<keywords>
;AccountStopoutLevel();
</keywords>
<content>
   返回停止水平值。
</content>
<example>
Print(&quot;停止水平 = &quot;, AccountStopoutLevel());
</example>
</function>
<function>
tag=account_AccountStopoutMode
caption=AccountStopoutMode()
type=int
<keywords>
;AccountStopoutMode();
</keywords>
<content>
     对于停止水平返回的的运算方式。运算方式值如下:<br/><br/>
      0 - 计算保证金和净值之间的百分比;<br/>
      1 - 比较自由保证金水平和绝对值。
</content>
<example>
int level=AccountStopoutLevel();
if(AccountStopoutMode()==0)
   Print(&quot;停止水平= &quot;,水平, &quot;%&quot;);
else
   Print(&quot;停止水平= &quot;, 水平, &quot; &quot;, AccountCurrency());
</example>
</function>
</group>
<group>
tag=array
caption=Array functions
<keywords>
;Array functions;
</keywords>
<content>
        使用数组的一组函数。<br/><br/>
    数组的最大维数为四维。每个维数被索引编为从0 至<b>维度</b>-1。
    事实上，第一维数组的50 个，在调用时第一个数组显示为[0],最后一个数组显示为[49]。<br/><br/>
    使用这些函数(除那些改变定量和定性的数组外) 能够预定义时间系列<a href="help://predefined_variables_time">Time[]</a>, <a href="help://predefined_variables_open">Open[]</a>,
    <a href="help://predefined_variables_high">High[]</a>, <a href="help://predefined_variables_low">Low[]</a>,
    <a href="help://predefined_variables_close">Close[]</a>, <a href="help://predefined_variables_volume">Volume[]</a>

</content>
<function>
tag=array_ArrayBsearch
caption=ArrayBsearch()
type=int
<keywords>
;ArrayBsearch();
</keywords>
<content>
        如果没有发现事件，值会返回到第一个维度的数组或者最近的一个数组。<br/>

       此函数不能用在字符型或连续数字的数组上(除打开柱的连续数组)。<br/>
       注解: 双元查找只能够存储数。存储数字数组使用<a href="help://array_ArraySort">ArraySort()</a> 函数。
</content>
<example>
   datetime daytimes[];
   int      shift=10,dayshift;
   // 全部 Time[] 数组被排列在后面的形式
   ArrayCopySeries(daytimes,MODE_TIME,Symbol(),PERIOD_D1);
   if(Time[shift]&gt;=daytimes[0]) dayshift=0;
   else
     {
      dayshift=ArrayBsearch(daytimes,Time[shift],WHOLE_ARRAY,0,MODE_DESCEND);
      if(Period()&lt;PERIOD_D1) dayshift++;
     }
   Print(TimeToStr(Time[shift]),&quot; corresponds to &quot;,dayshift,&quot; day bar opened at &quot;,
         TimeToStr(daytimes[dayshift]));
</example>
<parameter>
type=double
name=<nobr>array[]</nobr>
description=需要搜索的数组.
</parameter>
<parameter>
type=double
name=value
description=将要搜索的值
</parameter>
<parameter>
type=
name=count
description=搜索的数量，默认搜索所有的数组.
</parameter>
<parameter>
type=
name=start
description=搜索的开始点，默认从头开始.
</parameter>
<parameter>
type=
name=direction
description=搜索的方向:<br/>MODE_ASCEND 顺序搜索,<br/>MODE_DESCEND 倒序搜索.
</parameter>
</function>
<function>
tag=array_ArrayCopy
caption=ArrayCopy()
type=int
<keywords>
;ArrayCopy();
</keywords>
<content>
复制一个数组到另外一个数组。 只有double[], int[], datetime[], color[], 和 bool[] 这些类型的数组可以被复制。 <br/>
返回复制元素总量。
</content>
<example>
  double array1[][6];
  double array2[10][6];
  // 数组2 被相同数据添满
  ArrayCopyRates(array1);
  ArrayCopy(array2,array1,0,0,60);
  // 现在数组2 的前10个柱来自历史(前10个柱包括索引[Bars-1])
  ArrayCopy(array2,array1,0,Bars*6-60,60);
  // 现在数组2 的后10个柱来自历史(后10个柱包括索引[0])
</example>
<parameter>
type=void
name=<nobr>dest[]</nobr>
description=目标数组 。
</parameter>
<parameter>
type=object
name=<nobr>source[]</nobr>
description=源数组 。
</parameter>
<parameter>
type=
name=start_dest
description=从目标数组的第几位开始写入，默认为0 。
</parameter>
<parameter>
type=
name=start_source
description=从源数组的第几位开始读取，默认为0 。
</parameter>
<parameter>
type=
name=count
description=读取多少位的数组 。默认值为WHOLE_ARRAY常数。
</parameter>
</function>
<function>
tag=array_ArrayCopyRates
caption=ArrayCopyRates()
type=int
<keywords>
;ArrayCopyRates();
</keywords>
<content>
复制一段走势图上的数据到一个二维数组，并返回复制柱总量，如果是-1表示失败。
数组的第二维只有6个项目分别是:<br/>
0 - 时间, <br/>
1 - 开盘价格, <br/>
2 - 最低价格, <br/>
3 - 最高价格,  <br/>
4 - 收盘价格,  <br/>
5 - 成交量. <br/> <br/>

如果数据(货币对名称/不同于当前的时间周期) 拒绝其他图表，这种情况下相应的图表不能够在客户端内打开，数据自然会拒绝服务器。这种情况，
<a href="help://constants_errors">错误</a> ERR_HISTORY_WILL_UPDATED (4066 - 拒绝刷新历史数据)
将被放置到 <a href="help://runtime_errors">last_error</a> 变量中，并且将再次拒绝(查看范例<a href="help://array_ArrayCopySeries">ArrayCopySeries()</a>).<br/><br/>
注解:此数组通常用于到DLL函数的通过数据 。<br/>
对于数据数组内存没有真正的分配，没有真正地执行复制。当数组访问时，将会改变方向。
</content>
<example>
  double array1[][6];
  ArrayCopyRates(array1,"EURUSD", PERIOD_H1);
  Print("当前柱 ",TimeToStr(array1[0][0]),"开盘价格", array1[0][1]);
</example>
<parameter>
type=void
name=<nobr>dest_array[]</nobr>
description=在二维数组上的双重目标数组。
</parameter>
<parameter>
type=
name=symbol
description=货币对名称
</parameter>
<parameter>
type=
name=timeframe
description=时间周期. 可以是<a href="help://constants_timeframes">列出时间周期</a>的任意值。
</parameter>
</function>
<function>
tag=array_ArrayCopySeries
caption=ArrayCopySeries()
type=int
<keywords>
;ArrayCopySeries();
</keywords>
<content>
     复制一个系列的走势图数据到数组上.<br/><br/>
        对于数据数组内存没有真正的分配，没有真正地执行复制。当数组访问时，将会改变方向。在客户指标内禁止数组作为 <a href="help://customind_SetIndexBuffer">数组下标</a>分配。这种情况下，数组被真正复制。<br/><br/>
       如果数据从不同货币对/时间周期图表复制，数据可能缺乏。这种情况下， <a href="help://constants_errors">错误</a> ERR_HISTORY_WILL_UPDATED (4066 - 拒绝刷新历史数据)将被放置到 <a href="help://runtime_errors">last_error</a> 变量中，并且在确定的时间周期内将重新尝试复制。
       <br/><br/>
        
     注解: 如果series_index是MODE_TIME, 那么第一个参量必须是日期型的数组 
</content>
<example>
datetime daytimes[];
int      shift=10,dayshift,error;
//---- 此Time[] 数组被排列在后面的命令
ArrayCopySeries(daytimes,MODE_TIME,Symbol(),PERIOD_D1);
error=GetLastError();
if(error==4066)
  {
   //---- 使两个以上接受只读
   for(int i=0;i&lt;2; i++)
     {
      Sleep(5000);
      ArrayCopySeries(daytimes,MODE_TIME,Symbol(),PERIOD_D1);
      //---- 检查但前每日柱时间
      datetime last_day=daytimes[0];
      if(Year()==TimeYear(last_day) &amp;&amp; Month()==TimeMonth(last_day) &amp;&amp; Day()==TimeDay(last_day)) break;
     }
  }
if(Time[shift]>=daytimes[0]) dayshift=0;
else
  {
   dayshift=ArrayBsearch(daytimes,Time[shift],WHOLE_ARRAY,0,MODE_DESCEND);
   if(Period()&lt;PERIOD_D1) dayshift++;
  }
Print(TimeToStr(Time[shift])," 相应 ",dayshift," day bar opened at ", TimeToStr(daytimes[dayshift]));
</example>
<parameter>
type=void
name=<nobr>array[]</nobr>
description=目标第一维数字数组。
</parameter>
<parameter>
type=int
name=series_index
description=连续数组识别符。必须是<a href="help://constants_series">连续数组</a>列表识别符其中的值。
</parameter>
<parameter>
type=
name=symbol
description=当前货币对名称
</parameter>
<parameter>
type=
name=timeframe
description=图表时间周期。可以是 <a href="help://constants_timeframes">列出时间周期</a>的任意值。
</parameter>
</function>
<function>
tag=array_ArrayDimension
caption=ArrayDimension()
type=int
<keywords>
;ArrayDimension();
</keywords>
<content>
      返回数组的多元维数
</content>
<example>
int num_array[10][5];
int dim_size;
dim_size=ArrayDimension(num_array);
// dim_size=2
</example>
<parameter>
type=object
name=<nobr>array[]</nobr>
description=将要返回的数组。
</parameter>
</function>
<function>
tag=array_ArrayGetAsSeries
caption=ArrayGetAsSeries()
type=bool
<keywords>
;ArrayGetAsSeries();
</keywords>
<content>
         返回TRUE，如果数组有组织序列的数组(是否从最后到最开始排序过的)，否则返回FALSE。
</content>
<example>
  if(ArrayGetAsSeries(array1)==true)
    Print(&quot;数组1是作为连续指数被编入索引&quot;);
  else
    Print(&quot;数组1 正常编入索引(从左到右)&quot;);
</example>
<parameter>
type=object
name=<nobr>array[]</nobr>
description=需要检查的数组。
</parameter>
</function>
<function>
tag=array_ArrayInitialize
caption=ArrayInitialize()
type=int
<keywords>
;ArrayInitialize();
</keywords>
<content>
        对数组进行初始化，返回经过初始化的数组项的个数 。<br/>
      注解:在客户指标中的<i>init()</i>函数不建议使用到初始化缓冲，在这种函数自动初始化<a href="help://customind_SetIndexEmptyValue">&quot;空值&quot;</a>将自动分配和缓冲重新分配。
</content>
<example>
  //----初始化所有带有2.1的数组
  double myarray[10];
  ArrayInitialize(myarray,2.1);
</example>
<parameter>
type=void
name=<nobr>array[]</nobr>
description=需要初始化的数组。
</parameter>
<parameter>
type=double
name=value
description=新的数组项的值 。
</parameter>
</function>
<function>
tag=array_ArrayIsSeries
caption=ArrayIsSeries()
type=bool
<keywords>
;ArrayIsSeries();
</keywords>
<content>
      如果检查数组是连续的(Time[],Open[],Close[],High[],Low[], or Volume[]), 返回 TRUE，否则返回FALSE。
</content>
<example>
   if(ArrayIsSeries(array1)==false)
     ArrayInitialize(array1,0);
   else
     {
      Print("连续数组不能被初始化!");
      return(-1);
     }
</example>
<parameter>
type=object
name=<nobr>array[]</nobr>
description=需要检查的数组 。
</parameter>
</function>
<function>
tag=array_ArrayMaximum
caption=ArrayMaximum()
type=int
<keywords>
;ArrayMaximum();
</keywords>
<content>
    找出数组中最大值的定位 。在数组中函数返回最大值位置。
</content>
<example>
double num_array[15]={4,1,6,3,9,4,1,6,3,9,4,1,6,3,9};
int    maxValueIdx=ArrayMaximum(num_array);
Print(&quot;最大值 = &quot;, num_array[maxValueIdx]);
</example>
<parameter>
type=double
name=<nobr>array[]</nobr>
description=搜索数字数组。
</parameter>
<parameter>
type=
name=count
description=搜索数组中项目的个数。
</parameter>
<parameter>
type=
name=start
description=搜索的开始指数。
</parameter>
</function>
<function>
tag=array_ArrayMinimum
caption=ArrayMinimum()
type=int
<keywords>
;ArrayMinimum();
</keywords>
<content>
      找出数组中最小值的定位 。在数组中函数返回最小值位置。
</content>
<example>
double num_array[15]={4,1,6,3,9,4,1,6,3,9,4,1,6,3,9};
int    minValueidx=ArrayMinimum(num_array);
Print(&quot;最小值 = &quot;, num_array[minValueIdx]);
</example>
<parameter>
type=double
name=<nobr>array[]</nobr>
description=搜索数字数组。
</parameter>
<parameter>
type=
name=count
description=搜索数组中项目的个数。
</parameter>
<parameter>
type=
name=start
description=搜索的开始指数。
</parameter>
</function>
<function>
tag=array_ArrayRange
caption=ArrayRange()
type=int
<keywords>
;ArrayRange();
</keywords>
<content>
        取数组中指定维数中项目的数量。 
        索引以零为基础，维度的大小要大于最大索引1 个点。
</content>
<example>
int    dim_size;
double num_array[10,10,10];
dim_size=ArrayRange(num_array, 1);
</example>
<parameter>
type=object
name=<nobr>array[]</nobr>
description=需要检查的数组。
</parameter>
<parameter>
type=int
name=range_index
description=指定的维数 。
</parameter>
</function>
<function>
tag=array_ArrayResize
caption=ArrayResize()
type=int
<keywords>
;ArrayResize();
</keywords>
<content>
        设定第一维度的大小。如果成功执行，在重新设定后返回包含的全部个数。如果数组没有重设，返回 -1。<br/>
       注解:在函数完成执行后，在函数内数组地方水平化并且重设将保留不变。
       在函数被重新调用后，一些数组将不同于表明的数组。
</content>
<example>
double array1[][4];
int    element_count=ArrayResize(array1, 20);
// 新大小 - 80个
</example>
<parameter>
type=void
name=<nobr>array[]</nobr>
description=需要重设的数组。
</parameter>
<parameter>
type=int
name=new_size
description=第一维中数组的新大小 。
</parameter>
</function>
<function>
tag=array_ArraySetAsSeries
caption=ArraySetAsSeries()
type=bool
<keywords>
;ArraySetAsSeries();
</keywords>
<content>
        设定指数数组为系列数组。如果<i>设置</i>参量值为TRUE，数组将被编入索引。数组0位的值是最后的值。 其FALSE值设定一个标准的索引命令。此函数返回先前状态。
</content>
<example>
double macd_buffer[300];
double signal_buffer[300];
int    i,limit=ArraySize(macd_buffer);
ArraySetAsSeries(macd_buffer,true);
 
for(i=0; i&lt;limit; i++)
   macd_buffer[i]=iMA(NULL,0,12,0,MODE_EMA,PRICE_CLOSE,i)-iMA(NULL,0,26,0,MODE_EMA,PRICE_CLOSE,i);
   
for(i=0; i&lt;limit; i++)
   signal_buffer[i]=iMAOnArray(macd_buffer,limit,9,0,MODE_SMA,i);
</example>
<parameter>
type=void
name=<nobr>array[]</nobr>
description=需要设置的数组。
</parameter>
<parameter>
type=bool
name=set
description=索引数组命令。
</parameter>
</function>
<function>
tag=array_ArraySize
caption=ArraySize()
type=int
<keywords>
;ArraySize();
</keywords>
<content>
      返回数组的项目数 。对于第一维数组，用ArraySize函数返回的 <a href="help://array_ArrayRange">ArrayRange(array,0)</a>。
</content>
<example>
int count=ArraySize(array1);
for(int i=0; i&lt;count; i++)
  {
   // 一些计算.
  }
</example>
<parameter>
type=object
name=<nobr>array[]</nobr>
description=任何类型数组。
</parameter>
</function>
<function>
tag=array_ArraySort
caption=ArraySort()
type=int
<keywords>
;ArraySort();ArraySort();MODE_ASCEND;MODE_DESCEND;
</keywords>
<content>
      对数组进行排序，系列数组不能ArraySort()使用进行排序 。
</content>
<example>
  double num_array[5]={4,1,6,3,9};
  // 新数组包含值4,1,6,3,9
  ArraySort(num_array);
  // 被排列新数组1,3,4,6,9
  ArraySort(num_array,WHOLE_ARRAY,0,MODE_DESCEND);
  // 被排列新数组 9,6,4,3,1
</example>
<parameter>
type=void
name=<nobr>array[]</nobr>
description=被排列的数组。
</parameter>
<parameter>
type=
name=count
description=对多少个数组项进行排序。
</parameter>
<parameter>
type=
name=start
description=排序的开始点。
</parameter>
<parameter>
type=
name=sort_dir
description=排序方式， <br/>MODE_ASCEND顺序排列， <br/> MODE_DESCEND倒序排列。
</parameter>
</function>
</group>
<group>
tag=check
caption=Checkup
<keywords>
;Checkup;
</keywords>
<content>
       一组可以检测当前客户端状态（包括MQL4程序的环境状态）的函数。

</content>
<function>
tag=check_GetLastError
caption=GetLastError()
type=int
<keywords>
;GetLastError();
</keywords>
<content>
       函数返回<a href="help://constants_errors">最后生成错误</a>，随后特殊值<a href="help://runtime_errors">last_error</a>变量的代码存储归零。
      所以， 对于GetLastError() 调用文本将返回0。
</content>
<example>
  int err;
  int handle=FileOpen(&quot;somefile.dat&quot;, FILE_READ|FILE_BIN);
  if(handle&lt;1)
    {
     err=GetLastError();
     Print(&quot;错误(&quot;,err,&quot;): &quot;,ErrorDescription(err));
     return(0);
    }
</example>
</function>
<function>
tag=check_IsConnected
caption=IsConnected()
type=bool
<keywords>
;IsConnected();
</keywords>
<content>
     在客户终端和服务器执行数据之间函数返回主要连接状态。如果连接服务器成功，返回TRUE。否则，返回FALSE。
</content>
<example>
  if(!IsConnected())
    {
     Print(&quot;没有连接!&quot;);
     return(0);
    }
  // 需要打开连接
  // ...
</example>
</function>
<function>
tag=check_IsDemo
caption=IsDemo()
type=bool
<keywords>
;IsDemo();
</keywords>
<content>
     如果智能交易在模拟账户运行，返回 TRUE 。否则，返回FALSE。
</content>
<example>
  if(IsDemo()) Print(&quot;在模拟账户运行&quot;);
  else Print(&quot;在真实账户运行&quot;);
</example>
</function>
<function>
tag=check_IsDllsAllowed
caption=IsDllsAllowed()
type=bool
<keywords>
;IsDllsAllowed();
</keywords>
<content>
如果智能交易函数DLL允许调用，返回TRUE。否则，返回FALSE。<br/>
<b>参见</b> <a href="help://check_IsLibrariesAllowed">IsLibrariesAllowed()</a>, <a href="help://check_IsTradeAllowed">IsTradeAllowed()</a>.
</content>
<example>
  #import &quot;user32.dll&quot;
     int     MessageBoxA(int hWnd, string szText, string szCaption,int nType);
  ...
  ...
  if(IsDllsAllowed()==false)
    {
     Print(&quot;DLL不允许调用。智能交易没有运行。&quot;);
     return(0);
    }
  // 智能交易外部调用 DLL函数
    MessageBoxA(0,&quot;an message&quot;,&quot;Message&quot;,MB_OK);
</example>
</function>
<function>
tag=check_IsExpertEnabled
caption=IsExpertEnabled()
type=bool
<keywords>
;IsExpertEnabled();
</keywords>
<content>
        如果智能交易开启运行，返回TRUE。否则，返回FALSE。
</content>
<example>
  while(!IsStopped())
    {
     ...
     if(!IsExpertEnabled()) break;
    }
</example>
</function>
<function>
tag=check_IsLibrariesAllowed
caption=IsLibrariesAllowed()
type=bool
<keywords>
;IsLibrariesAllowed();
</keywords>
<content>
       如果智能交易允许调用数据库函数，返回TRUE 。否则，返回FALSE。
        <b>参见</b> <a href="help://check_IsDllsAllowed">IsDllsAllowed()</a>, <a href="help://check_IsTradeAllowed">IsTradeAllowed()</a>.
</content>
<example>
  #import &quot;somelibrary.ex4&quot;
     int somefunc();
  ...
  ...
  if(IsLibrariesAllowed()==false)
    {
     Print(&quot;不允许调用数据库&quot;);
     return(0);
    }
  // 智能交易调用外部 DLL 函数
  somefunc();
</example>
</function>
<function>
tag=check_IsOptimization
caption=IsOptimization()
type=bool
<keywords>
;IsOptimization();
</keywords>
<content>
     如果在策略测试中智能交易为优化模式，返回TRUE。否则，返回FALSE。
</content>
<example>
  if(IsOptimization()) return(0);
</example>
</function>
<function>
tag=check_IsStopped
caption=IsStopped()
type=bool
<keywords>
;IsStopped();
</keywords>
<content>
        如果程序（智能交易或脚本）得到命令中止业务，返回TRUE。否则，返回FALSE。
      在客户端中止<a href="help://runtime_start">执行</a>之前程序业务会继续运行2.5秒。
</content>
<example>
  while(expr!=false)
    {
     if(IsStopped()==true) return(0);
     // 长运行时间循环
     // ...
    }
</example>
</function>
<function>
tag=check_IsTesting
caption=IsTesting()
type=bool
<keywords>
;IsTesting();
</keywords>
<content>
      如果智能交易在测试模式中运行，返回TRUE 。否则，返回FALSE。
</content>
<example>
  if(IsTesting()) Print(&quot;测试中&quot;);
</example>
</function>
<function>
tag=check_IsTradeAllowed
caption=IsTradeAllowed()
type=bool
<keywords>
;IsTradeAllowed();
</keywords>
<content>
        如果智能交易允许交易，返回TRUE 。否则，返回FALSE。<br/>
        <b>参见</b> <a href="help://check_IsDllsAllowed">IsDllsAllowed()</a>, <a href="help://check_IsLibrariesAllowed">IsLibrariesAllowed()</a>, <a href="help://check_IsTradeContextBusy">IsTradeContextBusy()</a>。
</content>
<example>
  if(IsTradeAllowed()) Print(&quot;允许交易&quot;);
</example>
</function>
<function>
tag=check_IsTradeContextBusy
caption=IsTradeContextBusy()
type=bool
<keywords>
;IsTradeContextBusy();
</keywords>
<content>
如果其他智能交易交易忙，返回TRUE。否则，返回FALSE。<br/>
<b>参见</b> <a href="help://check_IsTradeAllowed">IsTradeAllowed()</a>.
</content>
<example>
  if(IsTradeContextBusy()) Print(&quot;交易文本忙，请稍等&quot;);
</example>
</function>
<function>
tag=check_IsVisualMode
caption=IsVisualMode()
type=bool
<keywords>
;IsVisualMode();
</keywords>
<content>
     如果智能交易用&quot;图片模式&quot;测试，返回TRUE 。否则，返回FALSE。
</content>
<example>
  if(IsVisualMode()) Comment("Visual mode turned on");
</example>
</function>
<function>
tag=check_UninitializeReason
caption=UninitializeReason()
type=int
<keywords>
;UninitializeReason();
</keywords>
<content>
       返回智能交易，自定义指标和脚本的未初始化原因代码。
       返回值为<a href="help://constants_uninit">未初始化原因代码</a>之一。
      此函数同样可以在函数 init() 中调用分析先前开启初始化原因。
</content>
<example>
  // 这是范例
  int deinit()
    {
     switch(UninitializeReason())
       {
        case REASON_CHARTCLOSE:
        case REASON_REMOVE:      CleanUp(); break; // 清理和抽空所有源代码
        case REASON_RECOMPILE:
        case REASON_CHARTCHANGE:
        case REASON_参量:
        case REASON_ACCOUNT:     StoreData(); break;  // 准备重新开始
       }
     //...
    }
</example>
</function>
</group>
<group>
tag=terminal
caption=Client terminal
<keywords>
;Client terminal;
</keywords>
<content>
        函数返回的客户终端信息。

</content>
<function>
tag=terminal_TerminalCompany
caption=TerminalCompany()
type=string
<keywords>
;TerminalCompany();
</keywords>
<content>
     返回所属客户端公司名称。
</content>
<example>
Print(&quot;公司名称 &quot;,TerminalCompany());
</example>
</function>
<function>
tag=terminal_TerminalName
caption=TerminalName()
type=string
<keywords>
;TerminalName();
</keywords>
<content>
      返回客户端名称。
</content>
<example>
Print(&quot;终端名称&quot;,TerminalName());
</example>
</function>
<function>
tag=terminal_TerminalPath
caption=TerminalPath()
type=string
<keywords>
;TerminalPath();
</keywords>
<content>
      从被开启的客户端返回文件目录。
</content>
<example>
Print(&quot;工作目录&quot;,TerminalPath());
</example>
</function>
</group>
<group>
tag=common
caption=Common functions
<keywords>
;Common functions;
</keywords>
<content>
        常规命令函数不包括特殊函数。
</content>
<function>
tag=common_Alert
caption=Alert()
type=void
<keywords>
;Alert();
</keywords>
<content>
        弹出一个显示信息的警告窗口。
        参量可以使任意类型。通过参量总数不得超过64。<br/><br/>
        对于警报函数数组不能通过。数组可以作为输出元素。<br/><br/>
        双重数据类型可以输入到小数点后4位。
        输入数据使用<a href="help://convert_DoubleToStr">DoubleToStr()</a>函数更为精确。<br/>
        bool数据, 时间和颜色类型警作为数字类型输入。<br/>
        时间类型值作为数组使用 <a href="help://convert_TimeToStr">TimeToStr()</a>函数输入。<br/>
        <b>参见</b> <a href="help://common_Comment">Comment()</a> 和<a href="help://common_Print">Print()</a> 函数。
</content>
<example>
  if(Close[0]&gt;SignalLevel)
    Alert(&quot;收盘价进入 &quot;, Close[0],&quot;!!!&quot;);
</example>
<parameter>
type=...
name=
description=任意值，如有多个可用逗号分割 。最多为64个参量。
</parameter>
</function>
<function>
tag=common_Comment
caption=Comment()
type=void
<keywords>
;Comment();
</keywords>
<content>
显示信息在走势图左上角 。参量可以使任意类型。通过参量总数不得超过64。<br/><br/>
        对于警报函数数组不能通过。数组可以作为输出元素。<br/><br/>
        双重数据类型可以输入到小数点后4位。
        输入数据使用<a href="help://convert_DoubleToStr">DoubleToStr()</a>函数更为精确。<br/>
        bool数据, 时间和颜色类型警作为数字类型输入。<br/>
 bool数据, 时间和颜色类型警作为数字类型输入。<br/>
        时间类型值作为数组使用 <a href="help://convert_TimeToStr">TimeToStr()</a>函数输入。<br/>
        <b>参见</b> <a href="help://common_Comment">Comment()</a> 和<a href="help://common_Print">Print()</a> 函数。
</content>
<example>
  double free=AccountFreeMargin();
  Comment(&quot;账户自由保证金 &quot;,DoubleToStr(free,2),"\n",&quot;Current time is &quot;,TimeToStr(TimeCurrent()));
</example>
<parameter>
type=...
name=
description==任意值，如有多个可用逗号分割 。最多为64个参量。
</parameter>
</function>
<function>
tag=common_GetTickCount
caption=GetTickCount()
type=int
<keywords>
;GetTickCount();
</keywords>
<content>
     使用GetTickCount()函数取时间标记，函数取回用毫秒标示的时间标记。
</content>
<example>
  int start=GetTickCount();
  // 计算...
  Print(&quot;Calculation time is &quot;, GetTickCount()-start, &quot; milliseconds.&quot;);
</example>
</function>
<function>
tag=common_MarketInfo
caption=MarketInfo()
type=double
<keywords>
;MarketInfo();
</keywords>
<content>
     在市场观察窗口返回不同数据保证金列表。
     当前保证金的部分描述存储在<a href="help://predefined_variables">预定义变量</a>。
</content>
<example>
   double bid   =MarketInfo(&quot;EURUSD&quot;,MODE_BID);
   double ask   =MarketInfo(&quot;EURUSD&quot;,MODE_ASK);
   double point =MarketInfo(&quot;EURUSD&quot;,MODE_POINT);
   int    digits=MarketInfo(&quot;EURUSD&quot;,MODE_DIGITS);
   int    spread=MarketInfo(&quot;EURUSD&quot;,MODE_SPREAD);
</example>
<parameter>
type=string
name=symbol
description=货币对保证金。
</parameter>
<parameter>
type=int
name=type
description=指定类别的请求识别符信息返回。可以是 <a href="help://constants_marketinfo">请求识别码</a>的任意值。
</parameter>
</function>
<function>
tag=common_MessageBox
caption=MessageBox()
type=int
<keywords>
;MessageBox();MessageBox;
</keywords>
<content>
在信息箱内可以创建，展示和控制信息箱。信息箱包含信息和题头。如果函数成功运行，MessageBox函数 <a href="help://constants_messagebox">返回代码</a>值为其中值之一。<br/> 
此函数从客户端的工作页面不能调用<a href="help://runtime_start">执行</a>。
</content>
<example>
  #include &lt;WinUser32.mqh&gt;
  
  if(ObjectCreate(&quot;text_object&quot;, OBJ_TEXT, 0, D'2004.02.20 12:30', 1.0045)==false)
    {
     int ret=MessageBox(&quot; ObjectCreate() function returned the &quot;+GetLastError()+&quot; error\nContinue?&quot;, &quot;Question&quot;, MB_YESNO|MB_ICONQUESTION);
     if(ret==IDNO) return(false);
    }
  // 继续
</example>
<parameter>
type=
name=text
description=窗口显示的文字。
</parameter>
<parameter>
type=
name=caption
description=窗口上显示的标题。如果参量为 NULL, 智能交易名称将被隐藏。
</parameter>
<parameter>
type=
name=flags
description=窗口选项开关。选项<a href="help://constants_messagebox"> 开关</a>存在组。
</parameter>
</function>
<function>
tag=common_PlaySound
caption=PlaySound()
type=void
<keywords>
;PlaySound();
</keywords>
<content>
      函数播放声音文件。文件必须载入目录<em>terminal_dir\sounds</em>或子目录内。
</content>
<example>
  if(IsDemo()) PlaySound(&quot;alert.wav&quot;);
</example>
<parameter>
type=string
name=filename
description=音频文件名 。
</parameter>
</function>
<function>
tag=common_Print
caption=Print()
type=void
<keywords>
;Print();Print;
</keywords>
<content>
将文本打印在结果窗口内 。 参量可以使任意类型。通过参量总数不得超过64。<br/><br/>
        对于Print()函数数组不能通过。数组可以作为输出元素。<br/><br/>
        双重数据类型可以输入到小数点后4位。
        输入数据使用<a href="help://convert_DoubleToStr">DoubleToStr()</a>函数更为精确。<br/>
        bool数据, 时间和颜色类型警作为数字类型输入。<br/>
        时间类型值作为数组使用 <a href="help://convert_TimeToStr">TimeToStr()</a>函数输入。<br/>
        <b>参见</b> <a href="help://common_Comment">Comment()</a> 和<a href="help://common_Print">Print()</a> 函数。
</content>
<example>
  Print(&quot;当前自由保证金 &quot;, AccountFreeMargin());
  Print(&quot;当前时间 &quot;, TimeToStr(TimeCurrent()));
  double pi=3.141592653589793;
  Print(&quot;PI number is &quot;, DoubleToStr(pi,8));
  // 输入数据: PI number is 3.14159265
  // 数组打印
  for(int i=0;i&lt;10;i++)
    Print(关闭[i]);
</example>
<parameter>
type=...
name=
description=任意值，如有多个可用逗号分割 。最多为64个。
</parameter>
</function>
<function>
tag=common_SendFTP
caption=SendFTP()
type=bool
<keywords>
;SendFTP();
</keywords>
<content>
设置在工具>选项>公开标签内发送文件到FTP 服务器。如果尝试失败, 返回FALSE。<br/>
在测试的模式下作用不能控制。作用可以从客户指标或其他中运作。<br/>
发送的文件必须储存在 <em>terminal_directory\experts\files</em>文件夹或子文件夹内。<br/>
如果不存在FTP 地址或者指定密码，文件不会传送。
</content>
<example>
  int lasterror=0;
  if(!SendFTP("report.txt"))
    lasterror=GetLastError();
</example>
<parameter>
type=string
name=filename
description=发送文件。
</parameter>
<parameter>
type=
name=ftp_path
description=FTP 通道。如果没有制定通道，会应用设置中的描述通道。
</parameter>
</function>
<function>
tag=common_SendMail
caption=SendMail()
type=void
<keywords>
;SendMail();
</keywords>
<content>
设置在工具>选项 >EMail 标签内发送电子邮件。<br/>
可以设置禁止此项功能， 或者是省略电子邮件地址。
获得详细错误信息，查看<a href="help://check_GetLastError">GetLastError()</a> 函数。
</content>
<example>
  double lastclose=Close[0];
  if(lastclose&lt;my_signal)
    SendMail(&quot;从你的智能交易&quot;, &quot;价格下降到&quot;+DoubleToStr(lastclose,Digits));
</example>
<parameter>
type=string
name=subject
description=文本。
</parameter>
<parameter>
type=string
name=some_text
description=邮件。
</parameter>
</function>

<function>
      tag=common_SendNotification
      caption=SendNotification()
      type=bool
      <content>
向选项窗口的“通知”标签上指定的MetaQuotes ID的移动程序端发送推送通知。<br/>
可以在设置中禁止发送通知。也可以省略ID。</br>
如果出错的话，函数会返回false。若要获取有关错误的信息，调用<a href="help://check_GetLastError">GetLastError()</a>函数。<br/><br/>
注意: SendNotification()函数具有严格的使用限制：每秒钟不得调用2次以上并且每分钟调用不超过10次。动态控制频繁调用，如若违背函数会被封锁。 
      </content>
      <example>
  double lastclose=Close[0];
  if(lastclose&lt;my_signal)
    SendNotification(&quot;价格更改 &quot;+DoubleToStr(lastclose,Digits));
      </example>
      <parameter>
        type=string
        name=message
        description=信息文本多达255个字符。
      </parameter>
    </function>

<function>
tag=common_Sleep
caption=Sleep()
type=void
<keywords>
;Sleep();
</keywords>
<content>
      The Sleep()函数是指在指定的时间间隔内暂停交易业务<br/>
      The Sleep()函数不能在客户指标内<a href="help://runtime_start">计算</a>。<br/>
      当进入函数<a href="help://check_IsStopped">停止状态</a> 智能交易每0.1 second秒会检测。
</content>
<example>
//---- 等待10秒
   Sleep(10000);
</example>
<parameter>
type=int
name=milliseconds
description=毫秒之内的内部睡眠。.
</parameter>
</function>
</group>
<group>
tag=convert
caption=Conversion functions
<keywords>
;Conversion functions;
</keywords>
<content>
       从一种格式转换到另一种格式提供数据的一组函数。<br/><br/>
  必须特别注意<a href="help://convert_NormalizeDouble">NormalizeDouble()</a>函数它提供了价格介绍的必要的准确性。 在交易的操作中，如果当前的数字超出交易服务器的需求，意味着没有任何标准的价格可以使用。 
</content>
<function>
tag=convert_CharToStr
caption=CharToStr()
type=string
<keywords>
;CharToStr();
</keywords>
<content>
      将字符型转换成字符串型结果。
</content>
<example>
  string str=&quot;WORL&quot; + CharToStr(44); // 'D'的44个代码。
  // 结果字串符将被WORLD
</example>
<parameter>
type=int
name=char_code
description=字符的ACSII码 。
</parameter>
</function>
<function>
tag=convert_DoubleToStr
caption=DoubleToStr()
type=string
<keywords>
;DoubleToStr();
</keywords>
<content>
        将双精度浮点型转换成字符串型的结果返回。
</content>
<example>
  string value=DoubleToStr(1.28473418, 5);
  // 值为&quot;1.28473&quot;
</example>
<parameter>
type=double
name=value
description=浮点型数字。
</parameter>
<parameter>
type=int
name=digits
description=精确格式，小数点后位(0-8)。
</parameter>
</function>
<function>
tag=convert_NormalizeDouble
caption=NormalizeDouble()
type=double
<keywords>
;NormalizeDouble();
</keywords>
<content>
     给出环绕浮点值的精确度。返回双重类型的正常化。<br/>
     计算止损和赢利值，挂单交易交易的<a href="help://trading_OrderSend">开盘价</a>必须正常化。精确值需要在<a href="help://predefined_variables_Digits">小数点</a>中预定义。
</content>
<example>
  double var1=0.123456789;
  Print(DoubleToStr(NormalizeDouble(var1,5),8));
  //  输入信息: 0.12346000
</example>
<parameter>
type=double
name=value
description=浮点值。
</parameter>
<parameter>
type=int
name=digits
description=精确格式，小数点之后的精确数字 (0-8)。
</parameter>
</function>
<function>
tag=convert_StrToDouble
caption=StrToDouble()
type=double
<keywords>
;StrToDouble();
</keywords>
<content>
      将字符串型转换成双精度浮点型结果。 
</content>
<example>
  double var=StrToDouble(&quot;103.2812&quot;);
</example>
<parameter>
type=string
name=value
description=数字的字符串转换格式 。
</parameter>
</function>
<function>
tag=convert_StrToInteger
caption=StrToInteger()
type=int
<keywords>
;StrToInteger();
</keywords>
<content>
     将字符串型转换成整型结果。
</content>
<example>
  int var1=StrToInteger(&quot;1024&quot;);
</example>
<parameter>
type=string
name=value
description=数字的字符串转换格式。
</parameter>
</function>
<function>
tag=convert_StrToTime
caption=StrToTime()
type=datetime
<keywords>
;StrToTime();
</keywords>
<content>
      将字符串型转换成时间型，输入格式为 &quot;yyyy.mm.dd hh:mi&quot;
</content>
<example>
  datetime var1;
  var1=StrToTime(&quot;2003.8.12 17:35&quot;);
  var1=StrToTime(&quot;17:35&quot;);      // 返回当前给出日期
  var1=StrToTime(&quot;2003.8.12&quot;);  // 返回午夜时间日期&quot;00:00&quot;
</example>
<parameter>
type=string
name=value
description=日期时间的字串符格式为 &quot;yyyy.mm.dd hh:mi&quot;。
</parameter>
</function>
<function>
tag=convert_TimeToStr
caption=TimeToStr()
type=string
<keywords>
;TimeToStr();
</keywords>
<content>
      时间类型(从1970 1月1 日通过的相当数量秒数）转换为 &quot;yyyy.mm.dd hh:mi&quot;格式。
</content>
<example>
  string var1=TimeToStr(TimeCurrent(),TIME_DATE|TIME_SECONDS);
</example>
<parameter>
type=datetime
name=value
description=自1970年1月所通过的数量秒数。
</parameter>
<parameter>
type=
name=mode
description=选择数据输出模式可以是以下的一个或者组合:<br/>TIME_DATE 结果格式为 &quot;yyyy.mm.dd&quot;,<br/>TIME_MINUTES 结果格式为 &quot;hh:mi&quot;,<br/>TIME_SECONDS 结果格式为 &quot;hh:mi:ss&quot;。
</parameter>
</function>
</group>
<group>
tag=customind
caption=Custom indicators
<keywords>
;Custom indicators;
</keywords>
<content>
        自定义指标中使用的一组函数。<br/><br/>
    这些函数不能在智能交易和脚本中使用。

</content>
<function>
tag=customind_IndicatorBuffers
caption=IndicatorBuffers()
type=void
<keywords>
;IndicatorBuffers();
</keywords>
<content>
        对于缓冲储存器分配记忆应用自定义指标计算。缓冲储存器的总数不能超过8或者是小于<a href="help://basis_preprosessor_compilation">自定义缓冲</a> 属性中所给出的值。 如果客户指标要求另外的缓冲器计数，那么这个功能必须使用为指定总额缓冲。 
</content>
<example>
#property  indicator_separate_window
#property  indicator_buffers 1
#property  indicator_color1  Silver
//---- 自定义参量
extern int FastEMA=12;
extern int SlowEMA=26;
extern int SignalSMA=9;
//---- 自定义缓冲
double     ind_buffer1[];
double     ind_buffer2[];
double     ind_buffer3[];
//+------------------------------------------------------------------+
//| Custom indicator initialization function                         |
//+------------------------------------------------------------------+
int init()
  {
//---- 使用2个添加缓冲。
   IndicatorBuffers(3);
//---- 画出设定
   SetIndexStyle(0,DRAW_HISTOGRAM,STYLE_SOLID,3);
   SetIndexDrawBegin(0,SignalSMA);
   IndicatorDigits(MarketInfo(Symbol(),MODE_DIGITS)+2);
//---- 绘制3 个添加缓冲位置
   SetIndexBuffer(0,ind_buffer1);
   SetIndexBuffer(1,ind_buffer2);
   SetIndexBuffer(2,ind_buffer3);
//----  DataWindow 和自定义窗口标签名称
   IndicatorShortName("OsMA("+FastEMA+","+SlowEMA+","+SignalSMA+")");
//---- 初始化结束
   return(0);
  }
</example>
<parameter>
type=int
name=count
description=在指标缓冲器和8缓冲储存器之间分配缓冲储存器的总量。
</parameter>
</function>
<function>
tag=customind_IndicatorCounted
caption=IndicatorCounted()
type=int
<keywords>
;IndicatorCounted();
</keywords>
<content>
在自定义最后一次开启之后，函数返回柱的总数不会改变。计算过的柱数无须重新计算。大多数情况下, 同样数额的索引值不需要重估。函数应用到优化计算中。
<br/><br/>
注解: 最近的柱无须考虑计算, 在多数情况下, 这个柱是要被重估的。不过，自定义指标显示交易中的新柱的第一替克。 可能先前柱的最后一个替克没有处理的结果（因为在最后 一个替克进入时倒数第二个没有 <a href="help://runtime_start">处理</a> 完成)客定义标将不会显示和计算。 在这样的情况下为了避免错误， IndicatorCounted()函数会返回前一个柱。 
</content>
<example>
  int start()
    {
     int limit;
     int counted_bars=IndicatorCounted();
  //---- 检验可能出现错误
     if(counted_bars&lt;0) return(-1);
  //---- 最后数的柱将被重数
     if(counted_bars&gt;0) counted_bars--;
     limit=Bars-counted_bars;
  //---- 主环
     for(int i=0; i&lt;limit; i++)
       {
        //---- ma_shift set to 0 because SetIndexShift called abowe
        ExtBlueBuffer[i]=iMA(NULL,0,JawsPeriod,0,MODE_SMMA,PRICE_MEDIAN,i);
        ExtRedBuffer[i]=iMA(NULL,0,TeethPeriod,0,MODE_SMMA,PRICE_MEDIAN,i);
        ExtLimeBuffer[i]=iMA(NULL,0,LipsPeriod,0,MODE_SMMA,PRICE_MEDIAN,i);
       }
  //---- 完成
     return(0);
    }
</example>
</function>
<function>
tag=customind_IndicatorDigits
caption=IndicatorDigits()
type=void
<keywords>
;IndicatorDigits();
</keywords>
<content>
      设置精确格式(计数数字在小数点以后)使自定义值直观化。货币对<a href="help://predefined_variables_Digits">精确价格</a> 为默认值。 指标会添加到图表中。
</content>
<example>
int init()
  {
//---- 使用及计算2个添加缓冲。
   IndicatorBuffers(3);
//---- 画出参量设置
   SetIndexStyle(0,DRAW_HISTOGRAM,STYLE_SOLID,3);
   SetIndexDrawBegin(0,SignalSMA);
   IndicatorDigits(Digits+2);
//----一个自定义的3个缓冲
   SetIndexBuffer(0,ind_buffer1);
   SetIndexBuffer(1,ind_buffer2);
   SetIndexBuffer(2,ind_buffer3);
//---- DataWindow 和自定义子窗口"简称" 
   IndicatorShortName("OsMA("+FastEMA+","+SlowEMA+","+SignalSMA+")");
//---- 初始化完成
   return(0);
  }
</example>
<parameter>
type=int
name=digits
description=精确格式。
</parameter>
</function>
<function>
tag=customind_IndicatorShortName
caption=IndicatorShortName()
type=void
<keywords>
;IndicatorShortName();
</keywords>
<content>
      设置显示在数据窗口和子窗口中自定义指标的&quot;简称&quot;。
</content>
<example>
int init()
  {
//----使用计算2个添加缓冲
   IndicatorBuffers(3);
//---- 画出设定
   SetIndexStyle(0,DRAW_HISTOGRAM,STYLE_SOLID,3);
   SetIndexDrawBegin(0,SignalSMA);
   IndicatorDigits(MarketInfo(Symbol(),MODE_DIGITS)+2);
//---- 绘制3个添加缓冲位置
   SetIndexBuffer(0,ind_buffer1);
   SetIndexBuffer(1,ind_buffer2);
   SetIndexBuffer(2,ind_buffer3);
//---- DataWindow 和自定义子窗口标签名称
   IndicatorShortName("OsMA("+FastEMA+","+SlowEMA+","+SignalSMA+")");
//---- 初始化完成
   return(0);
  }
</example>
<parameter>
type=string
name=name
description=新简称。
</parameter>
</function>
<function>
tag=customind_SetIndexArrow
caption=SetIndexArrow()
type=void
<keywords>
;SetIndexArrow();
</keywords>
<content>
      设置<a href="help://constants_drawstyles">DRAW_ARROW</a> 类型的自定义线为一个箭头货币对。<br/>
      <a href="help://constants_arrows">箭头代码</a>范围限于33到255之间。
</content>
<example>
int init()
  {
//---- 2 个自定义缓冲
    SetIndexBuffer(0,ExtUppperBuffer);
    SetIndexBuffer(1,ExtLowerBuffer);
//---- 绘制参量设置
    SetIndexStyle(0,DRAW_ARROW);
    SetIndexArrow(0,217);
    SetIndexStyle(1,DRAW_ARROW);
    SetIndexArrow(1,218);
//---- 在DataWindow窗口显示
    SetIndexLabel(0,"Fractal Up");
    SetIndexLabel(1,"Fractal Down");
//---- 初始化完成
   return(0);
  }
</example>
<parameter>
type=int
name=index
description=索引线。必须在0至7之间。
</parameter>
<parameter>
type=int
name=code
description=来自<a href="help://constants_wingdings">Wingdings</a> 或 <a href="help://constants_arrows">数组常数</a>的货币对代码。
</parameter>
</function>
<function>
tag=customind_SetIndexBuffer
caption=SetIndexBuffer()
type=bool
<keywords>
;SetIndexBuffer();
</keywords>
<content>
对于自定义指标预定义的缓冲器绑定全球水平。需要使用<a href="help://customind_IndicatorBuffers">IndicatorBuffers()</a> 函数计算缓冲器的总数并且不能超过8。如果成功，返回TRUE，否则将返回FALSE。获得详细信息，请查看 <a href="help://check_GetLastError">GetLastError()</a>函数。
</content>
<example>
  double ExtBufferSilver[];
  int init()
    {
      SetIndexBuffer(0, ExtBufferSilver); // 第一线缓冲
      // ...
    }
</example>
<parameter>
type=int
name=index
description=索引线。必须在0至7之间。
</parameter>
<parameter>
type=double
name=<nobr>array[]</nobr>
description=数组存储计算指标值。
</parameter>
</function>
<function>
tag=customind_SetIndexDrawBegin
caption=SetIndexDrawBegin()
type=void
<keywords>
;SetIndexDrawBegin();
</keywords>
<content>
从给出指标线画出必须开始设置柱数字(从数据开始) 。指标线会从左到右画出
所给出指标数组值左边部分不会显示在图表或数据窗口中。
设置0作为默认值, 随后，所有数据将得出。 
</content>
<example>
int init()
  {
//----使用计算2个添加缓冲
   IndicatorBuffers(3);
//----画出设定
   SetIndexStyle(0,DRAW_HISTOGRAM,STYLE_SOLID,3);
   SetIndexDrawBegin(0,SignalSMA);
   IndicatorDigits(MarketInfo(Symbol(),MODE_DIGITS)+2);
//---- 绘制3个添加缓冲位置
   SetIndexBuffer(0,ind_buffer1);
   SetIndexBuffer(1,ind_buffer2);
   SetIndexBuffer(2,ind_buffer3);
//---- DataWindow 和自定义子窗口标签名称
   IndicatorShortName("OsMA("+FastEMA+","+SlowEMA+","+SignalSMA+")");
//---- 初始化完成
   return(0);
  }
</example>
<parameter>
type=int
name=index
description=索引线。必须在0至7之间。
</parameter>
<parameter>
type=int
name=begin
description=第一个画出柱的数字位置。
</parameter>
</function>
<function>
tag=customind_SetIndexEmptyValue
caption=SetIndexEmptyValue()
type=void
<keywords>
;SetIndexEmptyValue();
</keywords>
<content>
        设置图画线省缺值。省缺值不得出或不被显示在DataWindow 。省缺值是EMPTY_VALUE。
</content>
<example>
int init()
  {
//----2个添加缓冲
    SetIndexBuffer(0,ExtUppperBuffer);
    SetIndexBuffer(1,ExtLowerBuffer);
//---- 画出参量设置
    SetIndexStyle(0,DRAW_ARROW);
    SetIndexArrow(0,217);
    SetIndexStyle(1,DRAW_ARROW);
    SetIndexArrow(1,218);
//---- 值0 不显示
    SetIndexEmptyValue(0,0.0);
    SetIndexEmptyValue(1,0.0);
//---- 在DataWindow窗口不显示
    SetIndexLabel(0,"Fractal Up");
    SetIndexLabel(1,"Fractal Down");
//---- 初始化完成
   return(0);
  }
</example>
<parameter>
type=int
name=index
description=索引线。必须在0至7之间。
</parameter>
<parameter>
type=double
name=value
description=新 &quot;省缺值&quot;。
</parameter>
</function>
<function>
tag=customind_SetIndexLabel
caption=SetIndexLabel()
type=void
<keywords>
;SetIndexLabel();
</keywords>
<content>
     在DataWindow 和tooltip中设置图画线描述。
</content>
<example>
//+------------------------------------------------------------------+
//| Ichimoku Kinko Hyo initialization function                       |
//+------------------------------------------------------------------+
int init()
  {
//----
   SetIndexStyle(0,DRAW_LINE);
   SetIndexBuffer(0,Tenkan_Buffer);
   SetIndexDrawBegin(0,Tenkan-1);
   SetIndexLabel(0,"Tenkan Sen");
//----
   SetIndexStyle(1,DRAW_LINE);
   SetIndexBuffer(1,Kijun_Buffer);
   SetIndexDrawBegin(1,Kijun-1);
   SetIndexLabel(1,"Kijun Sen");
//----
   a_begin=Kijun; if(a_begin&lt;Tenkan) a_begin=Tenkan;
   SetIndexStyle(2,DRAW_HISTOGRAM,STYLE_DOT);
   SetIndexBuffer(2,SpanA_Buffer);
   SetIndexDrawBegin(2,Kijun+a_begin-1);
   SetIndexShift(2,Kijun);
//---- 在DataWindow窗口Up Kumo线不显示
   SetIndexLabel(2,NULL);
   SetIndexStyle(5,DRAW_LINE,STYLE_DOT);
   SetIndexBuffer(5,SpanA2_Buffer);
   SetIndexDrawBegin(5,Kijun+a_begin-1);
   SetIndexShift(5,Kijun);
   SetIndexLabel(5,"Senkou Span A");
//----
   SetIndexStyle(3,DRAW_HISTOGRAM,STYLE_DOT);
   SetIndexBuffer(3,SpanB_Buffer);
   SetIndexDrawBegin(3,Kijun+Senkou-1);
   SetIndexShift(3,Kijun);
//---- 在DataWindow窗口Down Kumo 线不显示
   SetIndexLabel(3,NULL);
//----
   SetIndexStyle(6,DRAW_LINE,STYLE_DOT);
   SetIndexBuffer(6,SpanB2_Buffer);
   SetIndexDrawBegin(6,Kijun+Senkou-1);
   SetIndexShift(6,Kijun);
   SetIndexLabel(6,"Senkou Span B");
//----
   SetIndexStyle(4,DRAW_LINE);
   SetIndexBuffer(4,Chinkou_Buffer);
   SetIndexShift(4,-Kijun);
   SetIndexLabel(4,"Chinkou Span");
//----
   return(0);
  }
</example>
<parameter>
type=int
name=index
description=索引线。必须在0至7之间。
</parameter>
<parameter>
type=string
name=text
description=标签文本。 NULL 表示索引值在DataWindow不显示。
</parameter>
</function>
<function>
tag=customind_SetIndexShift
caption=SetIndexShift()
type=void
<keywords>
;SetIndexShift();
</keywords>
<content>
       撤销画线设置。对于仓位值，画线将会平移到右侧或是平移到左侧。在当前柱计算值将被平移到相应的柱。
</content>
<example>
//+------------------------------------------------------------------+
//| Alligator initialization function                                |
//+------------------------------------------------------------------+
int init()
  {
//----当画出时线平移
   SetIndexShift(0,JawsShift);
   SetIndexShift(1,TeethShift);
   SetIndexShift(2,LipsShift);
//---- 当画出时越过地一个位置
   SetIndexDrawBegin(0,JawsShift+JawsPeriod);
   SetIndexDrawBegin(1,TeethShift+TeethPeriod);
   SetIndexDrawBegin(2,LipsShift+LipsPeriod);
//---- 绘制3个添加缓冲位置
   SetIndexBuffer(0,ExtBlueBuffer);
   SetIndexBuffer(1,ExtRedBuffer);
   SetIndexBuffer(2,ExtLimeBuffer);
//---- 画出设定
   SetIndexStyle(0,DRAW_LINE);
   SetIndexStyle(1,DRAW_LINE);
   SetIndexStyle(2,DRAW_LINE);
//---- 索引标签
   SetIndexLabel(0,"Gator Jaws");
   SetIndexLabel(1,"Gator Teeth");
   SetIndexLabel(2,"Gator Lips");
//---- 初始化完成
   return(0);
  }
</example>
<parameter>
type=int
name=index
description=索引线。必须在0至7之间。
</parameter>
<parameter>
type=int
name=shift
description=平移植。
</parameter>
</function>
<function>
tag=customind_SetIndexStyle
caption=SetIndexStyle()
type=void
<keywords>
;SetIndexStyle();
</keywords>
<content>
      设置新型、样式、宽度和颜色为一条指定的显示线。
</content>
<example>
  SetIndexStyle(3, DRAW_LINE, EMPTY, 2, Red);
</example>
<parameter>
type=int
name=index
description=索引线。必须在0至7之间。
</parameter>
<parameter>
type=int
name=type
description=样式风格。可以是<a href="help://constants_drawstyles">划线风格</a>列表其中一个。
</parameter>
<parameter>
type=
name=style
description=画线风格。可以应用单线。可以是<a href="help://constants_drawstyles">划线风格</a>列表其中一个。  EMPTY 值表示风格不变。
</parameter>
<parameter>
type=
name=width
description=线的宽度。线的宽度可以是1,2,3,4,5。 EMPTY 值表示着风格不变。
</parameter>
<parameter>
type=
name=clr
description=线的颜色。.现存的参量表示颜色将不会改变。
</parameter>
</function>
<function>
tag=customind_SetLevelStyle
caption=SetLevelStyle()
type=void
<keywords>
;SetLevelStyle();
</keywords>
<content>
函数设置指标水平线输入新型、样式、宽度和颜色输入数据。
</content>
<example>
//---- 红色单线显示水平
   SetLevelStyle(STYLE_SOLID,2,Red)
</example>
<parameter>
type=int
name=draw_style
description=画线风格。可以应用单线。可以是<a href="help://constants_drawstyles">划线风格</a>列表其中一个。  EMPTY 值表示风格不变。
</parameter>
<parameter>
type=int
name=line_width
description=线的宽度。线的宽度可以是1,2,3,4,5。 EMPTY 值表示着风格不变。
</parameter>
<parameter>
type=
name=clr
description=线的颜色。.现存的参量表示颜色将不会改变。
</parameter>
</function>
<function>
tag=customind_SetLevelValue
caption=SetLevelValue()
type=void
<keywords>
;SetLevelValue();
</keywords>
<content>
      函数设置输入数据指标的水平线。
</content>
<example>
SetLevelValue(1,3.14);
</example>
<parameter>
type=int
name=level
description=水平索引(0-31)。
</parameter>
<parameter>
type=double
name=value
description=给出的指标水平值。
</parameter>
</function>
</group>
<group>
tag=dateandtime
caption=Date & Time functions
<keywords>
;Date & Time functions;
</keywords>
<content>
       表示时间类型数据的一组函数(从1970年1月1日午夜开始以秒为单位计算)。

</content>
<function>
tag=dateandtime_Day
caption=Day()
type=int
<keywords>
;Day();
</keywords>
<content>
     返回这个月的当天,最后一次访问服务器的时间。<br/>
     注解: 在测试中, 时间格式为最后设定的服务器模式。
</content>
<example>
  if(Day()&lt;5) return(0);
</example>
</function>
<function>
tag=dateandtime_DayOfWeek
caption=DayOfWeek()
type=int
<keywords>
;DayOfWeek();
</keywords>
<content>
     返回这周的星期数，(0-星期天,1,2,3,4,5,6 以此类推)来自最后已知的服务器上的时间。<br/>
    注解: 在测试中, 时间格式为最后设置的服务器模式。
</content>
<example>
  //  假期不工作
  if(DayOfWeek()==0 || DayOfWeek()==6) return(0);
</example>
</function>
<function>
tag=dateandtime_DayOfYear
caption=DayOfYear()
type=int
<keywords>
;DayOfYear();
</keywords>
<content>
     返回年的当天(1 代表1月1 日.., 365(6) 就是12月31 日)， 最后访问服务器的时间。<br/>
    注解: 在测试中, 时间格式为最后已知的服务器模式。
</content>
<example>
  if(DayOfYear()==245)
    return(true);
</example>
</function>
<function>
tag=dateandtime_Hour
caption=Hour()
type=int
<keywords>
;Hour();
</keywords>
<content>
     在程序开始以前的片刻，返回小时数(0,1,2,..23) 最后访问的服务器时间(在程序执行之内的时期这个值不会改变) 。<br/>
     注解: 在测试中, 时间格式为最后设置的服务器模式。
</content>
<example>
  bool is_siesta=false;
  if(Hour()&gt;=12 || Hour()&lt;17)
     is_siesta=true;
</example>
</function>
<function>
tag=dateandtime_Minute
caption=Minute()
type=int
<keywords>
;Minute();
</keywords>
<content>
    在程序开始以前的片刻，返回当前的分钟(0,1,2,..59)最后访问的服务器时间(在程序执行期间这个值不会改变) 。
</content>
<example>
  if(Minute()&lt;=15)
    return("first quarter");
</example>
</function>
<function>
tag=dateandtime_Month
caption=Month()
type=int
<keywords>
;Month();
</keywords>
<content>
     在程序开始以前的片刻，返回当前的月数(1,2,..12)最后访问的服务器时间(在程序执行期间这个值不会改变) 。<br/>
     注解: 在测试中, 时间格式为最后设定的服务器模式。
</content>
<example>
  if(Month()&lt;=5)
    return(&quot;the first half year&quot;);
</example>
</function>
<function>
tag=dateandtime_Seconds
caption=Seconds()
type=int
<keywords>
;Seconds();
</keywords>
<content>
      在程序开始以前的片刻，返回当前的秒数作为数字最后访问的服务器时间(在程序执行期间这个值不会改变) 。
</content>
<example>
  if(Seconds()&lt;=15)
    return(0);
</example>
</function>
<function>
tag=dateandtime_TimeCurrent
caption=TimeCurrent()
type=datetime
<keywords>
;TimeCurrent();
</keywords>
<content>
    返回最后访问的服务器时间(最新的行情输入时间)作为秒钟数字从00:00 1970 年1月1 日开始。<br/><br/>
     注解: 在测试中, 时间格式为最后设定的服务器模式。
</content>
<example>
  if(TimeCurrent()-OrderOpenTime()&lt;360) return(0);
</example>
</function>
<function>
tag=dateandtime_TimeDay
caption=TimeDay()
type=int
<keywords>
;TimeDay();
</keywords>
<content>
 返回输入日期中的日期（1-31）
</content>
<example>
  int day=TimeDay(D'2003.12.31');
  // 天数为31 
</example>
<parameter>
type=datetime
name=date
description=作为秒钟的数字从00:00 1970 年1月1 日开始。
</parameter>
</function>
<function>
tag=dateandtime_TimeDayOfWeek
caption=TimeDayOfWeek()
type=int
<keywords>
;TimeDayOfWeek();
</keywords>
<content>
    返回从零开始的星期中的第几天(0 代表星期天, 1, 2, 3, 4, 5, 6) 为指定日期。
</content>
<example>
  int weekday=TimeDayOfWeek(D'2004.11.2');
  // 数字2 - 星期二
</example>
<parameter>
type=datetime
name=date
description=作为秒钟的数字，从00:00 1970 年1月1 日开始。
</parameter>
</function>
<function>
tag=dateandtime_TimeDayOfYear
caption=TimeDayOfYear()
type=int
<keywords>
;TimeDayOfYear();
</keywords>
<content>
      返回一年中的日数(1 意味1月1 日.., 365(6) 表示12月31 日)为指定日期。
</content>
<example>
  int day=TimeDayOfYear(TimeCurrent());
</example>
<parameter>
type=datetime
name=date
description=作为秒钟的数字，从00:00 1970 年1月1 日开始。
</parameter>
</function>
<function>
tag=dateandtime_TimeHour
caption=TimeHour()
type=int
<keywords>
;TimeHour();
</keywords>
<content>
     返回小时为指定的时间。
</content>
<example>
  int h=TimeHour(TimeCurrent());
</example>
<parameter>
type=datetime
name=time
description=作为秒钟的数字，从00:00 1970 年1月1 日开始。
</parameter>
</function>
<function>
tag=dateandtime_TimeLocal
caption=TimeLocal()
type=datetime
<keywords>
;TimeLocal();
</keywords>
<content>
     返回当前电脑时间，从00:00 1970 年1月1 日开始。<br/>
    注解: 在测试中, 时间格式为最后设定的服务器模式。
</content>
<example>
  if(TimeLocal()-OrderOpenTime()&lt;360) return(0);
</example>
</function>
<function>
tag=dateandtime_TimeMinute
caption=TimeMinute()
type=int
<keywords>
;TimeMinute();
</keywords>
<content>
    返回分钟为指定的时间。
</content>
<example>
  int m=TimeMinute(TimeCurrent());
</example>
<parameter>
type=datetime
name=time
description=作为秒钟的数字，从00:00 1970 年1月1 日开始。
</parameter>
</function>
<function>
tag=dateandtime_TimeMonth
caption=TimeMonth()
type=int
<keywords>
;TimeMonth();
</keywords>
<content>
     返回月数为指定的时间。
</content>
<example>
  int m=TimeMonth(TimeCurrent());
</example>
<parameter>
type=datetime
name=time
description=作为秒钟的数字，从00:00 1970 年1月1 日开始。
</parameter>
</function>
<function>
tag=dateandtime_TimeSeconds
caption=TimeSeconds()
type=int
<keywords>
;TimeSeconds();
</keywords>
<content>
    返回秒数为指定的时间。
</content>
<example>
  int m=TimeSeconds(TimeCurrent());
</example>
<parameter>
type=datetime
name=time
description=作为秒钟的数字，从00:00 1970 年1月1 日开始。
</parameter>
</function>
<function>
tag=dateandtime_TimeYear
caption=TimeYear()
type=int
<keywords>
;TimeYear();
</keywords>
<content>
    返回年数为指定的时间。返回值的范围可以在1970 到 2037之间。
</content>
<example>
  int y=TimeYear(TimeCurrent());
</example>
<parameter>
type=datetime
name=time
description=作为秒钟的数字，从00:00 1970 年1月1 日开始。
</parameter>
</function>
<function>
tag=dateandtime_Year
caption=Year()
type=int
<keywords>
;Year();
</keywords>
<content>
      返回本年度的年数字，即，服务器的年数时间。<br/>
     注解: 在测试中, 时间格式为最后设定的服务器模式。
</content>
<example>
  // 如果时间范围在2006年1月到4月30日之间，返回。
    if(Year()==2006 &amp;&amp; Month()&lt;5)
    return(0);
</example>
</function>
</group>
<group>
tag=files
caption=File functions
<keywords>
;File functions;
</keywords>
<content>
       一组文件运行函数。<br/><br/>
    三个文件目录(补充指南)放置的地方:
    <ul>
      <li>/HISTORY/&lt;current broker&gt; - FileOpenHistory 函数;</li>
      <li>/EXPERTS/FILES - 常规状况;</li>
      <li>/TESTER/FILES - 专门测试.</li>
    </ul>
    来自其他目录的工作文件禁止。
</content>
<function>
tag=files_FileClose
caption=FileClose()
type=void
<keywords>
;FileClose();
</keywords>
<content>
     用<a href="help://files_FileOpen">FileOpen()</a> 函数打开先前已关闭的文件。
</content>
<example>
  int handle=FileOpen("filename", FILE_CSV|FILE_READ);
  if(handle&gt;0)
    {
     // 运行文件 ...
     FileClose(handle);
    }
</example>
<parameter>
type=int
name=handle
description=用 FileOpen()函数返回句柄。
</parameter>
</function>
<function>
tag=files_FileDelete
caption=FileDelete()
type=void
<keywords>
;FileDelete();
</keywords>
<content>
       删除指定的文件名。获得详细的错误信息, 查看<a href="help://check_GetLastError">GetLastError()</a>函数。<br/>
       如果他们是在 <em>terminal_dir\experts\files</em> 目录
        (<em>terminal_directory\tester\files</em>, 在测试的情况下)或它的补充指南，只删除单个文件。
        
        

        
        
        <pre class="docmql4">
  int lastError;
  FileDelete("my_table.csv");
  lastError=GetLastError();
  if(laseError!=ERR_NOERROR)
    {
     Print(&quot;错误 (&quot;,lastError,&quot;) 删除文件my_table.csv&quot;);
     return(0);
    }
        </pre>
</content>
<example>
  //文件 my_table.csv 将从目录terminal_dir\experts\files directory删除
</example>
<parameter>
type=string
name=filename
description=目录和文件名 。
</parameter>
</function>
<function>
tag=files_FileFlush
caption=FileFlush()
type=void
<keywords>
;FileFlush();
</keywords>
<content>
     将缓存中的数据刷新到磁盘上去 。<br/>
      注解：FileFlush() 函数只有在文件被读或写中显示。<br/>
      所有关闭的文件会自动从储存缓冲器上删除。所以在调用 <a href="help://files_FileClose">FileClose()</a> 函数之前不需要调用 FileFlush() 函数。
</content>
<example>
  int bars_count=Bars;
  int handle=FileOpen(&quot;mydat.csv&quot;,FILE_CSV|FILE_WRITE);
  if(handle&gt;0)
    {
     FileWrite(handle, &quot;#&quot;,&quot;OPEN&quot;,&quot;CLOSE&quot;,&quot;HIGH&quot;,&quot;LOW&quot;);
     for(int i=0;i&lt;bars_count;i++)
       FileWrite(handle, i+1,Open[i],Close[i],High[i], Low[i]);
     FileFlush(handle);
     ...
     for(int i=0;i&lt;bars_count;i++)
       FileWrite(handle, i+1,Open[i],Close[i],High[i], Low[i]);
     FileClose(handle);
    }
</example>
<parameter>
type=int
name=handle
description=用 FileOpen()函数返回的句柄。
</parameter>
</function>
<function>
tag=files_FileIsEnding
caption=FileIsEnding()
type=bool
<keywords>
;FileIsEnding();
</keywords>
<content>
        如果文件指针是在文件的末端,返回逻辑配齐， 否则返回 false。
        获得详细的错误信息, 查看 <a href="help://check_GetLastError">GetLastError()</a> 函数。
       如果文件末端在只读期间到达， <a href="help://check_GetLastError">GetLastError()</a> 函数将返回
        <a href="help://constants_errors">错误</a> ERR_END_OF_FILE (4099)。
</content>
<example>
  if(FileIsEnding(h1))
    {
     FileClose(h1);
     return(false);
    }
</example>
<parameter>
type=int
name=handle
description=用 FileOpen()函数返回的句柄。
</parameter>
</function>
<function>
tag=files_FileIsLineEnding
caption=FileIsLineEnding()
type=bool
<keywords>
;FileIsLineEnding();
</keywords>
<content>
       如果CSV文件指针是在文件的末端,返回逻辑配齐， 否则返回false.
        获得详细的错误信息, 查看 <a href="help://check_GetLastError">GetLastError()</a> 函数。
</content>
<example>
  if(FileIsLineEnding(h1))
    {
     FileClose(h1);
     return(false);
    }
</example>
<parameter>
type=int
name=handle
description=用 FileOpen()函数返回的句柄。
</parameter>
</function>
<function>
tag=files_FileOpen
caption=FileOpen()
type=int
<keywords>
;FileOpen();FILE_BIN;FILE_CSV;FILE_READ;FILE_WRITE;
</keywords>
<content>
为输入或输出信息打开文件。如果函数失败，返回打开文件或-1 。获得详细的错误信息, 查看<a href="help://check_GetLastError">GetLastError()</a> 函数。<br/>
注解: 文件可能只在<em>terminal_directory\experts\files</em> 文件夹(<em>terminal_directory\tester\files</em>
或在它的子文件夹内被打开。<br/>
FILE_BIN和 FILE_CSV 格式不能同时使用。<br/>
如果FILE_WRITE 与FILE_READ 不结合, 被打开的文件长度为零。如果还有一些包含数据的文件， 它们将被删除 。如果需要对现存文件添加数据， 必须使用FILE_READ 和 FILE_WRITE文件组合打开 。<br/>
如果FILE_READ 与FILE_WRITE 不结合, 仅仅会打开现存文件。如果文件不存在, 可以使用FILE_WRITE 创建。
<br/>在一个板块内最多能够同时执行32个文件。
</content>
<example>
  int handle;
  handle=FileOpen(&quot;my_data.csv&quot;,FILE_CSV|FILE_READ,';');
  if(handle&lt;1)
    {
     Print(&quot;未找到 my_data.dat 文件，错误&quot;, GetLastError());
     return(false);
    }
</example>
<parameter>
type=string
name=filename
description=文件名称
</parameter>
<parameter>
type=int
name=mode
description=打开模式。可以是以下的一种或是组合: FILE_BIN, FILE_CSV, FILE_READ, FILE_WRITE。
</parameter>
<parameter>
type=
name=delimiter
description=csv 文件的限定。默认值为';' 符号。
</parameter>
</function>
<function>
tag=files_FileOpenHistory
caption=FileOpenHistory()
type=int
<keywords>
;FileOpenHistory();
</keywords>
<content>
在当前的历史目录(<em>terminal_directory\history\server_name</em>)或在它的子文件内打开文件 。如果函数失败, 返回文件描述部分或-1 。获得详细的错误信息, 查看<a href="help://check_GetLastError">GetLastError()</a>函数。<br/>
注解: 客户终端可能连接到不同经纪公司的服务器。每个经纪公司的历史数据(HST 文件)会存储在<em>terminal_directory\history</em> 相对应的子文件夹内。<br/>
文件在脱机时同样可以打开，不会有数据进入。
</content>
<example>
  int handle=FileOpenHistory(&quot;USDX240.HST&quot;,FILE_BIN|FILE_WRITE);
  if(handle&lt;1)
    {
     Print(&quot;不能创建 USDX240.HST文件&quot;);
     return(false);
    }
  // 运行文件
  // ...
  FileClose(handle);
</example>
<parameter>
type=string
name=filename
description=文件名称
</parameter>
<parameter>
type=int
name=mode
description=打开模式。可以是以下的一种或是组合: FILE_BIN, FILE_CSV, FILE_READ, FILE_WRITE。
</parameter>
<parameter>
type=
name=delimiter
description=csv 文件的限定。默认值为';' 符号。
</parameter>
</function>
<function>
tag=files_FileReadArray
caption=FileReadArray()
type=int
<keywords>
;FileReadArray();
</keywords>
<content>
将二进制文件读取到数组中，返回读取的条数。<br/>
获得详细的错误信息, 查看<a href="help://check_GetLastError">GetLastError()</a> 函数。
</content>
<example>
  int handle;
  double varray[10];
  handle=FileOpen(&quot;filename.dat&quot;, FILE_BIN|FILE_READ);
  if(handle&gt;0)
    {
     FileReadArray(handle, varray, 0, 10);
     FileClose(handle);
    }
</example>
<parameter>
type=int
name=handle
description=用 FileOpen()函数返回的句柄。
</parameter>
<parameter>
type=&amp;
name=<nobr>array[]</nobr>
description=写入的数组。
</parameter>
<parameter>
type=int
name=start
description=在数组中存储的开始点。
</parameter>
<parameter>
type=int
name=count
description=读取多少个对象 。
</parameter>
</function>
<function>
tag=files_FileReadDouble
caption=FileReadDouble()
type=double
<keywords>
;FileReadDouble();DOUBLE_VALUE;FLOAT_VALUE;
</keywords>
<content>
从文件中读取浮点型数据，数字可以是8byte的double型或者是4byte的float型。<br/>
获得错误信息，请查看<a href="help://check_GetLastError">GetLastError()</a> 函数。
</content>
<example>
  int handle;
  double value;
  handle=FileOpen(&quot;mydata.dat&quot;,FILE_BIN);
  if(handle&gt;0)
    {
     value=FileReadDouble(handle,DOUBLE_VALUE);
     FileClose(handle);
    }
</example>
<parameter>
type=int
name=handle
description=用 FileOpen()函数返回的句柄。
</parameter>
<parameter>
type=
name=size
description=数字格式大小，DOUBLE_VALUE(8 bytes) 或者 FLOAT_VALUE(4 bytes)。
</parameter>
</function>
<function>
tag=files_FileReadInteger
caption=FileReadInteger()
type=int
<keywords>
;FileReadInteger();
</keywords>
<content>
       函数从当前二进制文件读取整形型数据，数字可以是1,2,4byte的长度 。如果格式大小不被指定, 系统设法读4 字节的值。获得详细的错误信息, 请查看<a href="help://check_GetLastError">GetLastError()</a> 函数。
</content>
<example>
  int handle;
  int value;
  handle=FileOpen(&quot;mydata.dat&quot;, FILE_BIN|FILE_READ);
  if(handle&gt;0)
    {
     value=FileReadInteger(h1,2);
     FileClose(handle);
    }
</example>
<parameter>
type=int
name=handle
description=用 FileOpen()函数返回的句柄。
</parameter>
<parameter>
type=
name=size
description=数字格式大小，CHAR_VALUE(1 byte), SHORT_VALUE(2 bytes) 或者 LONG_VALUE(4 bytes)。
</parameter>
</function>
<function>
tag=files_FileReadNumber
caption=FileReadNumber()
type=double
<keywords>
;FileReadNumber();
</keywords>
<content>
从当前文件位置在符号之前读取数字。只能为CSV 文件。<br/>
获得详细的错误信息, 查看 <a href="help://check_GetLastError">GetLastError()</a>函数。
</content>
<example>
  int handle;
  int value;
  handle=FileOpen(&quot;filename.csv&quot;, FILE_CSV, ';');
  if(handle&gt;0)
    {
     value=FileReadNumber(handle);
     FileClose(handle);
    }
</example>
<parameter>
type=int
name=handle
description=用 FileOpen()函数返回的句柄。
</parameter>
</function>
<function>
tag=files_FileReadString
caption=FileReadString()
type=string
<keywords>
;FileReadString();
</keywords>
<content>
函数从当前文件位置读取字串符。适用于CSV 和二进制文件。在文本文件中字串符在符号之前被读取。对于二进制文件, 被测量的计数将读取字串符。获得详细的错误信息, 查看<a href="help://check_GetLastError">GetLastError()</a>函数。
</content>
<example>
  int handle;
  string str;
  handle=FileOpen(&quot;filename.csv&quot;, FILE_CSV|FILE_READ);
  if(handle&gt;0)
    {
     str=FileReadString(handle);
     FileClose(handle);
    }
</example>
<parameter>
type=int
name=handle
description=用FileOpen()返回的句柄。
</parameter>
<parameter>
type=
name=length
description=读取字符串长度 。
</parameter>
</function>
<function>
tag=files_FileSeek
caption=FileSeek()
type=bool
<keywords>
;FileSeek();SEEK_CUR;SEEK_SET;SEEK_END;
</keywords>
<content>
在字节上函数移动文件指针是垂距的，从开始的一个新的位置指向末端或者当前文件位置。 接下来读取或写入放置在一个新位置。<br/>
如果文件指针成功地被移动了，函数返回 TRUEe， 否则，它返回 FALSE.
获得详细的错误信息，查看 <a href="help://check_GetLastError">GetLastError()</a> 函数。
</content>
<example>
  int handle=FileOpen(&quot;filename.csv&quot;, FILE_CSV|FILE_READ|FILE_WRITE, ';');
  if(handle&gt;0)
    {
     FileSeek(handle, 0, SEEK_END);
     //----在文件末端添加数据
     FileWrite(handle, data1, data2);
     FileClose(handle);
     handle=0;
    }
</example>
<parameter>
type=int
name=handle
description=用 FileOpen()函数返回的句柄。
</parameter>
<parameter>
type=int
name=offset
description=设置的原点。
</parameter>
<parameter>
type=int
name=origin
description=最初的位置。 值可以是以下任意常数:<br/>SEEK_CUR - 当前位置,<br/>SEEK_SET - 开始位置<br/>SEEK_END - 结束位置。
</parameter>
</function>
<function>
tag=files_FileSize
caption=FileSize()
type=int
<keywords>
;FileSize();
</keywords>
<content>
函数返回文件大小字节。获得详细的错误信息，查看<a href="help://check_GetLastError">GetLastError()</a> 函数。
</content>
<example>
  int handle;
  int size;
  handle=FileOpen(&quot;my_table.dat&quot;, FILE_BIN|FILE_READ);
  if(handle&gt;0)
    {
     size=FileSize(handle);
     Print(&quot;my_table.dat 大小为 &quot;, 大小 &quot; bytes&quot;);
     FileClose(handle);
    }
</example>
<parameter>
type=int
name=handle
description=用 FileOpen()函数返回的句柄。
</parameter>
</function>
<function>
tag=files_FileTell
caption=FileTell()
type=int
<keywords>
;FileTell();
</keywords>
<content>
        返回文件指针的当前位置。获得详细的错误信息，查看<a href="help://check_GetLastError">GetLastError()</a> 函数。
</content>
<example>
  int handle;
  int pos;
  handle=FileOpen(&quot;my_table.dat&quot;, FILE_BIN|FILE_READ);
  // 读取数据
  pos=FileTell(handle);
  Print(&quot;current position is &quot;, pos);
</example>
<parameter>
type=int
name=handle
description=用 FileOpen()函数返回的句柄。
</parameter>
</function>
<function>
tag=files_FileWrite
caption=FileWrite()
type=int
<keywords>
;FileWrite();
</keywords>
<content>
该函数的目的是便于书写的数据转换为CSV格式文件，自动插入限定符。在写入文件后，每行的尾端将会添加&quot;\r\n&quot; 符号。数字将会被转变成文本(查看<a href="help://common_Print">Print()</a> 函数)。<br/>
如果生成错误，返回书写字或负值的计数。<br/>
获得详细的错误信息，查看<a href="help://check_GetLastError">GetLastError()</a> 函数。
</content>
<example>
  int handle;
  datetime orderOpen=OrderOpenTime();
  handle=FileOpen(&quot;filename&quot;, FILE_CSV|FILE_WRITE, ';');
  if(handle&gt;0)
    {
     FileWrite(handle, Close[0], Open[0], High[0], Low[0], TimeToStr(orderOpen));
     FileClose(handle);
    }
</example>
<parameter>
type=int
name=handle
description=用 FileOpen()函数返回的句柄。
</parameter>
<parameter>
type=...
name=
description=写入的数据，由逗号分离。 它可以是63个参量。当他们作为整数时，int数据和双重类型自动地被转换成串，但不自动转换颜色、日期-时间和bool typesare和写出的文件。数组无法作为参量通过， 他们可能是输出的元素。
</parameter>
</function>
<function>
tag=files_FileWriteArray
caption=FileWriteArray()
type=int
<keywords>
;FileWriteArray();
</keywords>
<content>
函数给一个二进制文件写入数组。一些int、bool、日期-时间和颜色类型书面元素作为4字节整数。 一些双重类型书面元素，作为8字节浮动小数点数字。一些字串符类型将自动地在每串末尾添加符号 &quot;\r\n&quot; 。<br/>
如果错误生成，返回书写字或负值的计数。 获得详细的错误信息，查看 <a href="help://check_GetLastError">GetLastError()</a>函数。
</content>
<example>
  int handle;
  double BarOpenValues[10];
  //  复制前十个柱到数组
  for(int i=0;i&lt;10; i++)
    BarOpenValues[i]=Open[i];
  // 写入数组到文件
  handle=FileOpen(&quot;mydata.dat&quot;, FILE_BIN|FILE_WRITE);
  if(handle&gt;0)
    {
     FileWriteArray(handle, BarOpenValues, 3, 7); // 写入最后7个元素
     FileClose(handle);
    }
</example>
<parameter>
type=int
name=handle
description=用 FileOpen()函数返回的句柄。
</parameter>
<parameter>
type=object
name=<nobr>array[]</nobr>
description=写数组。
</parameter>
<parameter>
type=int
name=start
description=在数组内(第一个书面元素数字)开始索引。
</parameter>
<parameter>
type=int
name=count
description=书写字的计数。
</parameter>
</function>
<function>
tag=files_FileWriteDouble
caption=FileWriteDouble()
type=int
<keywords>
;FileWriteDouble();
</keywords>
<content>
函数给一个二进制文件以浮动小数点写入双重值。 如果格式指定为FLOAT_VALUE，值将作为4字节浮动小数点数字写入 (的浮游物类型)。否则，它以8字节浮动小数点格式将被写入(双重类型)。<br/>
如果错误生成，返回实际上书面字节数或负值。<br/>
获得详细的错误信息, 查看 <a href="help://check_GetLastError">GetLastError()</a> 函数。
</content>
<example>
  int handle;
  double var1=0.345;
  handle=FileOpen(&quot;mydata.dat&quot;, FILE_BIN|FILE_WRITE);
  if(handle&lt;1)
    {
     Print(&quot;不能打开错误文件-&quot;,GetLastError());
     return(0);
    }
  FileWriteDouble(h1, var1, DOUBLE_VALUE);
  //...
  FileClose(handle);
</example>
<parameter>
type=int
name=handle
description=用 FileOpen()函数返回的句柄。
</parameter>
<parameter>
type=double
name=value
description=双精度值。
</parameter>
<parameter>
type=
name=size
description=选择格式。可以是以下的任意值:<br/>          DOUBLE_VALUE (8 字节，默认值)<br/>          FLOAT_VALUE (4 字节)。
</parameter>
</function>
<function>
tag=files_FileWriteInteger
caption=FileWriteInteger()
type=int
<keywords>
;FileWriteInteger();
</keywords>
<content>
函数给一个二进制文件写入整数值。
 如果大小是SHORT_VALUE，值将作为2字节整数(短的类型)被写入。 如果大小是CHAR_VALUE，值将作为1字节整数(炭灰类型)写入，并且，如果大小是LONG_VALUE， 值将作为4字节整数(长的int类型)写入。 <br/>
如果错误生成，返回实际上书面字节数或负值。<br/>
获得详细的错误信息, 查看 <a href="help://check_GetLastError">GetLastError()</a> 函数。
</content>
<example>
  int handle;
  int value=10;
  handle=FileOpen(&quot;filename.dat&quot;, FILE_BIN|FILE_WRITE);
  if(handle&lt;1)
    {
     Print(&quot;不能打开错误文件-&quot;,GetLastError());
     return(0);
    }
  FileWriteInteger(handle, value, SHORT_VALUE);
  //...
  FileClose(handle);
</example>
<parameter>
type=int
name=handle
description=用 FileOpen()函数返回的句柄。
</parameter>
<parameter>
type=int
name=value
description=写入值
</parameter>
<parameter>
type=
name=size
description=选择格式。可以是以下任意值:<br/>CHAR_VALUE (1 字节),<br/>SHORT_VALUE (2 字节),<br/>LONG_VALUE (4 字节，默认值)。
</parameter>
</function>
<function>
tag=files_FileWriteString
caption=FileWriteString()
type=int
<keywords>
;FileWriteString();
</keywords>
<content>
从当前文件位置函数写入一个二进制文件字串符。 <br/>
如果错误生成，返回实际上书面字节数或负值。<br/>
获得详细的错误信息,查看<a href="help://check_GetLastError">GetLastError()</a> 函数。
</content>
<example>
  int handle;
  string str=&quot;some string&quot;;
  handle=FileOpen(&quot;filename.bin&quot;, FILE_BIN|FILE_WRITE);
    if(handle&lt;1)
    {
     Print(&quot;不能打开错误文件-&quot;,GetLastError());
     return(0);
    }
  FileWriteString(h1, str, 8);
  FileClose(handle);
</example>
<parameter>
type=int
name=handle
description=用 FileOpen()函数返回的句柄。
</parameter>
<parameter>
type=string
name=value
description=写入字串符。
</parameter>
<parameter>
type=int
name=length
description=写的字串符的长度。如果字串符长度超出被测量的值，它将被削减。 如果它较短，它将由二进制0s延伸由特定长度决定。
</parameter>
</function>
</group>
<group>
tag=globals
caption=Global variables
<keywords>
;Global variables;
</keywords>
<content>
        和整体变量一起使用的一组函数。<br/><br/>
    客户端整体变量不应该与MQL4程序中的<a href="help://basis_variables_global">变量</a>混合。<br/><br/>
    最后访问的整体变量可以在客户端内保存4个星期，随后将被自动删除。
   对于整体变量的范文不仅仅是新值的<a href="help://globals_GlobalVariableSet">设定</a>，同样可以对整体变量进行<a href="help://globals_GlobalVariableGet">读取</a>。<br/><br/>
    在客户端从 MQL4 程序开启的客户端整体变量非常相似。
</content>
<function>
tag=globals_GlobalVariableCheck
caption=GlobalVariableCheck()
type=bool
<keywords>
;GlobalVariableCheck();
</keywords>
<content>
如果整体变量存在，返回TRUE.否则，返回FALSE。 要获得详细的错误信息，查看<a href="help://check_GetLastError">GetLastError()</a> 函数。
</content>
<example>
  // 检查先前使用变量
  if(!GlobalVariableCheck(&quot;g1&quot;))
    GlobalVariableSet(&quot;g1&quot;,1);
</example>
<parameter>
type=string
name=name
description=整体变量名称。
</parameter>
</function>
<function>
tag=globals_GlobalVariableDel
caption=GlobalVariableDel()
type=bool
<keywords>
;GlobalVariableDel();
</keywords>
<content>
删除整体变量。 如果函数成功，返回值将是真实的，否则，它将是错误的。 要获得详细的错误信息，查看<a href="help://check_GetLastError">GetLastError()</a> 函数。
</content>
<example>
  // 删除名称为  &quot;gvar_1&quot;的整体变量(&quot;gvar_1&quot;);
</example>
<parameter>
type=string
name=name
description=整体变量名称。
</parameter>
</function>
<function>
tag=globals_GlobalVariableGet
caption=GlobalVariableGet()
type=double
<keywords>
;GlobalVariableGet();
</keywords>
<content>
如果错误生成，返回值为现有整体变量或0。 获得详细的错误信息, 查看<a href="help://check_GetLastError">GetLastError()</a>函数。
</content>
<example>
  double v1=GlobalVariableGet(&quot;g1&quot;);
  //---- 检查函数调用结果
  if(GetLastError()!=0) return(false);
  //---- 继续程序
</example>
<parameter>
type=string
name=name
description=整体变量名称。
</parameter>
</function>
<function>
tag=globals_GlobalVariableName
caption=GlobalVariableName()
type=string
<keywords>
;GlobalVariableName();
</keywords>
<content>
由函数索引在整体变量名单返回一个整体变量的名字。 获得详细的错误信息, 查看 <a href="help://check_GetLastError">GetLastError()</a>函数。
</content>
<example>
  int    var_total=GlobalVariablesTotal();
  string name;
  for(int i=0;i&lt;var_total;i++)
    {
     name=GlobalVariableName(i);
     Print(i,&quot;: 整体变量名称 - &quot;,name);
    }
</example>
<parameter>
type=int
name=index
description=索引在整体变量名单。 它必须超出或相等于0或少于  <a href="help://globals_GlobalVariablesTotal">GlobalVariablesTotal()</a>。
</parameter>
</function>
<function>
tag=globals_GlobalVariableSet
caption=GlobalVariableSet()
type=datetime
<keywords>
;GlobalVariableSet();
</keywords>
<content>
设置整体变量的新的价格值。 如果它不存在，系统创造一个新的整体变量。 如果函数成功，返回值将是最后存取时间。 否则，返回值将是0。获得详细的错误信息,查看 <a href="help://check_GetLastError">GetLastError()</a> 函数。
</content>
<example>
  //---- 尝试设定新值
  if(GlobalVariableSet(&quot;BarsTotal&quot;,Bars)==0)
    return(false);
  //---- 继续程序
</example>
<parameter>
type=string
name=name
description=整体变量名称。
</parameter>
<parameter>
type=double
name=value
description=新的数值。
</parameter>
</function>
<function>
tag=globals_GlobalVariableSetOnCondition
caption=GlobalVariableSetOnCondition()
type=bool
<keywords>
;GlobalVariableSetOnCondition();
</keywords>
<content>
如果当前值均等对第三参量<i>check_value</i>，设置现有的整体变量的新值。 如果没有整体变量，函数将生成 <a href="help://constants_errors">错误</a> ERR_GLOBAL_VARIABLE_NOT_FOUND (4058) 并且返回 FALSE。
当成功地执行，函数返回 TRUE，否则，它返回 FALSE。 获得详细的错误信息, 查看 <a href="help://check_GetLastError">GetLastError()</a> 函数。<br/>
如果整体变量的当前值与<i>check_value</i>不同, 函数将返回FALSE。<br/>
函数将为整体变量提供自动通道，这就是为什么在一个客户终端内几个智能交易可以同时运行的原因。
</content>
<example>
  int init()
    {
     //---- 创建整体变量
     GlobalVariableSet(&quot;DATAFILE_SEM&quot;,0);
     //...
    }
  
  int start()
    {
     //---- 尝试锁住源代码
     while(!IsStopped())
       {
        //---- 锁住
        if(GlobalVariableSetOnCondition(&quot;DATAFILE_SEM&quot;,1,0)==true)  break;
        //---- 可以删除变量吗?
        if(GetLastError()==ERR_GLOBAL_VARIABLE_NOT_FOUND) return(0);
        //---- 睡眠状态
        Sleep(500);
       }
     //---- 源代码被锁
     // ...做同样工作
     //----未锁源代码
     GlobalVariableSet(&quot;DATAFILE_SEM&quot;,0);
    }
</example>
<parameter>
type=string
name=name
description=整体变量名称。
</parameter>
<parameter>
type=double
name=value
description=新值。
</parameter>
<parameter>
type=double
name=check_value
description=值与当前整体变量值比较。
</parameter>
</function>
<function>
tag=globals_GlobalVariablesDeleteAll
caption=GlobalVariablesDeleteAll()
type=int
<keywords>
;GlobalVariablesDeleteAll();
</keywords>
<content>
    删除整体变量。 如果命名前缀没有指定，所有整体变量将被删除。 否则，仅有那些可变物将被删除。从指定的前缀开始。 函数返回被删除的可变物计数。
</content>
<example>
Print(GlobalVariablesDeleteAll(&quot;test_&quot;),&quot; 整体删除测试&quot;);
</example>
<parameter>
type=
name=prefix_name
description=将被删除的整体变量的命名前缀。
</parameter>
</function>
<function>
tag=globals_GlobalVariablesTotal
caption=GlobalVariablesTotal()
type=int
<keywords>
;GlobalVariablesTotal();
</keywords>
<content>
      函数返回整体变量总值。
</content>
<example>
Print(GlobalVariablesTotal(),&quot;探测整体变量&quot;);
</example>
</function>
</group>
<group>
tag=math
caption=Math & Trig
<keywords>
;Math &; Trig;
</keywords>
<content>
        一组数学和三角设置函数。

</content>
<function>
tag=math_MathAbs
caption=MathAbs()
type=double
<keywords>
;MathAbs();
</keywords>
<content>
    返回绝对值(模数)的指定的数值。
</content>
<example>
  double dx=-3.141593, dy;
  // calc MathAbs
  dy=MathAbs(dx);
  Print("The absolute value of ",dx," is ",dy);
  // 输入数据:  -3.141593的绝对值为3.141593
</example>
<parameter>
type=double
name=value
description=数字值.
</parameter>
</function>
<function>
tag=math_MathArccos
caption=MathArccos()
type=double
<keywords>
;MathArccos();
</keywords>
<content>
MathArccos函数在范围0之内返回<i>x</i> 反余弦到π&#x3C0; (在弧度上)。 如果<i>x</i>少于-1是或超出1， MathArccos返回FALSE。
</content>
<example>
  double x=0.32696, y;
  y=asin(x);
  Print("正弦",x," = ",y);
  y=acos(x);
  Print("余弦 ",x," = ",y);
  //输入数据: 正弦 0.326960=0.333085
  //输入数据:余弦 0.326960=1.237711
</example>
<parameter>
type=double
name=x
description=在-1和1范围的值反余弦将被计算。
</parameter>
</function>
<function>
tag=math_MathArcsin
caption=MathArcsin()
type=double
<keywords>
;MathArcsin();
</keywords>
<content>
在 -&#x3C0;/2 到 &#x3C0;/2 范围内函数MathArcsin正弦 <i>x</i> 。
如果<i>x</i> 小于 -1 或超过1, 正弦返回NaN 。
</content>
<example>
  double x=0.32696, y;
  y=MathArcsin(x);
  Print("正弦",x," = ",y);
  y=acos(x);
  Print("余弦 ",x," = ",y);
  //输入数据:正弦 0.326960=0.333085
  //输入数据: 余弦 0.326960=1.237711
</example>
<parameter>
type=double
name=x
description=计算正弦的值。
</parameter>
</function>
<function>
tag=math_MathArctan
caption=MathArctan()
type=double
<keywords>
;MathArctan();
</keywords>
<content>
函数 MathArctan 返回  <i>x</i>的正切线值。 如果<i>x</i>为0, MathArctan 返回0。
MathArctan 返回值必须在-&#x3C0;/2 to &#x3C0;/2 弧度范围内。
</content>
<example>
  double x=-862.42, y;
  y=MathArctan(x);
  Print("正切线 ",x," is ",y);
  //输入数据:正切线 -862.42 is -1.5696
</example>
<parameter>
type=double
name=x
description=表示正切线的数字。
</parameter>
</function>
<function>
tag=math_MathCeil
caption=MathCeil()
type=double
<keywords>
;MathCeil();
</keywords>
<content>
 MathCeil函数返回一个最小超过或等于<i>x</i>的整数值。
</content>
<example>
  double y;
  y=MathCeil(2.8);
  Print("上限 2.8 is ",y);
  y=MathCeil(-2.8);
  Print("上限 -2.8 is ",y);
  /*输入数据:
    2.8 的上限为3
     -2.8 的上限为-2*/
</example>
<parameter>
type=double
name=x
description=数值。
</parameter>
</function>
<function>
tag=math_MathCos
caption=MathCos()
type=double
<keywords>
;MathCos();
</keywords>
<content>
     返回指定的余弦角。
</content>
<example>
  double pi=3.1415926535;
  double x, y;
  x=pi/2;
  y=MathSin(x);
  Print("正弦(",x,") = ",y);
  y=MathCos(x);
  Print("余弦(",x,") = ",y);
  //输入数据: 正弦(1.5708)=1
  //        余弦(1.5708)=0
</example>
<parameter>
type=double
name=value
description=角度测量。
</parameter>
</function>
<function>
tag=math_MathExp
caption=MathExp()
type=double
<keywords>
;MathExp();
</keywords>
<content>
返回<b>e</b>的值升级到<i>d</i>的乘方。
在溢出的情况下，函数返回INF (无限定)，并且在底线返回0。
</content>
<example>
  double x=2.302585093,y;
  y=MathExp(x);
  Print("MathExp(",x,") = ",y);
  //输入数据: MathExp(2.3026)=10
</example>
<parameter>
type=double
name=d
description=数字指定乘方。
</parameter>
</function>
<function>
tag=math_MathFloor
caption=MathFloor()
type=double
<keywords>
;MathFloor();
</keywords>
<content>
MathFloor函数返回一个最大小于或等于<i>x</i>的整数值。
</content>
<example>
  double y;
  y=MathFloor(2.8);
  Print("下限 2.8 is ",y);
  y=MathFloor(-2.8);
  Print("下限 -2.8 is ",y);
  /*输入数据:
    下限2.8 为 2
   下限 -2.8为-3*/
</example>
<parameter>
type=double
name=x
description=数值。
</parameter>
</function>
<function>
tag=math_MathLog
caption=MathLog()
type=double
<keywords>
;MathLog();
</keywords>
<content>
如果成功，MathLog函数返回 <i>x</i> 的自然数。
如果<i>x</i> 是负值，这些函数返回NaN (不确定值)。
如果<i>x</i> 是0， 他们返回 INF (无限定)。
</content>
<example>
  double x=9000.0,y;
  y=MathLog(x);
  Print("MathLog(",x,") = ", y);
  //输入数据: MathLog(9000)=9.10498
</example>
<parameter>
type=double
name=x
description=发现的自然数值。
</parameter>
</function>
<function>
tag=math_MathMax
caption=MathMax()
type=double
<keywords>
;MathMax();
</keywords>
<content>
      返回两个数字值的最大值。
</content>
<example>
  double result=MathMax(1.08,Bid);
</example>
<parameter>
type=double
name=value1
description=第一个数字值。
</parameter>
<parameter>
type=double
name=value2
description=第二个数字值。
</parameter>
</function>
<function>
tag=math_MathMin
caption=MathMin()
type=double
<keywords>
;MathMin();
</keywords>
<content>
     返回两个数字值的最小值。
</content>
<example>
  double result=MathMin(1.08,Ask);
</example>
<parameter>
type=double
name=value1
description=第一个数字值。
</parameter>
<parameter>
type=double
name=value2
description=第二个数字值。
</parameter>
</function>
<function>
tag=math_MathMod
caption=MathMod()
type=double
<keywords>
;MathMod();
</keywords>
<content>
      此函数返回两位数除法的保留浮点。<br/><br/>
      MathMod函数计算<i>x&nbsp;/&nbsp;y&nbsp;</i>的保留浮点<i>f&nbsp;</i>，这样<i>x&nbsp;=&nbsp;i&nbsp;*&nbsp;y&nbsp;+&nbsp;f&nbsp;</i>，<i>i&nbsp;</i> 是整数， <i>f&nbsp;</i>与 <i>x</i>是一样的标志，
      并且 <i>f&nbsp;</i>的绝对值小于<i>y</i>的绝对值。
</content>
<example>
  double x=-10.0,y=3.0,z;
  z=MathMod(x,y);
  Print("保留数 ",x," / ",y," 为 ",z);
  //输入数据:  -10 / 3 的保留数为 -1
</example>
<parameter>
type=double
name=value
description=被除值。
</parameter>
<parameter>
type=double
name=value2
description=除值。
</parameter>
</function>
<function>
tag=math_MathPow
caption=MathPow()
type=double
<keywords>
;MathPow();
</keywords>
<content>
     返回上升的基数指定的乘方(方次数值)。
</content>
<example>
  double x=2.0,y=3.0,z;
  z=MathPow(x,y);
  Printf(x," 的",y,"次乘方为", z);
  //输入数据: 2 的 3次乘方为8
</example>
<parameter>
type=double
name=base
description=基数。
</parameter>
<parameter>
type=double
name=exponent
description=方次数值。
</parameter>
</function>
<function>
tag=math_MathRand
caption=MathRand()
type=int
<keywords>
;MathRand();
</keywords>
<content>
在0到32767的范围内MathRand函数返回一个随机整数。
在调用MathRand之前，需要使用<a href="help://math_MathSrand">MathSrand</a> 函数找寻随机整数。
</content>
<example>
  MathSrand(TimeLocal());
  // 显示 10个数字。
  for(int i=0;i&lt;10;i++ )
    Print("随机值  ", MathRand());
</example>
</function>
<function>
tag=math_MathRound
caption=MathRound()
type=double
<keywords>
;MathRound();
</keywords>
<content>
     返回最近的四舍五入整数值。
</content>
<example>
  double y=MathRound(2.8);
  Print("2.8的四舍五入值为 ",y);
  y=MathRound(2.4);
  Print(" -2.4 的四舍五入值为 ",y);
  //输入数据:  2.8的四舍五入值为 3
  //         -2.4 的四舍五入值为 -2
</example>
<parameter>
type=double
name=value
description=四舍五入值。
</parameter>
</function>
<function>
tag=math_MathSin
caption=MathSin()
type=double
<keywords>
;MathSin();
</keywords>
<content>
      返回指定角的正弦。
</content>
<example>
  double pi=3.1415926535;
  double x, y;
  x=pi/2;
  y=MathSin(x);
  Print("MathSin(",x,") = ",y);
  y=MathCos(x);
  Print("MathCos(",x,") = ",y);
  //输入数据: MathSin(1.5708)=1
  //        MathCos(1.5708)=0
</example>
<parameter>
type=double
name=value
description=弧度角测量。
</parameter>
</function>
<function>
tag=math_MathSqrt
caption=MathSqrt()
type=double
<keywords>
;MathSqrt();
</keywords>
<content>
MathSqrt函数返回<i>x</i>的平方根。
如果<i>x</i>为负值，MathSqrt返回不确定值(与NaN相同)。
</content>
<example>
  double question=45.35, answer;
  answer=MathSqrt(question);
  if(question&lt;0)
    Print(&quot;错误: MathSqrt 返回&quot;,答案,&quot; 答案&quot;);
  else
    Print("",问题,"的平方根为 ", 答案);
  //输入数据: 45.35 的平方根为6.73
</example>
<parameter>
type=double
name=x
description=否定数值。
</parameter>
</function>
<function>
tag=math_MathSrand
caption=MathSrand()
type=void
<keywords>
;MathSrand();
</keywords>
<content>
MathSrand() 函数设置一系列随机整数的开始点。
重新初始化生成，使用1 作为自变数。找到的其他数值设置一个随机开始点。
<a href="help://math_MathRand">MathRand</a> 检测出生成的随机数字。
调用 MathRand之前， 任何 MathSrand的生成调用需要按照找寻通过1的顺序调用MathSrand 。
</content>
<example>
  MathSrand(TimeLocal());
  // 显示10 数字。
  for(int i=0;i&lt;10;i++ )
    Print("随机值 ", MathRand());
</example>
<parameter>
type=int
name=seed
description=找寻生成的随机数字。
</parameter>
</function>
<function>
tag=math_MathTan
caption=MathTan()
type=double
<keywords>
;MathTan();
</keywords>
<content>
MathTan 返回 <i>x</i>的正切线。如果 <i>x</i> 大于等于263或者小于等于 -263，
结果错误丢失，函数返回不确定值(与NaN相同)。
</content>
<example>
  double pi=3.1415926535;
  double x,y;
  x=MathTan(pi/4);
  Print("MathTan(",pi/4," = ",x);
  //输入数据: MathTan(0.7856)=1
</example>
<parameter>
type=double
name=x
description=弧度角
</parameter>
</function>
</group>
<group>
tag=objects
caption=Object functions
<keywords>
;Object functions;
</keywords>
<content>
        对于当前图表有关的图表物件的一组函数。

</content>
<function>
tag=objects_ObjectCreate
caption=ObjectCreate()
type=bool
<keywords>
;ObjectCreate();
</keywords>
<content>
物件创建的指定名称、类型和最初坐标的指定窗口。计数坐标与物件的关联可以是从1到3物件类型。 如果函数成功，返回值将是 TRUE，否则，它将是 FALSE。
获得详细的错误信息, 查看 <a href="help://check_GetLastError">GetLastError()</a>函数。
OBJ_LABEL类型的物件忽略坐标。 使用<a href="help://objects_ObjectSet">ObjectSet()</a> 设定 <a href="help://constants_objects_properties">OBJPROP_XDISTANCE</a> 和
<a href="help://constants_objects_properties">OBJPROP_YDISTANCE</a> 属性。<br/>
注解: 子窗口图表(如果子窗口带有指标)编号从1 开始。主窗口的存在的索引为零。<br/>
必须通过的坐标： 时间和价格。 例如， OBJ_VLINE只物件需要时间，但必须通过价格(任何值)。
</content>
<example>
  // 新文本物件
  if(!ObjectCreate(&quot;text_object&quot;, OBJ_TEXT, 0, D'2004.02.20 12:30', 1.0045))
    {
     Print(&quot;错误:不能创建文本! 代码 #&quot;,GetLastError());
     return(0);
    }
  // 新文本标签
  if(!ObjectCreate(&quot;label_object&quot;, OBJ_LABEL, 0, 0, 0))
    {
     Print(&quot;错误:不能创建文本! 代码 #&quot;,GetLastError());
     return(0);
    }
  ObjectSet(&quot;label_object&quot;, OBJPROP_XDISTANCE, 200);
  ObjectSet(&quot;label_object&quot;, OBJPROP_YDISTANCE, 100);
</example>
<parameter>
type=string
name=name
description=物件唯一名称。
</parameter>
<parameter>
type=int
name=type
description=物件类型。它可以<a href="help://constants_objects">是物件类型列举</a>的任意值。
</parameter>
<parameter>
type=int
name=window
description=件窗口将增加的索引。窗口索引必须多于或等于0并且小于 <a href="help://windows_WindowsTotal">WindowsTotal()</a>。
</parameter>
<parameter>
type=datetime
name=time1
description=第一点的时间部分。
</parameter>
<parameter>
type=double
name=price1
description=第一点的值部分。
</parameter>
<parameter>
type=
name=time2
description=第二点的时间部分。
</parameter>
<parameter>
type=
name=price2
description=第二点的值部分。
</parameter>
<parameter>
type=
name=time3
description=第三点的时间部分。
</parameter>
<parameter>
type=
name=price3
description=第三点的值部分。
</parameter>
</function>
<function>
tag=objects_ObjectDelete
caption=ObjectDelete()
type=bool
<keywords>
;ObjectDelete();
</keywords>
<content>
删除物件已有的指定名称。 如果函数成功，返回值将是TRUE，否则，它将是 FALSE。<br/>
获得详细的错误信息, 查看<a href="help://check_GetLastError">GetLastError()</a> 函数。
</content>
<example>
ObjectDelete(&quot;text_object&quot;);
</example>
<parameter>
type=string
name=name
description=被删除的物件名称。
</parameter>
</function>
<function>
tag=objects_ObjectDescription
caption=ObjectDescription()
type=string
<keywords>
;ObjectDescription();
</keywords>
<content>
返回物件描述。 对于OBJ_TEXT和OBJ_LABEL类型物件，这些物件文本将返回。<br/>
获得详细的错误信息，查看<a href="help://check_GetLastError">GetLastError()</a> 函数。
<br/><b>参见</b> <a href="help://objects_ObjectSetText">ObjectSetText()</a> 函数。
</content>
<example>
  //  对于文件写下图表物件
  int    handle, total;
  string obj_name,fname;
  // 文件名称
  fname="objlist_"+Symbol();
  handle=FileOpen(fname,FILE_CSV|FILE_WRITE);
  if(handle!=false)
    {
     total=ObjectsTotal();
     for(int i=-;i&lt;total;i++)
       {
        obj_name=ObjectName(i);
        FileWrite(handle,"Object "+obj_name+" description= "+ObjectDescription(obj_name));
       }
     FileClose(handle);
    }
</example>
<parameter>
type=string
name=name
description=物件名称。
</parameter>
</function>
<function>
tag=objects_ObjectFind
caption=ObjectFind()
type=int
<keywords>
;ObjectFind();
</keywords>
<content>
查找指定的物件名称。窗口的索引包含所找到的物件。如果它失败, 返回值将是-1 。
获得详细的错误信息, 查看 <a href="help://check_GetLastError">GetLastError()</a> 函数。
子窗口图表(如果子窗口带有指标)编号从1 开始。主窗口的索引为零。
</content>
<example>
if(ObjectFind(&quot;line_object2&quot;)!=win_idx) return(0);
</example>
<parameter>
type=string
name=name
description=查找的物件名称。
</parameter>
</function>
<function>
tag=objects_ObjectGet
caption=ObjectGet()
type=double
<keywords>
;ObjectGet();
</keywords>
<content>
函数返回指定物件的属性。 
检查错误，查看 <a href="help://check_GetLastError">GetLastError()</a> 函数。
<br/><b>参见</b> <a href="help://objects_ObjectSet">ObjectSet()</a>函数。
</content>
<example>
color oldColor=ObjectGet(&quot;hline12&quot;, OBJPROP_COLOR);
</example>
<parameter>
type=string
name=name
description=物件名称。
</parameter>
<parameter>
type=int
name=index
description=物件属性索引。它可以是<a href="help://constants_objects_properties">物件属性列举值</a>的任意。
</parameter>
</function>
<function>
tag=objects_ObjectGetFiboDescription
caption=ObjectGetFiboDescription()
type=string
<keywords>
;ObjectGetFiboDescription();
</keywords>
<content>
函数返回对斐波纳契物件的平实描述。相当数量斐波纳契水平取决于<a href="help://constants_objects">物件类型</a>。 最大斐波纳契水平是32。<br/>
获得详细的错误信息,查看 <a href="help://check_GetLastError">GetLastError() 函数</a>。
<br/><b>参见</b> <a href="help://objects_ObjectSetFiboDescription">ObjectSetFiboDescription()</a> 函数。
</content>
<example>
#include &lt;stdlib.mqh&gt;
  ...
  string text;
  for(int i=0;i&lt;32;i++)
    {
     text=ObjectGetFiboDescription(MyObjectName,i);
     //---- 检查物件少于32水平线
     if(GetLastError()!=ERR_NO_ERROR) break;
     Print(MyObjectName,&quot;水平: &quot;,i,&quot; description: &quot;,text);
    }
</example>
<parameter>
type=string
name=name
description=斐波纳契物件名称。
</parameter>
<parameter>
type=int
name=index
description=斐波纳契索引水平(0-31)。
</parameter>
</function>
<function>
tag=objects_ObjectGetShiftByValue
caption=ObjectGetShiftByValue()
type=int
<keywords>
;ObjectGetShiftByValue();
</keywords>
<content>
函数计算并返回索引柱（移动当前相关的柱）给出的值。 索引柱由第一和第二坐标应用线性方程计算。 适用于趋势线和相似的物件。获得详细的错误信息, 查看  <a href="help://check_GetLastError">GetLastError()</a> 函数。
<br/><b>参见</b> <a href="help://objects_ObjectGetValueByShift">ObjectGetValueByShift()</a> 函数。
</content>
<example>
  int shift=ObjectGetShiftByValue(&quot;MyTrendLine#123&quot;, 1.34);
</example>
<parameter>
type=string
name=name
description=物件名称。
</parameter>
<parameter>
type=double
name=value
description=价格值。
</parameter>
</function>
<function>
tag=objects_ObjectGetValueByShift
caption=ObjectGetValueByShift()
type=double
<keywords>
;ObjectGetValueByShift();
</keywords>
<content>
函数计算并返回指定柱的值(转移当前相关的柱)。索引柱由第一和第二坐标应用线性方程计算。 适用于趋势线和相似的物件。
获得详细的错误信息, 查看 <a href="help://check_GetLastError">GetLastError()</a> 函数。
<br/><b>参见</b> <a href="help://objects_ObjectGetShiftByValue">ObjectGetShiftByValue()</a> 函数。
</content>
<example>
  double price=ObjectGetValueByShift(&quot;MyTrendLine#123&quot;, 11);
</example>
<parameter>
type=string
name=name
description=物件名称。
</parameter>
<parameter>
type=int
name=shift
description=柱索引。
</parameter>
</function>
<function>
tag=objects_ObjectMove
caption=ObjectMove()
type=bool
<keywords>
;ObjectMove();
</keywords>
<content>
函数在图移动一个物件座标。 物件可能根据他们的
<a href="help://constants_objects">类型</a>
有一个到三个座标。 如果函数成功 ，返回值将是 TRUE， 否则，它将是FALSE。
获得详细的错误信息, 查看 <a href="help://check_GetLastError">GetLastError()</a> 函数。
物件坐标的开始数字必须是0。
</content>
<example>
ObjectMove(&quot;MyTrend&quot;, 1, D'2005.02.25 12:30', 1.2345);
</example>
<parameter>
type=string
name=name
description=物件名称。
</parameter>
<parameter>
type=int
name=point
description=坐标索引(0-2)。
</parameter>
<parameter>
type=datetime
name=time1
description=新时间值。
</parameter>
<parameter>
type=double
name=price1
description=新值。
</parameter>
</function>
<function>
tag=objects_ObjectName
caption=ObjectName()
type=string
<keywords>
;ObjectName();
</keywords>
<content>
在物件列表中用它的索引函数返回物件名称。获得详细的错误信息, 查看 <a href="help://check_GetLastError">GetLastError()</a> 函数。
</content>
<example>
  int    obj_total=ObjectsTotal();
  string name;
  for(int i=0;i&lt;obj_total;i++)
    {
     name=ObjectName(i);
     Print(i,&quot;物件名称为 &quot; + name);
    }
</example>
<parameter>
type=int
name=index
description=在物件列表中的物件索引。物件索引必须超过或等于0并且小于<a href="help://objects_ObjectsTotal">ObjectsTotal()</a>。
</parameter>
</function>
<function>
tag=objects_ObjectsDeleteAll
caption=ObjectsDeleteAll()
type=int
<keywords>
;ObjectsDeleteAll();
</keywords>
<content>
在图表的子窗口删除全部类型物件。函数返回删除物件数。获得详细的错误信息, 查看 <a href="help://check_GetLastError">GetLastError()</a> 函数。<br/>
注解: 子窗口图表(如果子窗口带有指标)编号从1 开始。主窗口的存在的索引为零。如果窗口索引错误或值为-1，物件 会从现有的图表中删除。<br/>
如果<i>类型</i> 值等与-1 或这个参量是错误的，在子窗口的全部指定物件将被删除。
</content>
<example>
  ObjectsDeleteAll(2, OBJ_HLINE); // 从第二子窗口移除全部水平线。
  ObjectsDeleteAll(2);            // 从第二子窗口移除全部物件。
  ObjectsDeleteAll();             //从图表中移除全部物件。
</example>
<parameter>
type=
name=window
description=选择参量。 物件的索引窗口将被删除。 必须超过或等于 -1 （EMPTY为默认值）并且小于 <a href="help://windows_WindowsTotal">WindowsTotal()</a>。
</parameter>
<parameter>
type=
name=type
description=选择参量。被删除的物件类型。它可以是 任意<a href="help://constants_objects">列举值的物件类型</a>或EMPTY常数删除所有物件类型。
</parameter>
</function>
<function>
tag=objects_ObjectSet
caption=ObjectSet()
type=bool
<keywords>
;ObjectSet();
</keywords>
<content>
改变指定物件属性的值。如果函数成功, 返回值将是 TRUE。否则, 它将是FALSE.
获得详细的错误信息, 查看 <a href="help://check_GetLastError">GetLastError()</a> 函数。
<br/><b>参见</b> <a href="help://objects_ObjectGet">ObjectGet()</a> 函数。
</content>
<example>
  // moving the first coord to the last bar time
  ObjectSet(&quot;MyTrend&quot;, OBJPROP_TIME1, Time[0]);
  // setting the second fibo level
  ObjectSet(&quot;MyFibo&quot;, OBJPROP_FIRSTLEVEL+1, 1.234);
  // setting object visibility. object will be shown only on 15 minute and 1 hour charts
  ObjectSet(&quot;MyObject&quot;, OBJPROP_TIMEFRAMES, OBJ_PERIOD_M15 | OBJ_PERIOD_H1);
</example>
<parameter>
type=string
name=name
description=物件名称。
</parameter>
<parameter>
type=int
name=index
description=物件索引值。 它可以是<a href="help://constants_objects_properties">列举的任意物件属性</a>值。
</parameter>
<parameter>
type=double
name=value
description=新的属性值。
</parameter>
</function>
<function>
tag=objects_ObjectSetFiboDescription
caption=ObjectSetFiboDescription()
type=bool
<keywords>
;ObjectSetFiboDescription();
</keywords>
<content>
函数分配一个新的描述到斐波纳契物件的水平。 相当数量斐波纳契水平取决于<a href="help://constants_objects">物件类型</a>。 最大金额斐波纳契水平是32。<br/>
获得详细的错误信息,查看  <a href="help://check_GetLastError">GetLastError()</a> 函数。
</content>
<example>
ObjectSetFiboDescription(&quot;MyFiboObject&quot;,2,&quot;Second line&quot;);
</example>
<parameter>
type=string
name=name
description=物件名称。
</parameter>
<parameter>
type=int
name=index
description=斐波纳契索引水平(0-31)。
</parameter>
<parameter>
type=string
name=text
description=新的水平描述
</parameter>
</function>
<function>
tag=objects_ObjectSetText
caption=ObjectSetText()
type=bool
<keywords>
;ObjectSetText();
</keywords>
<content>
改变物件描述。对于OBJ_TEXT 和OBJ_LABEL物件的描述作为图表的文本显示。如果函数成功, 返回的值将是TRUE。 否则, 它是FALSE。
获得详细的错误信息, 查看<a href="help://check_GetLastError">GetLastError()</a> 函数。<br/>
只有字体大小，字体名称和文本颜色参量使用为 <i>font_size</i>, <i>font_name</i>和 <i>text_color</i> 物件。为<a href="help://constants_objects">其它类型 </a>物件, 这些参量被忽略。
<br/><b>参见</b> <a href="help://objects_ObjectDescription">ObjectDescription()</a> 函数。
</content>
<example>
ObjectSetText(&quot;text_object&quot;, &quot;Hello world!&quot;, 10, &quot;Times New Roman&quot;, Green);
</example>
<parameter>
type=string
name=name
description=物件名称。
</parameter>
<parameter>
type=string
name=text
description=描述物件文本。
</parameter>
<parameter>
type=int
name=font_size
description=字体大小点数。
</parameter>
<parameter>
type=
name=font
description=字体名称。
</parameter>
<parameter>
type=
name=text_color
description=文本颜色。
</parameter>
</function>
<function>
tag=objects_ObjectsTotal
caption=ObjectsTotal()
type=int
<keywords>
;ObjectsTotal();
</keywords>
<content>
     在图表中返回指定物件类型总量。
</content>
<example>
  int    obj_total=ObjectsTotal();
  string name;
  for(int i=0;i&lt;obj_total;i++)
    {
     name=ObjectName(i);
     Print(i,&quot;对于 #的物件名称&quot;,i,&quot; is &quot; + name);
    }
</example>
<parameter>
type=
name=type
description=选择参量。将计数的物件类型。 它可以是 <a href="help://constants_objects">物件类型列举</a>的任意值或EMPTY常数计算全部类型物件。
</parameter>
</function>
<function>
tag=objects_ObjectType
caption=ObjectType()
type=int
<keywords>
;ObjectType();
</keywords>
<content>
函数返回 <a href="help://constants_objects">物件类型</a>值。
获得详细的错误信息, 查看 <a href="help://check_GetLastError">GetLastError()</a> 函数。
</content>
<example>
if(ObjectType(&quot;line_object2&quot;)!=OBJ_HLINE) return(0);
</example>
<parameter>
type=string
name=name
description=物件名称。
</parameter>
</function>
</group>
<group>
tag=strings
caption=String functions
<keywords>
;String functions;
</keywords>
<content>
        字串符类型数据的一组函数。

</content>
<function>
tag=strings_StringConcatenate
caption=StringConcatenate()
type=string
<keywords>
;StringConcatenate();
</keywords>
<content>
数据的字串符形式通过并且返回。 参量可以为任意类型。通过参量的总数不得超过64个字符。<br/><br/>
作为应用到<a href="help://common_Print">Print()</a>, <a href="help://common_Alert">Alert()</a> 和<a href="help://common_Comment">Comment()</a>函数的参量按照同样规则传送。
从函数参量返回获取的字符串作为连接结果。<br/><br/>
 当字串符连续使用(+)添加时，StringConcatenate() 运行较快并且会存储。
</content>
<example>
  string text;
  text=StringConcatenate(&quot;Account free margin is &quot;, AccountFreeMargin(), &quot;Current time is &quot;, TimeToStr(TimeCurrent()));
// 文本=&quot;Account free margin is &quot; + AccountFreeMargin() + &quot;Current time is &quot; + TimeToStr(TimeCurrent())
  Print(text);
</example>
<parameter>
type=...
name=
description=所有价格值由逗号分开。 它可以是64个参量。
</parameter>
</function>
<function>
tag=strings_StringFind
caption=StringFind()
type=int
<keywords>
;StringFind();
</keywords>
<content>
     搜索子字串符。如果未找到子字串符，从搜索子字串符开始返回字串符中的位置，或是 -1。
</content>
<example>
  string text=&quot;快速的棕色小狗跨越过懒惰的狐狸&quot;;
  int index=StringFind(text, &quot;小狗跨越&quot;, 0);
  if(index!=16)
    Print(&quot;oops!&quot;);
</example>
<parameter>
type=string
name=text
description=被搜索的字符串。
</parameter>
<parameter>
type=string
name=matched_text
description=需要搜索的字符串。
</parameter>
<parameter>
type=
name=start
description=搜索开始索引位置 。
</parameter>
</function>
<function>
tag=strings_StringGetChar
caption=StringGetChar()
type=int
<keywords>
;StringGetChar();
</keywords>
<content>
     从字串符指定位置返回代码。
</content>
<example>
  int char_code=StringGetChar(&quot;abcdefgh&quot;, 3);
  // 取出代码 'c' 是 99
</example>
<parameter>
type=string
name=text
description=字串符。
</parameter>
<parameter>
type=int
name=pos
description=取字符的位置 。可以自0 至 <a href="help://strings_StringLen">StringLen(text)</a>-1。
</parameter>
</function>
<function>
tag=strings_StringLen
caption=StringLen()
type=int
<keywords>
;StringLen();
</keywords>
<content>
     在字串符中返回代码数。 Returns character count in a string.
</content>
<example>
  string str=&quot;some text&quot;;
  if(StringLen(str)&lt;5) return(0);
</example>
<parameter>
type=string
name=text
description=计算字符串长度。
</parameter>
</function>
<function>
tag=strings_StringSetChar
caption=StringSetChar()
type=string
<keywords>
;StringSetChar();
</keywords>
<content>
      在指定位置返回带有改变代码的字串符复本。
</content>
<example>
  string str=&quot;abcdefgh&quot;;
  string str1=StringSetChar(str, 3, 'D');
  // str1 is &quot;abcDefgh&quot;
</example>
<parameter>
type=string
name=text
description=改变的字串符代码。
</parameter>
<parameter>
type=int
name=pos
description=字串符种代码的位置。可以自0 至 <a href="help://strings_StringLen">StringLen(text)</a>。
</parameter>
<parameter>
type=int
name=value
description=新取得ASCII 代码。
</parameter>
</function>
<function>
tag=strings_StringSubstr
caption=StringSubstr()
type=string
<keywords>
;StringSubstr();
</keywords>
<content>
从给出的位置的文本字串符开端提取字串符。<br/>
如果可能此函数返回提取字串符的副本，否则返回空字串符。
</content>
<example>
  string text=&quot;快速的棕色小狗跨越过懒惰的狐狸&quot;;
  string substr=StringSubstr(text, 4, 5);
  // 减去字串符是&quot;快速&quot;单词
</example>
<parameter>
type=string
name=text
description=将被提取的字串符。
</parameter>
<parameter>
type=int
name=start
description=字串符开始索引。可以是自 0 至 <a href="help://strings_StringLen">StringLen(text)</a>-1。
</parameter>
<parameter>
type=
name=length
description=字串符提取的宽度。如果参量值超过或等于 0 或者参量没有指定，字串符将被提取。
</parameter>
</function>
<function>
tag=strings_StringTrimLeft
caption=StringTrimLeft()
type=string
<keywords>
;StringTrimLeft();
</keywords>
<content>
在字串符左侧部分函数剪切空间和图表。如果可能函数返回一个剪切的复本。否则返回空字串符。
</content>
<example>
  string str1=&quot;  Hello world   &quot;;
  string str2=StringTrimLeft(str);
  // 在剪切str2将是 &quot;Hello World   &quot;
</example>
<parameter>
type=string
name=text
description=左侧剪切的字串符。
</parameter>
</function>
<function>
tag=strings_StringTrimRight
caption=StringTrimRight()
type=string
<keywords>
;StringTrimRight();
</keywords>
<content>
在字串符右侧部分函数剪切空间和图表。如果可能函数返回一个剪切的复本。否则返回空字串符。
</content>
<example>
  string str1=&quot;  Hello world   &quot;;
  string str2=StringTrimRight(str);
  // 在剪切str2 之后将是 &quot;  Hello World&quot;
</example>
<parameter>
type=string
name=text
description=右侧剪切的字串符。
</parameter>
</function>
</group>
<group>
tag=indicators
caption=Technical indicators
<keywords>
;Technical indicators;
</keywords>
<content>
        标准和自定义指标的一组计算函数。<br/><br/>
   对于交易(或其他MQL4 程序)接受其他指标的值，这个值不可能存在于图表之内。 这个请求的指标将在嗲用模件中被加载并计算。<br/><br/>
    不仅可以计算当前图表中的任何指标，同样可以计算任何有效的货币对/时间周期数据。如果请求数据(货币对名称/时间周期不同于当前图表)来自其他图表，这种情况可能使相应的图表不能在客户端内打开，并且需要从服务器上请求数据。这种情况下，
    <a href="help://constants_errors">错误</a> ERR_HISTORY_WILL_UPDATED (4066 - 请求历史数据并刷新)将被放置于<a href="help://runtime_errors">last_error</a>变量中，并且可以重新请求(查看<a href="help://array_ArrayCopySeries">ArrayCopySeries()</a>范例)。

</content>
<function>
tag=indicators_iAC
caption=iAC()
type=double
<keywords>
;iAC() - Accelerator Oscillator (Acceleration/Deceleration);
</keywords>
<content>
      计算比尔.威廉斯的加速器或减速箱振荡器。
</content>
<example>
  double result=iAC(NULL, 0, 1);
</example>
<parameter>
type=string
name=symbol
description=计算指标数据上的货币对名称. NULL表示当前货币对.
</parameter>
<parameter>
type=int
name=timeframe
description=时间周期。 可以<a href="help://constants_timeframes">时间周期列举</a>任意值. 0表示当前图表的时间周期.
</parameter>
<parameter>
type=int
name=shift
description=从显示缓冲采取的值的索引(转移相对当前柱特定相当数量期间前)。
</parameter>
</function>
<function>
tag=indicators_iAD
caption=iAD()
type=double
<keywords>
;iAD() - Accumulation/Distribution;
</keywords>
<content>
     计算离散指标并且返回它的值。
</content>
<example>
  double result=iAD(NULL, 0, 1);
</example>
<parameter>
type=string
name=symbol
description=计算指标数据上的货币对名称. NULL表示当前货币对.
</parameter>
<parameter>
type=int
name=timeframe
description=时间周期.可以是<a href="help://constants_timeframes">时间周期列举</a>任意值.0表示当前图表的时间周期.
</parameter>
<parameter>
type=int
name=shift
description=从显示缓冲采取的值的索引(转移相对当前柱特定相当数量期间前)。
</parameter>
</function>
<function>
tag=indicators_iAlligator
caption=iAlligator()
type=double
<keywords>
;iAlligator() - Alligator;MODE_GATORJAW;MODE_GATORTEETH;MODE_GATORLIPS;
</keywords>
<content>
     计算比尔・威廉斯的鳄鱼指标并且退回它的值。
</content>
<example>
  double jaw_val=iAlligator(NULL, 0, 13, 8, 8, 5, 5, 3, MODE_SMMA, PRICE_MEDIAN, MODE_GATORJAW, 1);
</example>
<parameter>
type=string
name=symbol
description=计算指标数据上的货币对名称. NULL表示当前货币对.
</parameter>
<parameter>
type=int
name=timeframe
description=时间周期。 可以<a href="help://constants_timeframes">时间周期列举</a>任意值. 0表示当前图表的时间周期.
</parameter>
<parameter>
type=int
name=jaw_period
description=平均周期(鳄鱼的下颌)的蓝线。
</parameter>
<parameter>
type=int
name=jaw_shift
description=蓝线转移相对图。
</parameter>
<parameter>
type=int
name=teeth_period
description=平均周期(鳄鱼的牙)的红线。
</parameter>
<parameter>
type=int
name=teeth_shift
description=红线转移相对图。
</parameter>
<parameter>
type=int
name=lips_period
description=平均周期(鳄鱼的嘴唇)的绿线。
</parameter>
<parameter>
type=int
name=lips_shift
description=绿线转移相对图。
</parameter>
<parameter>
type=int
name=ma_method
description=MA方法。 它可以是其中任意个<a href="help://constants_movings">滑动平均法</a>.
</parameter>
<parameter>
type=int
name=applied_price
description=应用的价格。 它可以是 <a href="help://constants_prices">应用价格列举</a> 的任意值.
</parameter>
<parameter>
type=int
name=mode
description=数据来源，显示线的标识符。 它可以是以下值中的任意:<br/>MODE_GATORJAW - Gator 下颌(蓝色)平衡线路,<br/>MODE_GATORTEETH - Gator  牙(红色)平衡线路，<br/>MODE_GATORLIPS - Gator  嘴唇(绿色)平衡线路。
</parameter>
<parameter>
type=int
name=shift
description=转移相对当前柱(期间的数字)应该采取数据从的地方。
</parameter>
</function>
<function>
tag=indicators_iADX
caption=iADX()
type=double
<keywords>
;iADX() - Average Directional Movement Index;
</keywords>
<content>
      计算移动定向索引并且退回它的值。
</content>
<example>
if(iADX(NULL,0,14,PRICE_HIGH,MODE_MAIN,0)&gt;iADX(NULL,0,14,PRICE_HIGH,MODE_PLUSDI,0)) return(0);
</example>
<parameter>
type=string
name=symbol
description=计算指标数据上的货币对名称. NULL表示当前货币对.
</parameter>
<parameter>
type=int
name=timeframe
description=时间周期。 可以<a href="help://constants_timeframes">时间周期列举</a>任意值. 0表示当前图表的时间周期.
</parameter>
<parameter>
type=int
name=period
description=计算平均周期。
</parameter>
<parameter>
type=int
name=applied_price
description=应用的价格。它可以是<a href="help://constants_prices">应用价格列举</a>的任意值.
</parameter>
<parameter>
type=int
name=mode
description=指标索引行。 它可以是<a href="help://constants_lines">指标索引列举</a>的任意值.
</parameter>
<parameter>
type=int
name=shift
description=从显示缓冲采取的值的索引(转移相对当前柱特定相当数量期间前) .
</parameter>
</function>
<function>
tag=indicators_iATR
caption=iATR()
type=double
<keywords>
;iATR() - Average True Range;
</keywords>
<content>
      计算平均真实范围的指标并且返回它的值。
</content>
<example>
  if(iATR(NULL,0,12,0)&gt;iATR(NULL,0,20,0)) return(0);
</example>
<parameter>
type=string
name=symbol
description=计算指标数据上的货币对名称. NULL表示当前货币对.
</parameter>
<parameter>
type=int
name=timeframe
description=时间周期。 可以<a href="help://constants_timeframes">时间周期列举</a>任意值. 0表示当前图表的时间周期.
</parameter>
<parameter>
type=int
name=period
description=计算平均周期。
</parameter>
<parameter>
type=int
name=shift
description=从显示缓冲采取的值的索引(转移相对当前柱特定相当数量期间前)。
</parameter>
</function>
<function>
tag=indicators_iAO
caption=iAO()
type=double
<keywords>
;iAO() - Awesome Oscillator;
</keywords>
<content>
     计算比尔.威廉斯的振荡器并且退回它的值。
</content>
<example>
  double val=iAO(NULL, 0, 2);
</example>
<parameter>
type=string
name=symbol
description=计算指标数据上的货币对名称. NULL表示当前货币对.
</parameter>
<parameter>
type=int
name=timeframe
description=时间周期。 可以<a href="help://constants_timeframes">时间周期列举</a>任意值. 0表示当前图表的时间周期.
</parameter>
<parameter>
type=int
name=shift
description=从显示缓冲采取的值的索引(转移相对当前柱特定相当数量期间前)。
</parameter>
</function>
<function>
tag=indicators_iBearsPower
caption=iBearsPower()
type=double
<keywords>
;iBearsPower() - Bears Power;
</keywords>
<content>
      计算熊功率指标并且返回它的值。
</content>
<example>
  double val=iBearsPower(NULL, 0, 13,PRICE_CLOSE,0);
</example>
<parameter>
type=string
name=symbol
description=计算指标数据上的货币对名称. NULL表示当前货币对.
</parameter>
<parameter>
type=int
name=timeframe
description=时间周期。 可以<a href="help://constants_timeframes">时间周期列举</a>任意值. 0表示当前图表的时间周期.
</parameter>
<parameter>
type=int
name=period
description=计算平均周期。
</parameter>
<parameter>
type=int
name=applied_price
description=应用的价格。 它可以是<a href="help://constants_prices">应用价格列举</a>的任意值.
</parameter>
<parameter>
type=int
name=shift
description=从显示缓冲采取的值的索引(转移相对当前柱特定相当数量期间前) .
</parameter>
</function>
<function>
tag=indicators_iBands
caption=iBands()
type=double
<keywords>
;iBands() - Bollinger Bands®;
</keywords>
<content>
      计算保力加通道技术指标并返回它的值。
</content>
<example>
if(iBands(NULL,0,20,2,0,PRICE_LOW,MODE_LOWER,0)&gt;Low[0]) return(0);
</example>
<parameter>
type=string
name=symbol
description=计算指标数据上的货币对名称. NULL表示当前货币对.
</parameter>
<parameter>
type=int
name=timeframe
description=时间周期。 可以<a href="help://constants_timeframes">时间周期列举</a>任意值. 0表示当前图表的时间周期.
</parameter>
<parameter>
type=int
name=period
description=计算平均周期的主线。
</parameter>
<parameter>
type=int
name=deviation
description=与主线的偏差。
</parameter>
<parameter>
type=int
name=bands_shift
description=指标相对图转移。
</parameter>
<parameter>
type=int
name=applied_price
description=应用的价格。 它可以是<a href="help://constants_prices">应用价格列举</a>的任意值.
</parameter>
<parameter>
type=int
name=mode
description=显示索引行。 它可以是<a href="help://constants_lines">指标线识别符列举</a>的任意值.
</parameter>
<parameter>
type=int
name=shift
description=从显示缓冲采取的值的索引(转移相对当前柱特定相当数量期间前).
</parameter>
</function>
<function>
tag=indicators_iBandsOnArray
caption=iBandsOnArray()
type=double
<keywords>
;iBandsOnArray() - Bollinger Bands® on buffer;
</keywords>
<content>
       计算保力加通道指标在不同数组上的数据存储。不同于iBands (...)， iBandsOnArray函数，不由货币对名字，时间周期，应用的价格采取数据 。 必须提前准备价格数据。从左到右计算指标。 要对数组元素访问至系列列阵(即，从右到左)，你必须使用<a href="help://array_ArraySetAsSeries">ArraySetAsSeries</a> 函数.
</content>
<example>
if(iBands(ExtBuffer,total,2,0,MODE_LOWER,0)&gt;Low[0]) return(0);
</example>
<parameter>
type=double
name=<nobr>array[]</nobr>
description=数据数组。
</parameter>
<parameter>
type=int
name=total
description=将计数的项目的数量。 0意味整体列阵。
</parameter>
<parameter>
type=int
name=period
description=计算主线的平均周期。
</parameter>
<parameter>
type=int
name=deviation
description=与主线的偏差。
</parameter>
<parameter>
type=int
name=bands_shift
description=指标相对图转移。
</parameter>
<parameter>
type=int
name=mode
description=显示索引行。 它可以是<a href="help://constants_lines">指标线识别符列举</a>的任意值.
</parameter>
<parameter>
type=int
name=shift
description=从显示缓冲采取的值的索引(转移相对当前柱特定相当数量期间前).
</parameter>
</function>
<function>
tag=indicators_iBullsPower
caption=iBullsPower()
type=double
<keywords>
;iBullsPower() - Bulls Power;
</keywords>
<content>
      计算牛市指标并返回它的值。
</content>
<example>
  double val=iBullsPower(NULL, 0, 13,PRICE_CLOSE,0);
</example>
<parameter>
type=string
name=symbol
description=计算指标数据上的货币对名称. NULL表示当前货币对.
</parameter>
<parameter>
type=int
name=timeframe
description=时间周期。 可以<a href="help://constants_timeframes">时间周期列举</a>任意值. 0表示当前图表的时间周期.
</parameter>
<parameter>
type=int
name=period
description=计算平均周期。
</parameter>
<parameter>
type=int
name=applied_price
description=应用的价格。 它可以是<a href="help://constants_prices">应用价格列举</a>的任意值.
</parameter>
<parameter>
type=int
name=shift
description=从显示缓冲采取的值的索引(转移相对当前柱特定相当数量期间前) .
</parameter>
</function>
<function>
tag=indicators_iCCI
caption=iCCI()
type=double
<keywords>
;iCCI() - Commodity Channel Index;
</keywords>
<content>
    计算商品通道索引指标并且返回它的值。
</content>
<example>
  if(iCCI(NULL,0,12,PRICE_TYPICAL,0)&gt;iCCI(NULL,0,20,PRICE_TYPICAL,0)) return(0);
</example>
<parameter>
type=string
name=symbol
description=计算指标数据上的货币对名称. NULL表示当前货币对.
</parameter>
<parameter>
type=int
name=timeframe
description=时间周期。 可以<a href="help://constants_timeframes">时间周期列举</a>任意值. 0表示当前图表的时间周期.
</parameter>
<parameter>
type=int
name=period
description=计算平均周期.
</parameter>
<parameter>
type=int
name=applied_price
description=应用的价格。 它可以是<a href="help://constants_prices">应用价格列举</a>的任意值.
</parameter>
<parameter>
type=int
name=shift
description=从显示缓冲采取的值的索引(转移相对当前柱特定相当数量期间前) .
</parameter>
</function>
<function>
tag=indicators_iCCIOnArray
caption=iCCIOnArray()
type=double
<keywords>
;iCCIOnArray() - Commodity Channel Index on buffer;
</keywords>
<content>
      计算在不同数组存储的商品通道索引指标。不同于iCCI (...)， iCCIOnArray函数， 不由标志名字，时间周期，应用的价格采取数据。 必须提前准备价格数据。指标从左到右被计算。 要对数组元素至于系列列阵访问(即，从右到左)，你必须使用 <a href="help://array_ArraySetAsSeries">ArraySetAsSeries</a> 函数.
</content>
<example>
if(iCCIOnArray(ExtBuffer,total,12,0)&gt;iCCI(NULL,0,20,PRICE_TYPICAL, 0)) return(0);
</example>
<parameter>
type=double
name=<nobr>array[]</nobr>
description=数据数组.
</parameter>
<parameter>
type=int
name=total
description=计算项目数字.
</parameter>
<parameter>
type=int
name=period
description=计算平均周期.
</parameter>
<parameter>
type=int
name=shift
description=从显示缓冲采取的值的索引(转移相对当前柱特定相当数量期间前）.
</parameter>
</function>
<function>
tag=indicators_iCustom
caption=iCustom()
type=double
<keywords>
;iCustom() - Custom Indicator;
</keywords>
<content>
     计算指定的客户指标并且退回它的值。 必须在<em>terminal_directory\experts\indicators</em>目录内编写客户指标(*.EX4文件)。
</content>
<example>
  double val=iCustom(NULL, 0, &quot;示例Ind&quot;,13,1,0);
</example>
<parameter>
type=string
name=symbol
description=计算指标数据上的货币对名称. NULL表示当前货币对.
</parameter>
<parameter>
type=int
name=timeframe
description=时间周期。 可以<a href="help://constants_timeframes">时间周期列举</a>任意值. 0表示当前图表的时间周期.
</parameter>
<parameter>
type=string
name=name
description=客户指标完成程序名称.
</parameter>
<parameter>
type=...
name=
description=参量设置(如果需要)。通过的参量和他们的顺序必须与desclaration命令和客户指标的外部可变物的种类对应。
</parameter>
<parameter>
type=int
name=mode
description=索引行。 从0到7并且必须对应以其中一个使用的索引的 <a href="help://customind_SetIndexBuffer">SetIndexBuffer</a> 函数.
</parameter>
<parameter>
type=int
name=shift
description=从显示缓冲采取的值的索引(转移相对当前柱特定相当数量期间前).
</parameter>
</function>
<function>
tag=indicators_iDeMarker
caption=iDeMarker()
type=double
<keywords>
;iDeMarker() - DeMarker;
</keywords>
<content>
     计算DeMarker指标并返回它的值.
</content>
<example>
  double val=iDeMarker(NULL, 0, 13, 1);
</example>
<parameter>
type=string
name=symbol
description=计算指标数据上的货币对名称. NULL表示当前货币对.
</parameter>
<parameter>
type=int
name=timeframe
description=时间周期。 可以<a href="help://constants_timeframes">时间周期列举</a>任意值. 0表示当前图表的时间周期.
</parameter>
<parameter>
type=int
name=period
description=计算平均周期。
</parameter>
<parameter>
type=int
name=shift
description=从显示缓冲采取的值的索引(转移相对当前柱特定相当数量期间前) .
</parameter>
</function>
<function>
tag=indicators_iEnvelopes
caption=iEnvelopes()
type=double
<keywords>
;iEnvelopes() - Envelopes;
</keywords>
<content>
     计算包络指标并返回它的值。
</content>
<example>
  double val=iEnvelopes(NULL, 0, 13,MODE_SMA,10,PRICE_CLOSE,0.2,MODE_UPPER,0);
</example>
<parameter>
type=string
name=symbol
description=计算指标数据上的货币对名称. NULL表示当前货币对.
</parameter>
<parameter>
type=int
name=timeframe
description=时间周期。 可以<a href="help://constants_timeframes">时间周期列举</a>任意值. 0表示当前图表的时间周期.
</parameter>
<parameter>
type=int
name=ma_period
description=主线的平均周期计算.
</parameter>
<parameter>
type=int
name=ma_method
description=MA方法。 它可以是其中任意 <a href="help://constants_movings">滑动平均值列举</a> 值.
</parameter>
<parameter>
type=int
name=ma_shift
description=MA转移。 指标线垂直与图表的时间周期.
</parameter>
<parameter>
type=int
name=applied_price
description=应用的价格。 它可以是<a href="help://constants_prices">应用价格列举</a>的任意值.
</parameter>
<parameter>
type=double
name=deviation
description=与主线的偏差。
</parameter>
<parameter>
type=int
name=mode
description=指标行数组索引。它可以是 <a href="help://constants_lines">指标识别符列举</a>的任意值.
</parameter>
<parameter>
type=int
name=shift
description=从显示缓冲采取的值的索引(转移相对当前柱特定相当数量期间前).
</parameter>
</function>
<function>
tag=indicators_iEnvelopesOnArray
caption=iEnvelopesOnArray()
type=double
<keywords>
;iEnvelopesOnArray() - Envelopes on buffer;
</keywords>
<content>
       计算包络指标在不同数组上的数据存储。与不同iEnvelopes (...)， iEnvelopesOnArray函数不由标志名字， 时间周期，应用的价格采取数据。 必须提前准备价格数据。 指标从左到右被计算。 要对数组元素至于系列列阵(即，从右到左)访问，你必须使用<a href="help://array_ArraySetAsSeries">ArraySetAsSeries</a> 函数.
</content>
<example>
  double val=iEnvelopesOnArray(ExtBuffer, 0, 13, MODE_SMA, 0.2, MODE_UPPER,0 );
</example>
<parameter>
type=double
name=<nobr>array[]</nobr>
description=数据数组.
</parameter>
<parameter>
type=int
name=total
description=计算项目数字.
</parameter>
<parameter>
type=int
name=ma_period
description=主线的平均周期计算。
</parameter>
<parameter>
type=int
name=ma_method
description=MA方法。 它可以是其中任意 <a href="help://constants_movings">滑动平均值列举</a> 值.
</parameter>
<parameter>
type=int
name=ma_shift
description=MA转移。 指标线垂直与图表的时间周期。
</parameter>
<parameter>
type=double
name=deviation
description=与主线的偏差。
</parameter>
<parameter>
type=int
name=mode
description=指标行数组索引。它可以是 <a href="help://constants_lines">指标识别符列举</a>的任意值.
</parameter>
<parameter>
type=int
name=shift
description=从显示缓冲采取的值的索引(转移相对当前柱特定相当数量期间前).
</parameter>
</function>
<function>
tag=indicators_iForce
caption=iForce()
type=double
<keywords>
;iForce() - Force Index;
</keywords>
<content>
     计算强力索引指标并返回它的值。
</content>
<example>
  double val=iForce(NULL, 0, 13,MODE_SMA,PRICE_CLOSE,0);
</example>
<parameter>
type=string
name=symbol
description=计算指标数据上的货币对名称. NULL表示当前货币对.
</parameter>
<parameter>
type=int
name=timeframe
description=时间周期。 可以<a href="help://constants_timeframes">时间周期列举</a>任意值. 0表示当前图表的时间周期.
</parameter>
<parameter>
type=int
name=period
description=计算平均周期。
</parameter>
<parameter>
type=int
name=ma_method
description=MA方法。 它可以是其中任意 <a href="help://constants_movings">滑动平均值列举</a> 值.
</parameter>
<parameter>
type=int
name=applied_price
description=应用的价格。 它可以是<a href="help://constants_prices">应用价格列举</a>的任意值.
</parameter>
<parameter>
type=int
name=shift
description=从显示缓冲采取的值的索引(转移相对当前柱特定相当数量期间前).
</parameter>
</function>
<function>
tag=indicators_iFractals
caption=iFractals()
type=double
<keywords>
;iFractals() - Fractals;
</keywords>
<content>
     计算分形索引指标并返回它的值。
</content>
<example>
  double val=iFractals(NULL, 0, MODE_UPPER, 3);
</example>
<parameter>
type=string
name=symbol
description=计算指标数据上的货币对名称. NULL表示当前货币对.
</parameter>
<parameter>
type=int
name=timeframe
description=时间周期。 可以<a href="help://constants_timeframes">时间周期列举</a>任意值. 0表示当前图表的时间周期.
</parameter>
<parameter>
type=int
name=mode
description=指标行数组索引。它可以是 <a href="help://constants_lines">指标识别符列举</a>的任意值.
</parameter>
<parameter>
type=int
name=shift
description=从显示缓冲采取的值的索引(转移相对当前柱特定相当数量期间前).
</parameter>
</function>
<function>
tag=indicators_iGator
caption=iGator()
type=double
<keywords>
;iGator() - Gator Oscillator;
</keywords>
<content>
     计算随机震荡指标。 震荡指标在<a href="help://indicators_iAlligator">鳄鱼</a> 红色和蓝线(上部直方图)和那之间的区别在于红色和绿线(更低的直方图)之间。
</content>
<example>
  double jaw_val=iGator(NULL, 0, 13, 8, 8, 5, 5, 3, MODE_SMMA, PRICE_MEDIAN, MODE_UPPER, 1);
</example>
<parameter>
type=string
name=symbol
description=计算指标数据上的货币对名称. NULL表示当前货币对.
</parameter>
<parameter>
type=int
name=timeframe
description=时间周期。 可以<a href="help://constants_timeframes">时间周期列举</a>任意值. 0表示当前图表的时间周期.
</parameter>
<parameter>
type=int
name=jaw_period
description=平均周期(鳄鱼的下颌)的蓝线.
</parameter>
<parameter>
type=int
name=jaw_shift
description=蓝线转移相对图.
</parameter>
<parameter>
type=int
name=teeth_period
description=平均周期(鳄鱼的牙)的红线.
</parameter>
<parameter>
type=int
name=teeth_shift
description=红线转移相对图.
</parameter>
<parameter>
type=int
name=lips_period
description=平均周期(鳄鱼的嘴唇)的绿线.
</parameter>
<parameter>
type=int
name=lips_shift
description=绿线转移相对图.
</parameter>
<parameter>
type=int
name=ma_method
description=MA方法。 它可以是其中任意 <a href="help://constants_movings">滑动平均值列举</a> 值.
</parameter>
<parameter>
type=int
name=applied_price
description=应用的价格。 它可以是<a href="help://constants_prices">应用价格列举</a>的任意值.
</parameter>
<parameter>
type=int
name=mode
description=指标行数组索引。它可以是 <a href="help://constants_lines">指标识别符列举</a>的任意值.
</parameter>
<parameter>
type=int
name=shift
description=从显示缓冲采取的值的索引(转移相对当前柱特定相当数量期间前).
</parameter>
</function>
<function>
tag=indicators_iIchimoku
caption=iIchimoku()
type=double
<keywords>
;iIchimoku() - Ichimoku Kinko Hyo;
</keywords>
<content>
      计算Ichimoku Kinko Hyo并且返回它的值。
</content>
<example>
  double tenkan_sen=iIchimoku(NULL, 0, 9, 26, 52, MODE_TENKANSEN, 1);
</example>
<parameter>
type=string
name=symbol
description=计算指标数据上的货币对名称. NULL表示当前货币对.
</parameter>
<parameter>
type=int
name=timeframe
description=时间周期。 可以<a href="help://constants_timeframes">时间周期列举</a>任意值. 0表示当前图表的时间周期.
</parameter>
<parameter>
type=int
name=tenkan_sen
description=Tenkan Sen 平均周期.
</parameter>
<parameter>
type=int
name=kijun_sen
description=Kijun Sen 平均周期.
</parameter>
<parameter>
type=int
name=senkou_span_b
description=Senkou SpanB 平均周期.
</parameter>
<parameter>
type=int
name=mode
description=数据源代码。它可以是 <a href="help://constants_ichimoku">Ichimoku Kinko Hyo 列举模式</a>的任意值.
</parameter>
<parameter>
type=int
name=shift
description=从显示缓冲采取的值的索引(转移相对当前柱特定相当数量期间前).
</parameter>
</function>
<function>
tag=indicators_iBWMFI
caption=iBWMFI()
type=double
<keywords>
;iBWMFI() - Market Facilitation Index (Bill Williams);
</keywords>
<content>
     计算比尔.威廉斯市场斐波纳契指标并且返回它的值。
</content>
<example>
  double val=iBWMFI(NULL, 0, 0);
</example>
<parameter>
type=string
name=symbol
description=计算指标数据上的货币对名称. NULL表示当前货币对.
</parameter>
<parameter>
type=int
name=timeframe
description=时间周期。 可以<a href="help://constants_timeframes">时间周期列举</a>任意值. 0表示当前图表的时间周期.
</parameter>
<parameter>
type=int
name=shift
description=从显示缓冲采取的值的索引(转移相对当前柱特定相当数量期间前).
</parameter>
</function>
<function>
tag=indicators_iMomentum
caption=iMomentum()
type=double
<keywords>
;iMomentum() - Momentum;
</keywords>
<content>
      计算动量索引指标并返回它的值。
</content>
<example>
if(iMomentum(NULL,0,12,PRICE_CLOSE,0)&gt;iMomentum(NULL,0,20,PRICE_CLOSE,0)) return(0);
</example>
<parameter>
type=string
name=symbol
description=计算指标数据上的货币对名称. NULL表示当前货币对.
</parameter>
<parameter>
type=int
name=timeframe
description=时间周期。 可以<a href="help://constants_timeframes">时间周期列举</a>任意值. 0表示当前图表的时间周期.
</parameter>
<parameter>
type=int
name=period
description=价格改变的周期计算.
</parameter>
<parameter>
type=int
name=applied_price
description=应用的价格。 它可以是<a href="help://constants_prices">应用价格列举</a>的任意值.
</parameter>
<parameter>
type=int
name=shift
description=从显示缓冲采取的值的索引(转移相对当前柱特定相当数量期间前).
</parameter>
</function>
<function>
tag=indicators_iMomentumOnArray
caption=iMomentumOnArray()
type=double
<keywords>
;iMomentumOnArray() - Momentum on buffer;
</keywords>
<content>
       计算动量指标在不同数组上的数据存储。与不同iMomentum(...), the iMomentumOnArray 函数不由标志名字， 时间周期，应用的价格采取数据。 必须提前准备价格数据。 指标从左到右被计算。 要对数组元素至于系列列阵(即，从右到左)访问，你必须使用<a href="help://array_ArraySetAsSeries">ArraySetAsSeries</a> 函数.
</content>
<example>
if(iMomentumOnArray(mybuffer,100,12,0)&gt;iMomentumOnArray(mubuffer,100,20,0)) return(0);
</example>
<parameter>
type=double
name=<nobr>array[]</nobr>
description=数据数组.
</parameter>
<parameter>
type=int
name=total
description=将计数的项目的数量.
</parameter>
<parameter>
type=int
name=period
description=计算价格变化的周期.
</parameter>
<parameter>
type=int
name=shift
description=从显示缓冲采取的值的索引(转移相对当前柱特定相当数量期间前).
</parameter>
</function>
<function>
tag=indicators_iMFI
caption=iMFI()
type=double
<keywords>
;iMFI() - Money Flow Index;
</keywords>
<content>
 计算资金流量索引指标并返回它的值。
</content>
<example>
if(iMFI(NULL,0,14,0)&gt;iMFI(NULL,0,14,1)) return(0);
</example>
<parameter>
type=string
name=symbol
description=计算指标数据上的货币对名称. NULL表示当前货币对.
</parameter>
<parameter>
type=int
name=timeframe
description=时间周期。 可以<a href="help://constants_timeframes">时间周期列举</a>任意值. 0表示当前图表的时间周期.
</parameter>
<parameter>
type=int
name=period
description=指标的周期计算.
</parameter>
<parameter>
type=int
name=shift
description=从显示缓冲采取的值的索引(转移相对当前柱特定相当数量期间前).
</parameter>
</function>
<function>
tag=indicators_iMA
caption=iMA()
type=double
<keywords>
;iMA() - Moving Average;
</keywords>
<content>
      计算移动平均指标并返回它的值。
</content>
<example>
AlligatorJawsBuffer[i]=iMA(NULL,0,13,8,MODE_SMMA,PRICE_MEDIAN,i);
</example>
<parameter>
type=string
name=symbol
description=计算指标数据上的货币对名称. NULL表示当前货币对.
</parameter>
<parameter>
type=int
name=timeframe
description=时间周期。 可以<a href="help://constants_timeframes">时间周期列举</a>任意值. 0表示当前图表的时间周期.
</parameter>
<parameter>
type=int
name=period
description=平均周期计算。
</parameter>
<parameter>
type=int
name=ma_shift
description=MA转移。 指标线垂直与图表的时间周期.
</parameter>
<parameter>
type=int
name=ma_method
description=MA方法。 它可以是其中任意 <a href="help://constants_movings">滑动平均值列举</a> 值.
</parameter>
<parameter>
type=int
name=applied_price
description=应用的价格。 它可以是<a href="help://constants_prices">应用价格列举</a>的任意值.
</parameter>
<parameter>
type=int
name=shift
description=从显示缓冲采取的值的索引(转移相对当前柱特定相当数量期间前).
</parameter>
</function>
<function>
tag=indicators_iMAOnArray
caption=iMAOnArray()
type=double
<keywords>
;iMAOnArray() - Moving Average on buffer;
</keywords>
<content>
        计算移动平均指标在不同数组上的数据存储。与不同iMA(...), the iMAOnArray 函数不由标志名字， 时间周期，应用的价格采取数据。 必须提前准备价格数据。 指标从左到右被计算。 要对数组元素至于系列列阵(即，从右到左)访问，你必须使用<a href="help://array_ArraySetAsSeries">ArraySetAsSeries</a> 函数.
</content>
<example>
   double macurrent=iMAOnArray(ExtBuffer,0,5,0,MODE_LWMA,0);
   double macurrentslow=iMAOnArray(ExtBuffer,0,10,0,MODE_LWMA,0);
   double maprev=iMAOnArray(ExtBuffer,0,5,0,MODE_LWMA,1);
   double maprevslow=iMAOnArray(ExtBuffer,0,10,0,MODE_LWMA,1);
   //----
   if(maprev&lt;maprevslow &amp;&amp; macurrent&gt;=macurrentslow)
     Alert(&quot;穿过&quot;);
</example>
<parameter>
type=double
name=<nobr>array[]</nobr>
description=数据数组.
</parameter>
<parameter>
type=int
name=total
description=将计数的项目的数量.
</parameter>
<parameter>
type=int
name=period
description=平均周期计算.
</parameter>
<parameter>
type=int
name=ma_shift
description=MA 移动.
</parameter>
<parameter>
type=int
name=ma_method
description=MA方法。 它可以是其中任意 <a href="help://constants_movings">滑动平均值列举</a> 值.
</parameter>
<parameter>
type=int
name=shift
description=从显示缓冲采取的值的索引(转移相对当前柱特定相当数量期间前).
</parameter>
</function>
<function>
tag=indicators_iOsMA
caption=iOsMA()
type=double
<keywords>
;iOsMA() - Moving Average of Oscillator;
</keywords>
<content>
     计算移动振动平均震荡器指标并退回它的值。有时在一些系统中显示为MACD 直方图。
</content>
<example>
if(iOsMA(NULL,0,12,26,9,PRICE_OPEN,1)&gt;iOsMA(NULL,0,12,26,9,PRICE_OPEN,0)) return(0);
</example>
<parameter>
type=string
name=symbol
description=计算指标数据上的货币对名称. NULL表示当前货币对.
</parameter>
<parameter>
type=int
name=timeframe
description=时间周期。 可以<a href="help://constants_timeframes">时间周期列举</a>任意值. 0表示当前图表的时间周期.
</parameter>
<parameter>
type=int
name=fast_ema_period
description=对于快速移动平均值周期数的计算.
</parameter>
<parameter>
type=int
name=slow_ema_period
description=对于缓慢移动平均值周期数计算.
</parameter>
<parameter>
type=int
name=signal_period
description=对于信号移动平均值周期数计算.
</parameter>
<parameter>
type=int
name=applied_price
description=应用的价格。 它可以是<a href="help://constants_prices">应用价格列举</a>的任意值.
</parameter>
<parameter>
type=int
name=shift
description=从显示缓冲采取的值的索引(转移相对当前柱特定相当数量期间前).
</parameter>
</function>
<function>
tag=indicators_iMACD
caption=iMACD()
type=double
<keywords>
;iMACD() - Moving Averages Convergence/Divergence;
</keywords>
<content>
      计算移动平均数汇总/分离指标并退回它的值。在系统中， OsMA称MACD直方图， 这个指标被作为二条线。 在客户终端，移动平均数汇总/分离被画作为直方图。
</content>
<example>
if(iMACD(NULL,0,12,26,9,PRICE_CLOSE,MODE_MAIN,0)&gt;iMACD(NULL,0,12,26,9,PRICE_CLOSE,MODE_SIGNAL,0)) return(0);
</example>
<parameter>
type=string
name=symbol
description=计算指标数据上的货币对名称. NULL表示当前货币对.
</parameter>
<parameter>
type=int
name=timeframe
description=时间周期。 可以<a href="help://constants_timeframes">时间周期列举</a>任意值. 0表示当前图表的时间周期.
</parameter>
<parameter>
type=int
name=fast_ema_period
description=对于快速移动平均值周期数的计算.
</parameter>
<parameter>
type=int
name=slow_ema_period
description=对于缓慢移动平均值周期数计算.
</parameter>
<parameter>
type=int
name=signal_period
description=对于信号移动平均值周期数计算.
</parameter>
<parameter>
type=int
name=applied_price
description=应用的价格。 它可以是<a href="help://constants_prices">应用价格列举</a>的任意值.
</parameter>
<parameter>
type=int
name=mode
description=指标行数组索引。它可以是 <a href="help://constants_lines">指标识别符列举</a>的任意值.
</parameter>
<parameter>
type=int
name=shift
description=从显示缓冲采取的值的索引(转移相对当前柱特定相当数量期间前).
</parameter>
</function>
<function>
tag=indicators_iOBV
caption=iOBV()
type=double
<keywords>
;iOBV() - On Balance Volume;
</keywords>
<content>
      计算能量潮指标并返回它的值。
</content>
<example>
  double val=iOBV(NULL, 0, PRICE_CLOSE, 1);
</example>
<parameter>
type=string
name=symbol
description=计算指标数据上的货币对名称. NULL表示当前货币对.
</parameter>
<parameter>
type=int
name=timeframe
description=时间周期。 可以<a href="help://constants_timeframes">时间周期列举</a>任意值. 0表示当前图表的时间周期.
</parameter>
<parameter>
type=int
name=applied_price
description=应用的价格。 它可以是<a href="help://constants_prices">应用价格列举</a>的任意值.
</parameter>
<parameter>
type=int
name=shift
description=从显示缓冲采取的值的索引(转移相对当前柱特定相当数量期间前).
</parameter>
</function>
<function>
tag=indicators_iSAR
caption=iSAR()
type=double
<keywords>
;iSAR() - Parabolic SAR;
</keywords>
<content>
      计算抛物线状止损和反转指标并返回它的值。
</content>
<example>
if(iSAR(NULL,0,0.02,0.2,0)&gt;Close[0]) return(0);
</example>
<parameter>
type=string
name=symbol
description=计算指标数据上的货币对名称. NULL表示当前货币对.
</parameter>
<parameter>
type=int
name=timeframe
description=时间周期。 可以<a href="help://constants_timeframes">时间周期列举</a>任意值. 0表示当前图表的时间周期.
</parameter>
<parameter>
type=double
name=step
description=增值, 通常 0.02.
</parameter>
<parameter>
type=double
name=maximum
description=最大值，通常 0.2.
</parameter>
<parameter>
type=int
name=shift
description=从显示缓冲采取的值的索引(转移相对当前柱特定相当数量期间前).
</parameter>
</function>
<function>
tag=indicators_iRSI
caption=iRSI()
type=double
<keywords>
;iRSI() - Relative Strength Index;
</keywords>
<content>
     计算相对强弱索引指标并返回它的值。
</content>
<example>
if(iRSI(NULL,0,14,PRICE_CLOSE,0)&gt;iRSI(NULL,0,14,PRICE_CLOSE,1)) return(0);
</example>
<parameter>
type=string
name=symbol
description=计算指标数据上的货币对名称. NULL表示当前货币对.
</parameter>
<parameter>
type=int
name=timeframe
description=时间周期。 可以<a href="help://constants_timeframes">时间周期列举</a>任意值. 0表示当前图表的时间周期.
</parameter>
<parameter>
type=int
name=period
description=周期数字的计算.
</parameter>
<parameter>
type=int
name=applied_price
description=应用的价格。 它可以是<a href="help://constants_prices">应用价格列举</a>的任意值.
</parameter>
<parameter>
type=int
name=shift
description=从显示缓冲采取的值的索引(转移相对当前柱特定相当数量期间前).
</parameter>
</function>
<function>
tag=indicators_iRSIOnArray
caption=iRSIOnArray()
type=double
<keywords>
;iRSIOnArray() - Relative Strength Index on buffer;
</keywords>
<content>
       计算相对强弱索引指标在不同数组上的数据存储。与不同iRSI(...), the iRSIOnArray 函数不由标志名字， 时间周期，应用的价格采取数据。 必须提前准备价格数据。 指标从左到右被计算。 要对数组元素至于系列列阵(即，从右到左)访问，你必须使用 <a href="help://array_ArraySetAsSeries">ArraySetAsSeries</a> 函数.
</content>
<example>
if(iRSIOnArray(ExtBuffer,1000,14,0)&gt;iRSI(NULL,0,14,PRICE_CLOSE,1)) return(0);
</example>
<parameter>
type=double
name=<nobr>array[]</nobr>
description=数据数组.
</parameter>
<parameter>
type=int
name=total
description=将计数的项目的数量.
</parameter>
<parameter>
type=int
name=period
description=计算价格变化的周期.
</parameter>
<parameter>
type=int
name=shift
description=从显示缓冲采取的值的索引(转移相对当前柱特定相当数量期间前).
</parameter>
</function>
<function>
tag=indicators_iRVI
caption=iRVI()
type=double
<keywords>
;iRVI() - Relative Vigor Index;
</keywords>
<content>
      计算相对活力索引指标并返回它的值。
</content>
<example>
  double val=iRVI(NULL, 0, 10,MODE_MAIN,0);
</example>
<parameter>
type=string
name=symbol
description=计算指标数据上的货币对名称. NULL表示当前货币对.
</parameter>
<parameter>
type=int
name=timeframe
description=时间周期。 可以<a href="help://constants_timeframes">时间周期列举</a>任意值. 0表示当前图表的时间周期.
</parameter>
<parameter>
type=int
name=period
description=周期数字的计算.
</parameter>
<parameter>
type=int
name=mode
description=指标行数组索引。它可以是 <a href="help://constants_lines">指标识别符列举</a>的任意值.
</parameter>
<parameter>
type=int
name=shift
description=从显示缓冲采取的值的索引(转移相对当前柱特定相当数量期间前).
</parameter>
</function>
<function>
tag=indicators_iStdDev
caption=iStdDev()
type=double
<keywords>
;iStdDev() - Standard Deviation;
</keywords>
<content>
     计算标准偏差指标并返回它的值。
</content>
<example>
double val=iStdDev(NULL,0,10,0,MODE_EMA,PRICE_CLOSE,0);
</example>
<parameter>
type=string
name=symbol
description=计算指标数据上的货币对名称. NULL表示当前货币对.
</parameter>
<parameter>
type=int
name=timeframe
description=时间周期。 可以<a href="help://constants_timeframes">时间周期列举</a>任意值. 0表示当前图表的时间周期.
</parameter>
<parameter>
type=int
name=ma_period
description=MA 周期.
</parameter>
<parameter>
type=int
name=ma_shift
description=MA 移动.
</parameter>
<parameter>
type=int
name=ma_method
description=MA方法。 它可以是其中任意 <a href="help://constants_movings">滑动平均值列举</a> 值.
</parameter>
<parameter>
type=int
name=applied_price
description=应用的价格。 它可以是<a href="help://constants_prices">应用价格列举</a>的任意值.
</parameter>
<parameter>
type=int
name=shift
description=从显示缓冲采取的值的索引(转移相对当前柱特定相当数量期间前).
</parameter>
</function>
<function>
tag=indicators_iStdDevOnArray
caption=iStdDevOnArray()
type=double
<keywords>
;iStdDevOnArray() - Standard Deviation on buffer;
</keywords>
<content>
       计算标准离差索引指标在不同数组上的数据存储。与不同 iStdDev(...), the iStdDevOnArray 函数不由标志名字， 时间周期，应用的价格采取数据。 必须提前准备价格数据。 指标从左到右被计算。 要对数组元素至于系列列阵(即，从右到左)访问，你必须使用 <a href="help://array_ArraySetAsSeries">ArraySetAsSeries</a> 函数.
</content>
<example>
double val=iStdDevOnArray(ExtBuffer,100,10,0,MODE_EMA,0);
</example>
<parameter>
type=double
name=<nobr>array[]</nobr>
description=数据数组.
</parameter>
<parameter>
type=int
name=total
description=将计数的项目的数量.
</parameter>
<parameter>
type=int
name=ma_period
description=MA 周期.
</parameter>
<parameter>
type=int
name=ma_shift
description=MA 移动.
</parameter>
<parameter>
type=int
name=ma_method
description=MA方法。 它可以是其中任意 <a href="help://constants_movings">滑动平均值列举</a> 值.
</parameter>
<parameter>
type=int
name=shift
description=从显示缓冲采取的值的索引(转移相对当前柱特定相当数量期间前).
</parameter>
</function>
<function>
tag=indicators_iStochastic
caption=iStochastic()
type=double
<keywords>
;iStochastic() - Stochastic Oscillator;
</keywords>
<content>
     计算随机震荡指标并返回它的值。
</content>
<example>
  if(iStochastic(NULL,0,5,3,3,MODE_SMA,0,MODE_MAIN,0)&gt;iStochastic(NULL,0,5,3,3,MODE_SMA,0,MODE_SIGNAL,0))
    return(0);
</example>
<parameter>
type=string
name=symbol
description=计算指标数据上的货币对名称. NULL表示当前货币对.
</parameter>
<parameter>
type=int
name=timeframe
description=时间周期。 可以<a href="help://constants_timeframes">时间周期列举</a>任意值. 0表示当前图表的时间周期.
</parameter>
<parameter>
type=int
name=%Kperiod
description=%K 周期线。.
</parameter>
<parameter>
type=int
name=%Dperiod
description=%D周期线.
</parameter>
<parameter>
type=int
name=slowing
description=滚动值.
</parameter>
<parameter>
type=int
name=method
description=MA方法。 它可以是其中任意 <a href="help://constants_movings">滑动平均值列举</a> 值.
</parameter>
<parameter>
type=int
name=price_field
description=价格参量.可以是以下值: 0 - Low/High 或者 1 - Close/Close.
</parameter>
<parameter>
type=int
name=mode
description=指标行数组索引。它可以是 <a href="help://constants_lines">指标识别符列举</a>的任意值.
</parameter>
<parameter>
type=int
name=shift
description=从显示缓冲采取的值的索引(转移相对当前柱特定相当数量期间前).
</parameter>
</function>
<function>
tag=indicators_iWPR
caption=iWPR()
type=double
<keywords>
;iWPR() - William's Percent Range;
</keywords>
<content>
     计算威廉指标并返回它的值。
</content>
<example>
if(iWPR(NULL,0,14,0)&gt;iWPR(NULL,0,14,1)) return(0);
</example>
<parameter>
type=string
name=symbol
description=计算指标数据上的货币对名称. NULL表示当前货币对.
</parameter>
<parameter>
type=int
name=timeframe
description=时间周期。 可以<a href="help://constants_timeframes">时间周期列举</a>任意值. 0表示当前图表的时间周期.
</parameter>
<parameter>
type=int
name=period
description=周期数字计算.
</parameter>
<parameter>
type=int
name=shift
description=从显示缓冲采取的值的索引(转移相对当前柱特定相当数量期间前).
</parameter>
</function>
</group>
<group>
tag=series
caption=Timeseries access
<keywords>
;Timeseries access;
</keywords>
<content>
        任何可见货币对/时间周期的价格数据的一组函数。<br/>
        <br/>
   。如果请求数据(货币对名称/时间周期不同于当前图表)来自其他图表，这种情况可能使相应的图表不能在客户端内打开，并且需要从服务器上请求数据。这种情况下，
    <a href="help://constants_errors">错误</a> ERR_HISTORY_WILL_UPDATED (4066 - 请求历史数据并刷新)将被放置于<a href="help://runtime_errors">last_error</a>变量中，并且可以重新请求(查看<a href="help://array_ArrayCopySeries">ArrayCopySeries()</a>范例)。<br/><br/>
   在测试中，相同货币对但不同时间周期的价格价位被塑造（除成交量外）。其他货币对的价格数据不被塑造。这些情况下，在时间数组的 <a href="help://series_iBars">柱</a>总数被塑造。

</content>
<function>
tag=series_iBars
caption=iBars()
type=int
<keywords>
;iBars();
</keywords>
<content>
     在指定的图表内返回柱的数量。
<br/>
      对于当前图表柱总量的信息在预定义的变量中命名为<a href="help://predefined_variables_Bars">Bars</a>。
</content>
<example>
  Print(&quot;在货币对'EUROUSD'带有PERIOD_H1 柱数&quot;,iBars(&quot;EUROUSD&quot;,PERIOD_H1));
</example>
<parameter>
type=string
name=symbol
description=需应用到计算指标的货币对数据 NULL 意味当前货币对名称。
</parameter>
<parameter>
type=int
name=timeframe
description=时间周期。可以是<a href="help://constants_timeframes">时间周期列举</a>的任意值。0 意味着当前图表的时间周期。
</parameter>
</function>
<function>
tag=series_iBarShift
caption=iBarShift()
type=int
<keywords>
;iBarShift();
</keywords>
<content>
搜索柱开始的时间。函数返回指定开始时间的柱。如果柱的指定开始时间是省缺值， 函数将返回-1或 最近的柱 <i>exact</i>。<br/>
</content>
<example>
  datetime some_time=D'2004.03.21 12:00';
  int      shift=iBarShift(&quot;EUROUSD&quot;,PERIOD_M1,some_time);
  Print(&quot;带有打开时间平移柱 &quot;,TimeToStr(some_time),&quot; 是 &quot;,shift);
</example>
<parameter>
type=string
name=symbol
description=需应用到计算指标的货币对数据 NULL 意味当前货币对名称。。
</parameter>
<parameter>
type=int
name=timeframe
description=时间周期。可以是<a href="help://constants_timeframes">时间周期列举</a>的任意值。0 意味着当前图表的时间周期。
</parameter>
<parameter>
type=datetime
name=time
description=查找值 (柱的开始时间)。
</parameter>
<parameter>
type=
name=exact
description=未发现柱的返回模式。false - iBarShift 返回最近。 true - iBarShift 返回 -1。
</parameter>
</function>
<function>
tag=series_iClose
caption=iClose()
type=double
<keywords>
;iClose();
</keywords>
<content>
      对于带<i>有时间周<i>期和<i>平移<i>指定货币对的柱返回 <b>关闭</b>值。如果加载历史为空，函数返回0。<br/>
      对于当前图表，关于收盘价格的信息在预定义数组中命名为 <a href="help://predefined_variables_Close">Close[]</a>。
</content>
<example>
  Print(&quot;对于 USDCHF H1当前柱: &quot;,iTime(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,  iOpen(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,
                                      iHigh(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,  iLow(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,
                                      iClose(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;, iVolume(&quot;USDCHF&quot;,PERIOD_H1,i));
</example>
<parameter>
type=string
name=symbol
description=需应用到计算指标的货币对数据 NULL 意味当前货币对名称。
</parameter>
<parameter>
type=int
name=timeframe
description=时间周期。可以是<a href="help://constants_timeframes">时间周期列举</a>的任意值。0 意味着当前图表的时间周期。
</parameter>
<parameter>
type=int
name=shift
description=从指标缓冲器上获取的索引值。
</parameter>
</function>
<function>
tag=series_iHigh
caption=iHigh()
type=double
<keywords>
;iHigh();
</keywords>
<content>
        对于带<i>有时间周<i>期和<i>平移<i>指定<i>货币对</i> 的柱返回 <b>高</b>值。如果加载历史为空，函数返回0。<br/>
       对于当前图表，关于高价格的信息在预定义数组中命名为<a href="help://predefined_variables_High">High[]</a>.
</content>
<example>
  Print(&quot;对于USDCHF H1当前柱: &quot;,iTime(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,  iOpen(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,
                                      iHigh(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,  iLow(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,
                                      iClose(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;, iVolume(&quot;USDCHF&quot;,PERIOD_H1,i));
</example>
<parameter>
type=string
name=symbol
description=需应用到计算指标的货币对数据 NULL 意味当前货币对名称。
</parameter>
<parameter>
type=int
name=timeframe
description=时间周期。可以是<a href="help://constants_timeframes">时间周期列举</a>的任意值。0 意味着当前图表的时间周期。
</parameter>
<parameter>
type=int
name=shift
description=从指标缓冲器上获取的索引值。
</parameter>
</function>
<function>
tag=series_iHighest
caption=iHighest()
type=int
<keywords>
;iHighest();
</keywords>
<content>
  根据类型返回最大值转移的一个具体数字。
</content>
<example>
  double val;
  // 在范围内20个连续柱计算最大值
  // 在当前图表上从第4个至第23个的索引
  val=High[iHighest(NULL,0,MODE_HIGH,20,4)];
</example>
<parameter>
type=string
name=symbol
description=需应用到计算指标的货币对数据 NULL 意味当前货币对名称。。
</parameter>
<parameter>
type=int
name=timeframe
description=时间周期。可以是<a href="help://constants_timeframes">时间周期列举</a>的任意值。0 意味着当前图表的时间周期。
</parameter>
<parameter>
type=int
name=type
description=系列数组的识别符。它可以是<a href="help://constants_series">系列数据识别符列举</a> 的任意值。
</parameter>
<parameter>
type=
name=count
description=周期数字。
</parameter>
<parameter>
type=
name=start
description=移动显示与当前相关的柱，采取数据。
</parameter>
</function>
<function>
tag=series_iLow
caption=iLow()
type=double
<keywords>
;iLow();
</keywords>
<content>
      对于带<i>有时间周<i>期和<i>平移<i>指定<i>货币对</i> 的柱返回 <b>低</b>值。如果加载历史为空，函数返回0。<br/>
       对于当前图表，关于低价格的信息在预定义数组中命名为<a href="help://predefined_variables_Low">Low[]</a>.
</content>
<example>
  Print(&quot;对于USDCHF H1当前柱: &quot;,iTime(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,  iOpen(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,
                                      iHigh(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,  iLow(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,
                                      iClose(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;, iVolume(&quot;USDCHF&quot;,PERIOD_H1,i));
</example>
<parameter>
type=string
name=symbol
description=需应用到计算指标的货币对数据 NULL 意味当前货币对名称。。
</parameter>
<parameter>
type=int
name=timeframe
description=时间周期。可以是<a href="help://constants_timeframes">时间周期列举</a>的任意值。0 意味着当前图表的时间周期。
</parameter>
<parameter>
type=int
name=shift
description=从指标缓冲器上获取的索引值。
</parameter>
</function>
<function>
tag=series_iLowest
caption=iLowest()
type=int
<keywords>
;iLowest();
</keywords>
<content>
     根据类型返回最小值转移的一个具体数字。
</content>
<example>
// 在范围内计算连续10个柱的最低值
// 在当前图表从第10个到第19个的索引
double val=Low[iLowest(NULL,0,MODE_LOW,10,10)];
</example>
<parameter>
type=string
name=symbol
description=需应用到计算指标的货币对数据 NULL 意味当前货币对名称。。
</parameter>
<parameter>
type=int
name=timeframe
description=时间周期。可以是时间周期列举的任意值。0 意味着当前图表的时间周期。
</parameter>
<parameter>
type=int
name=type
description=系列数组的识别符。它可以是<a href="help://constants_series">系列数据识别符列举</a> 的任意值。
</parameter>
<parameter>
type=
name=count
description=时间周期。
</parameter>
<parameter>
type=
name=start
description=移动显示与当前相关的柱，采取数据。
</parameter>
</function>
<function>
tag=series_iOpen
caption=iOpen()
type=double
<keywords>
;iOpen();
</keywords>
<content>
       对于带<i>有时间周<i>期和<i>平移<i>指定<i>货币对</i> 的柱返回 <b>开价格</b>值。如果加载历史为空，函数返回0。<br/>
       对于当前图表，关于开价格的信息在预定义数组中命名为 <a href="help://predefined_variables_Open">Open[]</a>.
</content>
<example>
  Print(&quot;对于USDCHF H1当前柱: &quot;,iTime(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,  iOpen(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,
                                      iHigh(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,  iLow(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,
                                      iClose(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;, iVolume(&quot;USDCHF&quot;,PERIOD_H1,i));
</example>
<parameter>
type=string
name=symbol
description=需应用到计算指标的货币对数据 NULL 意味当前货币对名称。。
</parameter>
<parameter>
type=int
name=timeframe
description=时间周期。可以是<a href="help://constants_timeframes">时间周期列举</a>的任意值。0 意味着当前图表的时间周期。
</parameter>
<parameter>
type=int
name=shift
description=从指标缓冲器上获取的价格值指数。
</parameter>
</function>
<function>
tag=series_iTime
caption=iTime()
type=datetime
<keywords>
;iTime();
</keywords>
<content>
       对于带<i>有时间周<i>期和<i>平移<i>指定<i>货币对</i> 的柱返回 <b>时间</b>值。如果加载历史为空，函数返回0。<br/>
       对于当前图表，关于时间的信息在预定义数组中命名<a href="help://predefined_variables_Time">Time[]</a>.
</content>
<example>
  Print(&quot;对于USDCHF H1当前货币对: &quot;,iTime(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,  iOpen(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,
                                      iHigh(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,  iLow(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,
                                      iClose(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;, iVolume(&quot;USDCHF&quot;,PERIOD_H1,i));
</example>
<parameter>
type=string
name=symbol
description=需应用到计算指标的货币对数据 NULL 意味当前货币对名称。。
</parameter>
<parameter>
type=int
name=timeframe
description=时间周期。可以是<a href="help://constants_timeframes">时间周期列举</a>的任意值。0 意味着当前图表的时间周期。
</parameter>
<parameter>
type=int
name=shift
description=从指标缓冲器上获取的价格值指数。
</parameter>
</function>
<function>
tag=series_iVolume
caption=iVolume()
type=double
<keywords>
;iVolume();
</keywords>
<content>
      对于带<i>有时间周<i>期和<i>平移<i>指定<i>货币对</i> 的柱返回 <b>替克成交量</b>值。如果加载历史为空，函数返回0。<br/>
       对于当前图表，关于成交量的信息在预定义数组中命名<a href="help://predefined_variables_Volume">Volume[]</a>.
</content>
<example>
  Print(&quot;对于USDCHF H1的当前柱: &quot;,iTime(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,  iOpen(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,
                                      iHigh(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,  iLow(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;,
                                      iClose(&quot;USDCHF&quot;,PERIOD_H1,i),&quot;, &quot;, iVolume(&quot;USDCHF&quot;,PERIOD_H1,i));
</example>
<parameter>
type=string
name=symbol
description=需应用到计算指标的货币对数据 NULL 意味当前货币对名称。。
</parameter>
<parameter>
type=int
name=timeframe
description=时间周期。可以是<a href="help://constants_timeframes">时间周期列举</a>的任意值。0 意味着当前图表的时间周期。
</parameter>
<parameter>
type=int
name=shift
description=从指标缓冲器上获取的价格值指数。
</parameter>
</function>
</group>
<group>
tag=trading
caption=Trading functions
<keywords>
;Trading functions;
</keywords>
<content>
        交易管理的一组函数。<br/><br/>
   从自定义指标中不能调用<a href="help://trading_OrderSend">OrderSend()</a>, <a href="help://trading_OrderClose">OrderClose</a>,
    <a href="help://trading_OrderCloseBy">OrderCloseBy</a>, <a href="help://trading_OrderDelete">OrderDelete</a>和<a href="help://trading_OrderModify">OrderModify</a>
    交易函数。<br/><br/>
   交易函数应用于智能交易和脚本中。如果检验智能交易的“允许实事交易”属性，交易函数不能调用。<br/><br/>
   来自智能交易和脚本的交易在程序中只能有一个开启。这就是为什么如果交易业务忙，其他交易或脚本在此时不能调用的原因，由于<a href="help://constants_errors">错误</a> 146 (ERR_TRADE_CONTEXT_BUSY)。
   使用<a href="help://check_IsTradeAllowed">IsTradeAllowed()</a>函数检测交易或没有交易。 
    弄清交易访问模式，可以使用改变<a href="help://globals_GlobalVariableSetOnCondition">GlobalVariableSetOnCondition()</a>函数整体变量值。

</content>
<text>
tag=trading_errors
caption=Execution errors
<keywords>
;Execution errors;ERR_NO_ERROR;ERR_NO_RESULT;ERR_COMMON_ERROR;ERR_INVALID_TRADE_PARAMETERS;ERR_SERVER_BUSYERR_OLD_VERSION;ERR_NO_CONNECTION;ERR_TOO_FREQUENT_REQUESTSERR_ACCOUNT_DISABLED;ERR_INVALID_ACCOUNT;ERR_TRADE_TIMEOUT;ERR_INVALID_PRICE;ERR_INVALID_STOPSERR_INVALID_TRADE_VOLUME;ERR_MARKET_CLOSED;ERR_TRADE_DISABLED;ERR_NOT_ENOUGH_MONEY;ERR_PRICE_CHANGEDERR_OFF_QUOTES;ERR_REQUOTE;ERR_ORDER_LOCKED;ERR_LONG_POSITIONS_ONLY_ALLOWEDERR_TOO_MANY_REQUESTS;ERR_TRADE_MODIFY_DENIED;ERR_TRADE_CONTEXT_BUSY;ERR_TRADE_EXPIRATION_DENIED;
</keywords>
<content>
            <p>任何交易业务(<a href="help://trading_OrderSend">OrderSend()</a>, <a href="help://trading_OrderClose">OrderClose</a>,
        <a href="help://trading_OrderCloseBy">OrderCloseBy</a>, <a href="help://trading_OrderDelete">OrderDelete</a> 和 <a href="help://trading_OrderModify">OrderModify</a>函数)都会因为一些原因导致失败，并且返回负值<a href="help://trading_OrderSend">票据数</a> 或FALSE。
        您可以查看<a href="help://check_GetLastError">GetLastError()</a>函数得知错误的问题所在。
         每一个错误必须以不同的方式加以处理。最常见的建议列举如下：</p>
        <p>从交易服务器返回的错误代码</p>
        <table cellspacing="0" cellpadding="4" border="0" class="docenums" width="95%">
        <tr><th width="15%">常数</th><th width="10%">值</th><th width="75%">描述</th></tr>
        <tr><td>ERR_NO_ERROR</td><td>0</td><td>交易业务成功。</td></tr>
        <tr><td>ERR_NO_RESULT</td><td>1</td>
        <td><a href="help://trading_OrderModify">OrderModify</a>
        尝试去还原已经设定好的相同值。一个或多个值必须改变，然后修改尝试重复.</td>
        </tr>
        <tr><td>ERR_COMMON_ERROR</td><td>2</td><td>常规错误。直到错误清晰为止，所有交易必须停止运行。
        如果需要客户端的交易系统必须重启。</td></tr>
        <tr><td>ERR_INVALID_TRADE_参量</td><td>3</td>
        <td>无效参量，
         例如, 货币对错误,未知
                                                 <a href="help://constants_trading">交易业务</a>,
                                                 不存在票数等等。程序逻辑必须修改。</td>
        </tr>
        <tr><td>ERR_SERVER_BUSY</td><td>4</td><td>交易服务器忙。稍后请重新尝试。</td></tr>
        <tr><td>ERR_OLD_VERSION</td><td>5</td><td>客户端的旧版本。客户端的最新版本必须初始化。</td></tr>
        <tr><td>ERR_NO_CONNECTION</td><td>6</td>
        <td>交易服务器没有联接。需要确认连接没有断开(例如，应用
                                                  <a href="help://check_IsConnected">IsConnected</a> 函数)
                                                在5秒之后重试。 </td>
        </tr>
        <tr><td>ERR_TOO_FREQUENT_REQUESTS</td><td>8</td><td>请求过于频繁。过于频繁的请求必须减少，程序逻辑需要改变。</td></tr>
        <tr><td>ERR_ACCOUNT_DISABLED</td><td>64</td><td>账户被禁止。所有运行交易必须停止。</td></tr>
        <tr><td>ERR_INVALID_ACCOUNT</td><td>65</td><td>账号无效。所有运行交易必须停止。</td></tr>
        <tr><td>ERR_TRADE_TIMEOUT</td><td>128</td><td>交易超时。在重试前必须确认交易业务确实没有成功（存在未修改或未删除的定单）</td></tr>
        <tr><td>ERR_INVALID_PRICE</td><td>129</td>
        <td>无效开价格或报价格。稍后必须刷新
                                                 <a href="help://predefined_variables">数据</a>应用

                                                 /RefreshRates.html">RefreshRates</a>函数重试。
                                                如果错误没有消失，尝试停止所有运行交易，改变程序逻辑。</td>
        </tr>
        <tr><td>ERR_INVALID_STOPS</td><td>130</td>
        <td>Stops 太近或是价格计算错误。
        需要刷新<a href="help://predefined_variables">数据
                                                 /RefreshRates.html">RefreshRates</a> 函数重试
                                                如果错误没有消失，尝试停止所有运行交易，改变程序逻辑。</td>
        </tr>
        <tr><td>ERR_INVALID_TRADE_VOLUME</td><td>131</td>
        <td>无效交易值。
       尝试停止所有运行交易，改变程序逻辑。</td>
        </tr>
        <tr><td>ERR_MARKET_CLOSED</td><td>132</td><td>市场关闭。稍后重新尝试。</td></tr>
        <tr><td>ERR_TRADE_DISABLED</td><td>133</td><td>交易被禁止。所有运行交易必须停止。</td></tr>
        <tr><td>ERR_NOT_ENOUGH_MONEY</td><td>134</td><td>没有足够的资金。带有相同参量的交易必须重复。稍后用小额的资金重试，
       确定没有足够的资金完成交易。</td></tr>
        <tr><td>ERR_PRICE_CHANGED</td><td>135</td><td>

        数据应用<a href="help://windows_RefreshRates">RefreshRates</a> 函数重试。                                             </td>
        </tr>
        <tr><td>ERR_OFF_QUOTES</td><td>136</td>
        <td>没有报价格

        数据应用<a href="help://windows_RefreshRates">RefreshRates</a> 函数重试。</td>
        </tr>
        <tr><td>ERR_REQUOTE</td><td>138</td>
        <td>重新请求报价格。刷新<a href="help://predefined_variables">数据</a>
        可以应用 <a href="help://windows_RefreshRates">RefreshRates</a>
                                                  函数重试。
                                                 如果错误没有消失，尝试停止所有运行交易，改变程序逻辑。</td>
        </tr>
        <tr><td>ERR_ORDER_LOCKED</td><td>139</td><td>交易定单被锁住。尝试停止所有运行交易，改变程序逻辑。</td></tr>
        <tr><td>ERR_LONG_POSITIONS_ONLY_ALLOWED</td><td>140</td><td>只允许买进。SELL不再重复。</td></tr>
        <tr><td>ERR_TOO_MANY_REQUESTS</td><td>141</td>
        <td>请求过多。 过多的请求必须减少，程序逻辑需要改变。
        </tr>
        <tr><td>&nbsp;</td><td>142</td><td> 定单按次序排列。它不是一个错误,而是客户端和服务器交易之间一个代码。当断开或重新连接执行交易时，
        这种代码的出现次数非常少。此代码与误差128 一样处理。</td></tr>
        <tr><td>&nbsp;</td><td>143</td><td>定单已经被执行交易商接受。它不是一个错误,而是客户端和服务器交易之间一个代码。当断开或重新连接执行交易时，
        这种代码的出现次数非常少。此代码与误差128 一样处理。</td></tr>
        <tr><td>&nbsp;</td><td>144</td><td>在手动确认期间定单已经被客户放弃。它不是一个错误,而是客户端和服务器交易之间一个代码。</td></tr>
        <tr><td>ERR_TRADE_MODIFY_DENIED</td><td>145</td>
        <td>修改被否定。由于太近或被锁定。

        数据</a> 应用<a href="help://windows_RefreshRates">RefreshRates</a> 函数重试。 </td>
        </tr>
        <tr><td>ERR_TRADE_CONTEXT_BUSY</td><td>146</td><td>交易繁忙。只有在<a href="help://check_IsTradeContextBusy">IsTradeContextBusy</a>函数错误返回后重试。</td></tr>
        <tr><td>ERR_TRADE_EXPIRATION_DENIED</td><td>147</td><td>否定挂单交易期限。如果期限为零可以重试。</td></tr>
        <tr><td>ERR_TRADE_TOO_MANY_ORDERS</td><td>148</td><td>开仓和挂单交易总数已经达到经纪人设定。
        只有在现有仓位关闭或删除之后才可以开新仓位或挂单。</td></tr>
        <tr><td>ERR_TRADE_HEDGE_PROHIBITED</td><td>149</td>
                <td>在对冲被禁止的情况下试图开立与原有仓位相反的仓位， 首先必须平掉现有仓位，停止所有此类交易操作或者更改程序逻辑。</td></tr>
        <tr><td>ERR_TRADE_PROHIBITED_BY_FIFO</td><td>150</td>
                <td>尝试关闭违反FIFO规则的仓位， 首先平掉之前的仓位，停止所有此类交易操作或者更改程序逻辑。</td></tr>
        </table><br ="/">

</content>
</text>
<function>
tag=trading_OrderClose
caption=OrderClose()
type=bool
<keywords>
;OrderClose();
</keywords>
<content>
对定单进行平仓操作。 
如果函数成功，返回的值是真实的。
如果函数失败，返回的值是假的。
获得详细错误信息，请查看<a href="help://check_GetLastError">GetLastError()</a>函数。
</content>
<example>
  if(iRSI(NULL,0,14,PRICE_CLOSE,0)&gt;75)
    {
     OrderClose(order_id,1,Ask,3,Red);
     return(0);
    }
</example>
<parameter>
type=int
name=ticket
description=定单编号。
</parameter>
<parameter>
type=double
name=lots
description=手数。
</parameter>
<parameter>
type=double
name=price
description=收盘价格。
</parameter>
<parameter>
type=int
name=slippage
description=最高划点数。
</parameter>
<parameter>
type=
name=Color
description=图表中标记颜色。如果参量丢失，CLR_NONE值将不会在图表中画出。
</parameter>
</function>
<function>
tag=trading_OrderCloseBy
caption=OrderCloseBy()
type=bool
<keywords>
;OrderCloseBy();
</keywords>
<content>
用相反定单对打开仓位进行平仓操作。
如果函数成功，返回的值是真实的。
如果函数失败，返回的值是假的。
获得详细错误信息，请查看<a href="help://check_GetLastError">GetLastError()</a>函数。
</content>
<example>
  if(iRSI(NULL,0,14,PRICE_CLOSE,0)&gt;75)
    {
     OrderCloseBy(order_id,opposite_id);
     return(0);
    }
</example>
<parameter>
type=int
name=ticket
description=定单编号。
</parameter>
<parameter>
type=int
name=opposite
description=相对定单编号
</parameter>
<parameter>
type=
name=Color
description=图表中标记颜色。如果参量丢失，CLR_NONE值将不会在图表中画出
</parameter>
</function>
<function>
tag=trading_OrderClosePrice
caption=OrderClosePrice()
type=double
<keywords>
;OrderClosePrice();
</keywords>
<content>
对于当前选择定单返回收盘价格。<br/>
注解:定单必须用<a href="help://trading_OrderSelect">OrderSelect()</a>函数提前选定。
</content>
<example>
  if(OrderSelect(ticket,SELECT_BY_POS)==true)
    Print(&quot;对于定单 &quot;，定单编号&quot; = &quot;,OrderClosePrice()的收盘价格);
  else
    Print(&quot;OrderSelect 失败错误代码是&quot;,GetLastError());
</example>
</function>
<function>
tag=trading_OrderCloseTime
caption=OrderCloseTime()
type=datetime
<keywords>
;OrderCloseTime();
</keywords>
<content>
对于当前选择定单返回平仓时间。
如果定单时间不是0，所选定单会从账户历史重新尝试。开仓和挂单交易平仓时间必须等于 0。<br/>
注解:定单必须用<a href="help://trading_OrderSelect">OrderSelect()</a>函数提前选定。
</content>
<example>
  if(OrderSelect(10,SELECT_BY_POS,MODE_HISTORY)==true)
    {
     datetime ctm=OrderOpenTime();
     if(ctm&gt;0) Print(&quot;定单10 &quot;开仓时间, ctm);
     ctm=OrderCloseTime();
     if(ctm&gt;0) Print(&quot;定单 10 &quot;平仓时间, ctm);
    }
  else
    Print(&quot;OrderSelect失败错误代码是&quot;,GetLastError());
</example>
</function>
<function>
tag=trading_OrderComment
caption=OrderComment()
type=string
<keywords>
;OrderComment();
</keywords>
<content>
返回定单的注释。<br/>
注解:定单必须用<a href="help://trading_OrderSelect">OrderSelect()</a>函数提前选定。
</content>
<example>
  string comment;
  if(OrderSelect(10,SELECT_BY_TICKET)==false)
    { Print(&quot;OrderSelect 失败错误代码是&quot;,GetLastError());
     return(0);
    }
  comment = OrderComment();
  // ...
</example>
</function>
<function>
tag=trading_OrderCommission
caption=OrderCommission()
type=double
<keywords>
;OrderCommission();
</keywords>
<content>
返回定单的佣金数。<br/>
注解:定单必须用<a href="help://trading_OrderSelect">OrderSelect()</a>函数提前选定。
</content>
<example>
  if(OrderSelect(10,SELECT_BY_POS)==true)
    Print(&quot;定单10 &quot;佣金,OrderCommission());
  else
   Print(&quot;OrderSelect 失败错误代码是&quot;,GetLastError());
</example>
</function>
<function>
tag=trading_OrderDelete
caption=OrderDelete()
type=bool
<keywords>
;OrderDelete();
</keywords>
<content>
删除先前打开挂单。
如果函数成功，返回的值是真实的。
如果函数失败，返回的值是假的。
获得详细错误信息，请查看<a href="help://check_GetLastError">GetLastError()</a>函数。
</content>
<example>
  if(Ask&gt;var1)
    {
     OrderDelete(order_ticket);
     return(0);
    }
</example>
<parameter>
type=int
name=ticket
description=定单编号。
</parameter>
<parameter>
type=
name=Color
description=图表中标记颜色。如果参量丢失，CLR_NONE值将不会在图表中画出。
</parameter>
</function>
<function>
tag=trading_OrderExpiration
caption=OrderExpiration()
type=datetime
<keywords>
;OrderExpiration();
</keywords>
<content>
返回挂单的有效日期。<br/>
注解:定单必须用<a href="help://trading_OrderSelect">OrderSelect()</a>函数提前选定。
</content>
<example>
  if(OrderSelect(10, SELECT_BY_TICKET)==true)
    Print(&quot;定单 #10 有效日期为&quot;,OrderExpiration());
  else
    Print(&quot;OrderSelect 返回的&quot;,GetLastError()错误);
</example>
</function>
<function>
tag=trading_OrderLots
caption=OrderLots()
type=double
<keywords>
;OrderLots();
</keywords>
<content>
返回选定定单的手数。<br/>
注解:定单必须用<a href="help://trading_OrderSelect">OrderSelect()</a>函数提前选定。
</content>
<example>
  if(OrderSelect(10,SELECT_BY_POS)==true)
    Print(&quot;定单 10 &quot;手数,OrderLots());
  else
    Print(&quot;OrderSelect 返回的 &quot;,GetLastError()错误);
</example>
</function>
<function>
tag=trading_OrderMagicNumber
caption=OrderMagicNumber()
type=int
<keywords>
;OrderMagicNumber();
</keywords>
<content>
返回选定订单的指定编号<br/>
注解:定单必须用<a href="help://trading_OrderSelect">OrderSelect()</a>函数提前选定。
</content>
<example>
  if(OrderSelect(10,SELECT_BY_POS)==true)
    Print(&quot;定单 10 &quot;指定编号, OrderMagicNumber());
  else
    Print(&quot;OrderSelect 返回的 &quot;,GetLastError()错误);
</example>
</function>
<function>
tag=trading_OrderModify
caption=OrderModify()
type=bool
<keywords>
;OrderModify();
</keywords>
<content>
对于先前的开仓或挂单进行特性修改。如果函数成功，返回的值为 TRUE。如果函数失败，返回的值为FALSE。
 获得详细的错误信息,查看 <a href="help://check_GetLastError">GetLastError()</a>函数。<br/>
注解: 开价格和有效时间的改变只对挂单而言。<br/>
如果未改变的值作为函数参量通过，将会生成<a href="help://constants_errors">错误</a> 1 (ERR_NO_RESULT)。<br/>
在一些服务器中挂单的有效时间会被隐藏。这种情况下，当一个非零值在 <i>有效</i>参量被指定时，将生成<a href="help://constants_errors">错误</a> 147 (ERR_TRADE_EXPIRATION_DENIED)。
</content>
<example>
  if(TrailingStop&gt;0)
    {
     OrderSelect(12345,SELECT_BY_TICKET);
     if(Bid-OrderOpenPrice()&gt;Point*TrailingStop)
       {
        if(OrderStopLoss()&lt;Bid-Point*TrailingStop)
          {
           OrderModify(OrderTicket(),OrderOpenPrice(),Bid-Point*TrailingStop,OrderTakeProfit(),0,Blue);
           return(0);
          }
       }
    }
</example>
<parameter>
type=int
name=ticket
description=定单编号。
</parameter>
<parameter>
type=double
name=price
description=收盘价格
</parameter>
<parameter>
type=double
name=stoploss
description=新止损水平。
</parameter>
<parameter>
type=double
name=takeprofit
description=新赢利水平。
</parameter>
<parameter>
type=datetime
name=expiration
description=挂单有效时间。
</parameter>
<parameter>
type=
name=arrow_color
description=在图表中允许对止损/赢利颜色进行修改。如果参量丢失或存在CLR_NONE 值，在图表中将不会显示。
</parameter>
</function>
<function>
tag=trading_OrderOpenPrice
caption=OrderOpenPrice()
type=double
<keywords>
;OrderOpenPrice();
</keywords>
<content>
对于当前选择定单返回开价格。<br/>
定单必须由<a href="help://trading_OrderSelect">OrderSelect()</a> 函数首先选定。
</content>
<example>
  if(OrderSelect(10, SELECT_BY_POS)==true)
    Print(&quot;对于定单10 开价格&quot;,OrderOpenPrice());
  else
    Print(&quot;OrderSelect返回错误&quot;,GetLastError());
</example>
</function>
<function>
tag=trading_OrderOpenTime
caption=OrderOpenTime()
type=datetime
<keywords>
;OrderOpenTime();
</keywords>
<content>
对于当前选择定单返回买入时间。<br/>
注解:定单必须用<a href="help://trading_OrderSelect">OrderSelect()</a>函数提前选定。
</content>
<example>
  if(OrderSelect(10, SELECT_BY_POS)==true)
    Print(&quot;定单10 买入时间&quot;,OrderOpenTime());
  else
    Print(&quot;OrderSelect 返回的错误 &quot;,GetLastError());
</example>
</function>
<function>
tag=trading_OrderPrint
caption=OrderPrint()
type=void
<keywords>
;OrderPrint();
</keywords>
<content>
按照以下形式打印选择定单信息:<br/>
<a href="help://trading_OrderTicket">定单编号;</a> <a href="help://trading_OrderOpenTime">买入时间;</a> <a href="help://trading_OrderType">交易业务；</a>
 <a href="help://trading_OrderLots">手数总数;</a> <a href="help://trading_OrderOpenPrice">开盘价格;</a> <a href="help://trading_OrderStopLoss">止损;</a>
 <a href="help://trading_OrderTakeProfit">赢利;</a> <a href="help://trading_OrderCloseTime">平仓时间;</a> <a href="help://trading_OrderClosePrice">收盘价格;</a>
 <a href="help://trading_OrderCommission">佣金;</a> <a href="help://trading_OrderSwap">掉期;</a> <a href="help://trading_OrderProfit">盈利;</a>
 <a href="help://trading_OrderComment">注释;</a> <a href="help://trading_OrderMagicNumber">指定编码;</a> <a href="help://trading_OrderExpiration">挂单有效日期</a><br/>
定单必须用<a href="help://trading_OrderSelect">OrderSelect()</a>函数提前选定。 
</content>
<example>
  if(OrderSelect(10, SELECT_BY_TICKET)==true)
    OrderPrint();
  else
   Print(&quot;OrderSelect 失败错误代码是&quot;,GetLastError());
</example>
</function>
<function>
tag=trading_OrderProfit
caption=OrderProfit()
type=double
<keywords>
;OrderProfit();
</keywords>
<content>
对于选择定单返回净盈利值 (除掉期和佣金外)。对于开仓位当前不真实盈利。对于平仓为固定盈利。<br/>
对于当前选择定单返回盈利。<br/>
注解:定单必须用<a href="help://trading_OrderSelect">OrderSelect()</a>函数提前选定。
</content>
<example>
  if(OrderSelect(10, SELECT_BY_POS)==true)
    Print(&quot;定单 10 盈利&quot;,OrderProfit());
  else
    Print(&quot;OrderSelect返回的错误&quot;,GetLastError());
</example>
</function>
<function>
tag=trading_OrderSelect
caption=OrderSelect()
type=bool
<keywords>
;OrderSelect();SELECT_BY_POS;SELECT_BY_TICKET;MODE_TRADES;MODE_HISTORY;
</keywords>
<content>
函数选择定单。如果函数成功，返回的值为TRUE。如果函数失败，返回的值为FALSE。
获得详细错误信息，请查看<a href="help://check_GetLastError">GetLastError()</a>函数。<br/>
如果定单编号被选定，此<i>pool</i>参量被认知。此定单编号为唯一识别符。找出所选定单的列表，它的<a href="help://trading_OrderCloseTime">平仓时间</a>必须进行分析。如果定单卖出时间为零， 开单和挂单将从终端位置列表打开。可以从<a href="help://trading_OrderType">定单类型</a>区别开挂单和开单。 如果定单的<a href="help://trading_OrderCloseTime">卖出时间</a>不等于0， <a href="help://trading_OrderClose">平单</a>和<a href="help://trading_OrderDelete">删除</a>定单是在终端历史中被选择。他们同样可以区分<a href="help://trading_OrderType">定单类型</a>。
</content>
<example>
  if(OrderSelect(12470, SELECT_BY_TICKET)==true)
    {
     Print(&quot;定单 #12470 开价格&quot;, OrderOpenPrice());
     Print(&quot;定单 #12470 收盘价格 &quot;, OrderClosePrice());
    }
  else
    Print(&quot;OrderSelect 返回的错误 &quot;,GetLastError());
</example>
<parameter>
type=int
name=index
description=定单索引。
</parameter>
<parameter>
type=int
name=select
description=选定模式。可以为以下的任意值:<br/>SELECT_BY_POS <br/>SELECT_BY_TICKET 。
</parameter>
<parameter>
type=
name=pool
description=可选择定单索引。当选择SELECT_BY_POS参量时使用。可以为以下的任意值:<br/>MODE_TRADES (default)- 来自交易的定单(开单和挂单)，<br/>MODE_HISTORY - 来自历史的定单(平仓和取消定单)。
</parameter>
</function>
<function>
tag=trading_OrderSend
caption=OrderSend()
type=int
<keywords>
;OrderSend();
</keywords>
<content>
这个功能主要应用于开仓位置和挂单交易.
<br/>
由交易服务器返回定单的定单编号或者-1,说明是错误的。获得另外的错误信息, 查看<a href="help://check_GetLastError">GetLastError()</a>函数。<br/>
注解:市场定单的开启(OP_SELL or OP_BUY), 只有最后的卖价格或买价格可以应用到开价格中.
             如果执行当前带有不同证券的业务,必须使用带有MODE_BID 或 MODE_ASK参量的MarketInfo()函数获得.
             预测或是不标准的价格不可用.
             如果没有要求重新开价格或者没有按照小数点后的数字正常化,错误129 (ERR_INVALID_PRICE)将会生成.
             如果请求开价格的日期完全过期,错误138 (ERR_REQUOTE)将会生成.
             如果请求的价格是过时的,仓位只能够在当前价格位打开/只有当前价格位在price+-slippage范围内.
</p>
            <p>止损和赢利水平线不能够关闭市场. 最小距离的终止水平点可以使用MarketInfo ()函数得到MODE_STOPLEVEL参量。
            在错误或水平位不正常停止情况下,错误130 (ERR_INVALID_STOPS)将会生成.
</p>
            <p>在挂单的位置,开价格不能够终止市场活动.
             最小距离的终止水平点可以使用MarketInfo ()函数得到MODE_STOPLEVEL参量。
            在错误或水平位不正常停止情况下,错误130 (ERR_INVALID_STOPS)将会生成.
</p>
            <p>挂单交易的期限在一些服务器上禁止应用。这种情况下，一个特殊的非零值的参量将会产生，错误
            147 (ERR_TRADE_EXPIRATION_DENIED)将会生成。
            </p>
            <p>在一些服务器上，开仓和挂单交易的总数会被限定。如果超出限定，则不能开启新仓位。这样交易服务器返回到错误
            148 (ERR_TRADE_TOO_MANY_ORDERS)。  </p>
            <p><br>
              <br>
</content>
<example>
  int ticket;
  if(iRSI(NULL,0,14,PRICE_CLOSE,0)&lt;25)
    {
     ticket=OrderSend(Symbol(),OP_BUY,1,Ask,3,Ask-25*Point,Ask+25*Point,&quot;My order #2&quot;,16384,0,Green);
     if(ticket&lt;0)
       {
        Print("OrderSend 失败错误 #",GetLastError());
        return(0);
       }
    }
</example>
<parameter>
type=string
name=symbol
description=交易货币对。
</parameter>
<parameter>
type=int
name=cmd
description=购买方式。可以是<a href="help://constants_trading">购买方式列举</a>的任意值。
</parameter>
<parameter>
type=double
name=volume
description=购买手数。
</parameter>
<parameter>
type=double
name=price
description=收盘价格。
</parameter>
<parameter>
type=int
name=slippage
description=最大允许滑点数。
</parameter>
<parameter>
type=double
name=stoploss
description=止损水平。
</parameter>
<parameter>
type=double
name=takeprofit
description=赢利水平。
</parameter>
<parameter>
type=
name=comment
description=注解文本。注解的最后部分可以由服务器改变。
</parameter>
<parameter>
type=
name=magic
description=定单指定码。可以作为用户指定识别码使用。
</parameter>
<parameter>
type=
name=expiration
description=定单有效时间(只限挂单)。
</parameter>
<parameter>
type=
name=arrow_color
description=图表上箭头颜色。如果参量丢失或存在CLR_NONE价格值不会在图表中画出。
</parameter>
</function>
<function>
tag=trading_OrdersHistoryTotal
caption=OrdersHistoryTotal()
type=int
<keywords>
;OrdersHistoryTotal();
</keywords>
<content>
 在账户历史返回关闭定单数加载进入终端。历史列表的大小取决于终端的&quot;帐户历史&quot; 表格的当前的设置.
</content>
<example>
  // 来自交易历史的恢复信息
  int i,hstTotal=OrdersHistoryTotal();
  for(i=0;i&lt;hstTotal;i++)
    {
     //---- 检查选择结果
     if(OrderSelect(i,SELECT_BY_POS,MODE_HISTORY)==false)
       {
        Print(&quot;带有 (&quot;,GetLastError(),&quot;)错误的历史失败通道&quot;);
        break;
       }
     // 定单的一些工作
</example>
</function>
<function>
tag=trading_OrderStopLoss
caption=OrderStopLoss()
type=double
<keywords>
;OrderStopLoss();
</keywords>
<content>
对于当前选择定单返回止损值。<br/>
注解:定单必须用<a href="help://trading_OrderSelect">OrderSelect()</a>函数提前选定。
</content>
<example>
  if(OrderSelect(ticket,SELECT_BY_POS)==true)
    Print(&quot;对于10 止损值&quot;, OrderStopLoss());
  else
   Print(&quot;OrderSelect 失败错误代码是&quot;,GetLastError());
</example>
</function>
<function>
tag=trading_OrdersTotal
caption=OrdersTotal()
type=int
<keywords>
;OrdersTotal();
</keywords>
<content>
返回市场和挂单的总数<br/>
</content>
<example>
  int handle=FileOpen("OrdersReport.csv",FILE_WRITE|FILE_CSV,"\t");
  if(handle&lt;0) return(0);
  // 写标题
  FileWrite(handle,&quot;#&quot;,&quot;开价格&quot;,&quot;买入时间&quot;,&quot;货币对&quot;,&quot;手数&quot;);
  int total=OrdersTotal();
  // 编写定单命令
  for(int pos=0;pos&lt;total;pos++)
    {
     if(OrderSelect(pos,SELECT_BY_POS)==false) continue;
     FileWrite(handle,OrderTicket(),OrderOpenPrice(),OrderOpenTime(),OrderSymbol(),OrderLots());
    }
  FileClose(handle);
</example>
</function>
<function>
tag=trading_OrderSwap
caption=OrderSwap()
type=double
<keywords>
;OrderSwap();
</keywords>
<content>
对于当前选择定单返回掉期值。<br/>
注解:定单必须用<a href="help://trading_OrderSelect">OrderSelect()</a>函数提前选定。
</content>
<example>
  if(OrderSelect(order_id, SELECT_BY_TICKET)==true)
    Print(&quot;对于定单 #掉期&quot;, order_id, &quot; &quot;,OrderSwap());
  else
   Print(&quot;OrderSelect 失败错误代码是&quot;,GetLastError());
</example>
</function>
<function>
tag=trading_OrderSymbol
caption=OrderSymbol()
type=string
<keywords>
;OrderSymbol();
</keywords>
<content>
对于选择定单返回定单货币对值。<br/>
注解:定单必须用<a href="help://trading_OrderSelect">OrderSelect()</a>函数提前选定。
</content>
<example>
  if(OrderSelect(12, SELECT_BY_POS)==true)
    Print(&quot;定单 #货币对&quot;, OrderTicket(), &quot; is &quot;, OrderSymbol());
  else
   Print(&quot;OrderSelect 失败错误代码是&quot;,GetLastError());
</example>
</function>
<function>
tag=trading_OrderTakeProfit
caption=OrderTakeProfit()
type=double
<keywords>
;OrderTakeProfit();
</keywords>
<content>
对于当前选择定单返回赢利值。<br/>
注解:定单必须用<a href="help://trading_OrderSelect">OrderSelect()</a>函数提前选定。
</content>
<example>
  if(OrderSelect(12, SELECT_BY_POS)==true)
    Print(&quot;定单 #&quot;,OrderTicket(),&quot; 盈利: &quot;, OrderTakeProfit());
  else
    Print(&quot;OrderSelect() 返回错误 - &quot;,GetLastError());
</example>
</function>
<function>
tag=trading_OrderTicket
caption=OrderTicket()
type=int
<keywords>
;OrderTicket();
</keywords>
<content>
对于当前选择定单返回定单编号。<br/>
注解:定单必须用<a href="help://trading_OrderSelect">OrderSelect()</a>函数提前选定。
</content>
<example>
  if(OrderSelect(12, SELECT_BY_POS)==true)
    order=OrderTicket();
  else
   Print(&quot;OrderSelect 失败错误代码&quot;,GetLastError());
</example>
</function>
<function>
tag=trading_OrderType
caption=OrderType()
type=int
<keywords>
;OrderType();
</keywords>
<content>
对于当前选择定单返回定单类型。可以是以下的任意值:<br/>
OP_BUY -买进,<br/>
OP_SELL - 卖出，<br/>
OP_BUYLIMIT - 挂单买入限定，<br/>
OP_BUYSTOP - 挂单停止限定，<br/>
OP_SELLLIMIT - 挂单卖出限定,<br/>
OP_SELLSTOP - 挂单停止限定。<br/>
注解: 定单必须由<a href="help://trading_OrderSelect">OrderSelect()</a>函数选择。
</content>
<example>
  int order_type;
  if(OrderSelect(12, SELECT_BY_POS)==true)
    {
     order_type=OrderType();
     // ...
    }
  else
    Print(&quot;OrderSelect() 返回错误 - &quot;,GetLastError());
</example>
</function>
</group>
<group>
tag=windows
caption=Window functions
<keywords>
;Window functions;
</keywords>
<content>
        当前图表窗口的一组函数。

</content>
<function>
tag=windows_HideTestIndicators
caption=HideTestIndicators()
type=void
<keywords>
;HideTestIndicators();
</keywords>
<content>
      函数设置使用智能交易隐藏指标。在交易被测试以后打开相应的图表，标出的指标将不会出现在测试图表中。
       查看每个指标需应用当前隐藏的标记和第一个标记。<br/>必须注明只有这些指标才可以在测试图表中画出。
</content>
<example>
   HideTestIndicators(true);
   MaCurrent=iMA(NULL,0,56,0,MODE_EMA,PRICE_CLOSE,0);
   MaPrevious=iMA(NULL,0,56,0,MODE_EMA,PRICE_CLOSE,1);
   HideTestIndicators(false);
</example>
<parameter>
type=bool
name=hide
description=如果需要隐藏指标为TRUE，否则为FALSE。
</parameter>
</function>
<function>
tag=windows_Period
caption=Period()
type=int
<keywords>
;Period();
</keywords>
<content>
      返回使用 <a href="help://constants_timeframes">周期</a> (图表周期)的分钟总数。
</content>
<example>
  Print(&quot;时间周期 &quot;, Period());
</example>
</function>
<function>
tag=windows_RefreshRates
caption=RefreshRates()
type=bool
<keywords>
;RefreshRates();
</keywords>
<content>
 刷新<a href="help://predefined_variables">预定义变量和系列数组的数据</a>。在智能交易计算时间过长时，这个功能可以自动更新数据。如果数据刷新，返回到TRUE， 否则返回到FALSE。只有在客户端内的数据不被更新。如果数据已经更新，接下来输入的行情也一样被更新。<br/><br/>
智能交易和脚本只管理本身历史数据的复制本。在智能交易和脚本第一次<a href="help://runtime_start">开启</a> 的时候，当前的商品数据已经复制。 每次智能或脚本开启时，最初的复制本会更新。智能和脚本运作时，数据可能已经过期。
</content>
<example>
   int ticket;
   while(true)
     {
      ticket=OrderSend(Symbol(),OP_BUY,1.0,Ask,3,0,0,&quot;expert comment&quot;,255,0,CLR_NONE);
      if(ticket&lt;=0)
        {
         int error=GetLastError();
         //---- 资金不足
         if(error==134) break;
         //---- 10 秒钟等待
         Sleep(10000);
         //---- 刷新价格数据
         RefreshRates();
         break;
        }
      else
        {
         OrderSelect(ticket,SELECT_BY_TICKET);
         OrderPrint();
         break;
        }
     }
</example>
</function>
<function>
tag=windows_Symbol
caption=Symbol()
type=string
<keywords>
;Symbol();
</keywords>
<content>
     带有当前货币对名称返回字串符文本。
</content>
<example>
   int total=OrdersTotal();
   for(int pos=0;pos&lt;total;pos++)
     {
      // 因为此时可能平单或删除定单，检测选择结果!
      if(OrderSelect(pos, SELECT_BY_POS)==false) continue;
      if(OrderType()&gt;OP_SELL || OrderSymbol()!=Symbol()) continue;
      // 执行过程...
     }
</example>
</function>
<function>
tag=windows_WindowBarsPerChart
caption=WindowBarsPerChart()
type=int
<keywords>
;WindowBarsPerChart();
</keywords>
<content>
     在图表上函数返回可见柱总数。
</content>
<example>
// 对于可见柱工作。
int bars_count=WindowBarsPerChart();
int bar=WindowFirstVisibleBar();
for(int i=0; i&lt;bars_count; i++,bar--)
  {
   // ...
  }
</example>
</function>
<function>
tag=windows_WindowExpertName
caption=WindowExpertName()
type=string
<keywords>
;WindowExpertName();
</keywords>
<content>
从调用函数返回MQL4程序中独立执行智能交易，脚本，客户指标和数据库的名称。
</content>
<example>
string name=WindowExpertName();
GlobalVariablesDeleteAll(name);
</example>
</function>
<function>
tag=windows_WindowFind
caption=WindowFind()
type=int
<keywords>
;WindowFind();
</keywords>
<content>
如果发现指标 <i>名称</i>，函数返回包含特殊指标的窗口索引，否则返回 -1。<br/>
注解: 如果当<i>init()</i>函数运行时，客户指标搜索到本身，则WindowFind()函数返回 -1 。
</content>
<example>
int win_idx=WindowFind(&quot;MACD(12,26,9)&quot;);
</example>
<parameter>
type=string
name=name
description=指标简称。
</parameter>
</function>
<function>
tag=windows_WindowFirstVisibleBar
caption=WindowFirstVisibleBar()
type=int
<keywords>
;WindowFirstVisibleBar();
</keywords>
<content>
在当前图表窗口函数返回第一个可见柱。必须考虑到价格柱的逆序编号，即从最后一 价格数组中的最后一个指示为0。最老得柱被索引为<a href="help://predefined_variables_Bars">柱</a>-1。
如果第一个柱的编码为2 或少于<a href="help://windows_WindowBarsPerChart">图表中可见柱的总数</a>，
意味着图表窗口没有被完整填充。
</content>
<example>
   // 可见柱的工作
   int bars_count=WindowBarsPerChart();
   int bar=WindowFirstVisibleBar();
   for(int i=0; i&lt;bars_count; i++,bar--)
     {
      // ...
     }
</example>
</function>
<function>
tag=windows_WindowHandle
caption=WindowHandle()
type=int
<keywords>
;WindowHandle();
</keywords>
<content>
       返回包含特定图表的系统窗口。 如果<i>货币对</i>和 <i>时间周期</i>的图表暂时还没有开启，显示为0。

        <br/>
</content>
<example>
  int win_handle=WindowHandle("USDX",PERIOD_H1);
  if(win_handle!=0)
    Print(&quot;发现带有USDX,H1 的窗口。数组将会被立即复制。&quot;);
</example>
<parameter>
type=string
name=symbol
description=货币对名称。
</parameter>
<parameter>
type=int
name=timeframe
description=时间周期。可以是<a href="help://constants_timeframes">时间周期列举</a>的任意值。 0意味着当前图表的时间周期。
</parameter>
</function>
<function>
tag=windows_WindowIsVisible
caption=WindowIsVisible()
type=bool
<keywords>
;WindowIsVisible();
</keywords>
<content>
      如果图表在子窗口中可见，返回TRUE，否则返回FALSE。 子图表窗口可以隐藏于指标的可见属性位置。
</content>
<example>
  int maywin=WindowFind("MyMACD");
  if(maywin&gt;-1 &amp;&amp; WindowIsVisible(maywin)==true)
    Print("MyMACD窗口可见");
  else
    Print(" MyMACD窗口未发现或不可见");
</example>
<parameter>
type=int
name=index
description=图表自窗口索引。
</parameter>
</function>
<function>
tag=windows_WindowOnDropped
caption=WindowOnDropped()
type=int
<keywords>
;WindowOnDropped();
</keywords>
<content>
       返回智能交易，客户指标和脚本的绑定窗口索引。 只有在智能交易、客户指标或脚本应用鼠标的帮助下，绑定的值是准确的。<br/>
       注解：对于客户指标初始化(调用 <i>init()</i>函数)，此索引不被定义。<br/>
返回的索引被窗口编码(0为主菜单图表，指标子窗口的开始数字为1 )。 在运行期间客户指标可以创建子窗口，子窗口的编码不同于。<br/>
        <b>参见</b> <a href="help://windows_WindowXOnDropped">WindowXOnDropped()</a>, <a href="help://windows_WindowYOnDropped">WindowYOnDropped()</a>
</content>
<example>
if(WindowOnDropped()!=0)
  {
   Print("指标'MyIndicator'必须被主图表窗口接受!");
   return(false);
  }
</example>
</function>
<function>
tag=windows_WindowPriceMax
caption=WindowPriceMax()
type=double
<keywords>
;WindowPriceMax();
</keywords>
<content>
返回当前图表指定子窗口的最大垂直标度的值(0为主菜单图表，指标子窗口的开始数字为1 )。 如果子窗口没有指定，最大价格标度的值返回图表窗口。
<br/>
 <b>参见</b> <a href="help://windows_WindowPriceMin">WindowPriceMin()</a>, <a href="help://windows_WindowFirstVisibleBar">WindowFirstVisibleBar()</a>, <a href="help://windows_WindowBarsPerChart">WindowBarsPerChart()</a>
</content>
<example>
double   top=WindowPriceMax();
double   bottom=WindowPriceMin();
datetime left=Time[WindowFirstVisibleBar()];
int      right_bound=WindowFirstVisibleBar()-WindowBarsPerChart();
if(right_bound<0) right_bound=0;
datetime right=Time[right_bound]+Period()*60;
//----
ObjectCreate(&quot;Padding_rect&quot;,OBJ_RECTANGLE,0,left,top,right,bottom);
ObjectSet(&quot;Padding_rect&quot;,OBJPROP_BACK,true);
ObjectSet(&quot;Padding_rect&quot;,OBJPROP_COLOR,Blue);
WindowRedraw();
</example>
<parameter>
type=
name=index
description=图表子窗口索引 (0 -主图表窗口)。
</parameter>
</function>
<function>
tag=windows_WindowPriceMin
caption=WindowPriceMin()
type=double
<keywords>
;WindowPriceMin();
</keywords>
<content>
返回当前图表指定子窗口的最小垂直标度的价格值(0为主菜单图表，指标子窗口的开始数字为1 )。 如果子窗口没有指定，最小价格标度的价格值返回图表窗口。
<br/>
  <b>参见</b> <a href="help://windows_WindowPriceMax">WindowPriceMax()</a>, <a href="help://windows_WindowFirstVisibleBar">WindowFirstVisibleBar()</a>, <a href="help://windows_WindowBarsPerChart">WindowBarsPerChart()</a>
</content>
<example>
double   top=WindowPriceMax();
double   bottom=WindowPriceMin();
datetime left=Time[WindowFirstVisibleBar()];
int      right_bound=WindowFirstVisibleBar()-WindowBarsPerChart();
if(right_bound<0) right_bound=0;
datetime right=Time[right_bound]+Period()*60;
//----
ObjectCreate(&quot;Padding_rect&quot;,OBJ_RECTANGLE,0,left,top,right,bottom);
ObjectSet(&quot;Padding_rect&quot;,OBJPROP_BACK,true);
ObjectSet(&quot;Padding_rect&quot;,OBJPROP_COLOR,Blue);
WindowRedraw();
</example>
<parameter>
type=
name=index
description=图表子窗口索引 (0 - 主图表窗口)。
</parameter>
</function>
<function>
tag=windows_WindowPriceOnDropped
caption=WindowPriceOnDropped()
type=double
<keywords>
;WindowPriceOnDropped();
</keywords>
<content>
返回图表指出的智能交易或脚本价格下滑价格部分。 只有在智能交易、客户指标或脚本应用鼠标的情况下，绑定的值是准确的。
注解: 对于客户指标的值是不确定的。 
</content>
<example>
  double   drop_price=WindowPriceOnDropped();
  datetime drop_time=WindowTimeOnDropped();
  //---- 可能未指定 (zero)
  if(drop_time&gt;0)
    {
     ObjectCreate(&quot;价格下滑水平&quot;, OBJ_HLINE, 0, drop_price);
     ObjectCreate(&quot;下滑时间&quot;, OBJ_VLINE, 0, drop_time);
    }
</example>
</function>
<function>
tag=windows_WindowRedraw
caption=WindowRedraw()
type=void
<keywords>
;WindowRedraw();
</keywords>
<content>
      重新画出当前图表。在货币对属性改变之后应用。 
</content>
<example>
  //---- 对于货币对设置新属性
  ObjectMove(object_name1, 0, Time[index], price);
  ObjectSet(object_name1, OBJPROP_ANGLE, angle*2);
  ObjectSet(object_name1, OBJPROP_FONTSIZE, fontsize);
  ObjectSet(line_name, OBJPROP_TIME2, time2);
  ObjectSet(line_name, OBJPROP_ANGLE, line_angle);
  //---- 现在重画
  WindowRedraw();
</example>
</function>
<function>
tag=windows_WindowScreenShot
caption=WindowScreenShot()
type=bool
<keywords>
;WindowScreenShot();
</keywords>
<content>
以GIF 文件形式保存当前图像。如果失败，返回FALSE。详细错误信息，查看 <a href="help://check_GetLastError">GetLastError()</a> 函数。<br/>
图像被储存在<em>terminal_dir\experts\files</em> (<em>terminal_dir\tester\files</em> 测试情况下) 目录中或是子目录。
</content>
<example>
  int lasterror=0;
  //----测试者平仓或多个仓
  if(IsTesting() &amp;&amp; ExtTradesCounter&lt;TradesTotal())
    {
     //---- 使WindowScreenShot 进行检测
     if(!WindowScreenShot("shots\\tester"+ExtShotsCounter+".gif",640,480))
        lasterror=GetLastError();
     else ExtShotsCounter++;
     ExtTradesCounter=TradesTotal();
    }
</example>
<parameter>
type=string
name=filename
description=屏幕映像文件名称。
</parameter>
<parameter>
type=int
name=size_x
description=屏幕宽度映像点。
</parameter>
<parameter>
type=int
name=size_y
description=屏幕高度影响点。
</parameter>
<parameter>
type=
name=start_bar
description=I第一个可见柱的屏幕映像。如果价格值设定为 0 ，当前的<a href="help://windows_WindowFirstVisibleBar">第一个可见柱</a> 将被除去。如果价格值为负值， 结束图的映像将会产生。
</parameter>
<parameter>
type=
name=chart_scale
description=对于屏幕映像水平的图标度。 可以在范围从0到5之间。 如果没有值或者为负值，当前图表将被应用。
</parameter>
<parameter>
type=
name=chart_mode
description=图表显示模式。可以是以下价格值: ICHART_BAR (0 是柱的次序), CHART_CANDLE (1 是蜡烛柱的次序）,CHART_LINE (2 是收盘价格线)。如果没有价格值或者为负值，图表会以当前模式显示。
</parameter>
</function>
<function>
tag=windows_WindowTimeOnDropped
caption=WindowTimeOnDropped()
type=datetime
<keywords>
;WindowTimeOnDropped();
</keywords>
<content>
返回图表指出的智能交易或脚本价格下滑时间部分。 只有在智能交易、客户指标或脚本应用鼠标的帮助下，绑定的值是准确的。
 <br/>注解: 对于客户指标的价格值是不确定的。
</content>
<example>
  double   drop_price=WindowPriceOnDropped();
  datetime drop_time=WindowTimeOnDropped();
  //---- 可能未指定 (zero)
  if(drop_time&gt;0)
    {
     ObjectCreate("Dropped price line", OBJ_HLINE, 0, drop_price);
     ObjectCreate("Dropped time line", OBJ_VLINE, 0, drop_time);
    }
</example>
</function>
<function>
tag=windows_WindowsTotal
caption=WindowsTotal()
type=int
<keywords>
;WindowsTotal();
</keywords>
<content>
     返回在图表中指标窗口数(包括主图表)。 
</content>
<example>
Print(&quot;窗口数 = &quot;, WindowsTotal());
</example>
</function>
<function>
tag=windows_WindowXOnDropped
caption=WindowXOnDropped()
type=int
<keywords>
;WindowXOnDropped();
</keywords>
<content>
当以映像点X轴图表窗口的客户区域智能交易或脚本下滑时，返回价格值。 只有在智能交易、客户指标或脚本应用鼠标(&quot;Drag'n'Drop&quot;) 的情况下，绑定的值是准确的。
<br/>
        <b>参见</b> <a href="help://windows_WindowYOnDropped">WindowYOnDropped()</a>, <a href="help://windows_WindowOnDropped">WindowOnDropped()</a>
</content>
<example>
Print("智能交易下滑点 x=",WindowXOnDropped()," y=",WindowYOnDropped());
</example>
</function>
<function>
tag=windows_WindowYOnDropped
caption=WindowYOnDropped()
type=int
<keywords>
;WindowYOnDropped();
</keywords>
<content>
当以映像点Y轴图表窗口的客户区域智能交易或脚本下滑时，返回价格值。 只有在智能交易、客户指标或脚本应用鼠标(&quot;Drag'n'Drop&quot;)的帮助下，绑定的值是准确的。
<br/>
<b>参见</b> <a href="help://windows_WindowXOnDropped">WindowXOnDropped()</a>, <a href="help://windows_WindowPriceOnDropped">WindowPriceOnDropped()</a>, <a href="help://windows_WindowOnDropped">WindowOnDropped()</a>
</content>
<example>
  Print" 被获取智能交易到窗口的点x=",WindowXOnDropped()," y=",WindowYOnDropped());
</example>
</function>
</group>
<group>
tag=obsolete
caption=Obsolete functions
<keywords>
;Obsolete functions;
</keywords>
<content>
          <p>MQL4程序在不断的完善发展中，由于系统化的需要，一些名称被重新命名。旧的功能名称与MetaEditor资料无法连接。有时，编辑器会以适当的途径接纳。不过，我们还是要求使用新名称。</p>
      <table cellspacing="0" cellpadding="4" border="0" class="docenums">
      <tr><th width="50%">旧名称</th><th width="50%">新名称</th></tr>
      <tr><td>BarsPerWindow</td><td><a href="help://windows_WindowBarsPerChart">WindowBarsPerChart</a></td></tr>
      <tr><td>ClientTerminalName</td><td><a href="help://terminal_TerminalName">TerminalName</a></td></tr>
      <tr><td>CurTime</td><td><a href="help://dateandtime_TimeCurrent">TimeCurrent</a></td></tr>
      <tr><td>CompanyName</td><td><a href="help://terminal_TerminalCompany">TerminalCompany</a></td></tr>
      <tr><td>FirstVisibleBar</td><td><a href="help://windows_WindowFirstVisibleBar">WindowFirstVisibleBar</a></td></tr>
      <tr><td>Highest</td><td><a href="help://series_iHighest">iHighest</a></td></tr>
      <tr><td>HistoryTotal</td><td><a href="help://trading_OrdersHistoryTotal">OrdersHistoryTotal</a></td></tr>
      <tr><td>LocalTime</td><td><a href="help://dateandtime_TimeLocal">TimeLocal</a></td></tr>
      <tr><td>Lowest</td><td><a href="help://series_iLowest">iLowest</a></td></tr>
      <tr><td>ObjectsRedraw</td><td><a href="help://windows_WindowRedraw">WindowRedraw</a>,</td></tr>
      <tr><td>PriceOnDropped</td><td><a href="help://windows_WindowPriceOnDropped">WindowPriceOnDropped</a></td></tr>
      <tr><td>ScreenShot</td><td><a href="help://windows_WindowScreenShot">WindowScreenShot</a></td></tr>
      <tr><td>ServerAddress</td><td><a href="help://account_AccountServer">AccountServer</a></td></tr>
      <tr><td>TimeOnDropped</td><td><a href="help://windows_WindowTimeOnDropped">WindowTimeOnDropped</a></td></tr>
      </table><br/>

</content>
</group>
</group>
</dictionary>
